---
title: 複合的名字
description: 其中一個最有用的名字，就是您可以同時串連或撰寫名字標記。
ms.assetid: ea2453f3-7a64-4ce0-87c2-de6224ca71df
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5b5375bb505ff3737fb4e0cdea894790d93c0051
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/16/2019
ms.locfileid: "103675716"
---
# <a name="composite-monikers"></a><span data-ttu-id="5c370-103">複合的名字</span><span class="sxs-lookup"><span data-stu-id="5c370-103">Composite Monikers</span></span>

<span data-ttu-id="5c370-104">其中一個最有用的名字，就是您可以同時串連或撰寫名字標記。</span><span class="sxs-lookup"><span data-stu-id="5c370-104">One of the most useful features of monikers is that you can concatenate or compose monikers together.</span></span> <span data-ttu-id="5c370-105">*複合的標記* 是標記，是其他標記的組合，而且可以決定元件之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="5c370-105">A *composite moniker* is a moniker that is a composition of other monikers and can determine the relation between the parts.</span></span> <span data-ttu-id="5c370-106">這可讓您將具有相同部分路徑的兩個或多個名字標記之物件的完整路徑組合在一起。</span><span class="sxs-lookup"><span data-stu-id="5c370-106">This lets you assemble the complete path to an object given two or more monikers that are the equivalent of partial paths.</span></span> <span data-ttu-id="5c370-107">您可以撰寫相同類別 (的名字，例如兩個檔案的標記) 或不同類別 (例如檔案的名字和專案的標記) 。</span><span class="sxs-lookup"><span data-stu-id="5c370-107">You can compose monikers of the same class (such as two file monikers) or of different classes (such as a file moniker and an item moniker).</span></span> <span data-ttu-id="5c370-108">如果您要撰寫自己的「名字標記」類別，您也可以使用檔案或專案的名字寫來撰寫您的名字。</span><span class="sxs-lookup"><span data-stu-id="5c370-108">If you were to write your own moniker class, you could also compose your monikers with file or item monikers.</span></span> <span data-ttu-id="5c370-109">複合的基本優點是它會提供您一段程式碼，以實作為更簡單的名字組組合的每個可能的標記。</span><span class="sxs-lookup"><span data-stu-id="5c370-109">The basic advantage of a composite is that it gives you one piece of code to implement every possible moniker that is a combination of simpler monikers.</span></span> <span data-ttu-id="5c370-110">這可大幅減少特定自訂的「標記」類別的需求。</span><span class="sxs-lookup"><span data-stu-id="5c370-110">That significantly reduces the need for specific custom moniker classes.</span></span>

<span data-ttu-id="5c370-111">因為不同類別的名字可由另一個類別組成，所以名字可提供聯結多個命名空間的能力。</span><span class="sxs-lookup"><span data-stu-id="5c370-111">Because monikers of different classes can be composed with one another, monikers provide the ability to join multiple namespaces.</span></span> <span data-ttu-id="5c370-112">檔案系統會針對儲存為檔案的物件定義通用命名空間，因為所有應用程式都瞭解檔案系統路徑名稱。</span><span class="sxs-lookup"><span data-stu-id="5c370-112">The file system defines a common namespace for objects stored as files because all applications understand a file system path name.</span></span> <span data-ttu-id="5c370-113">同樣地，容器物件也會定義其所包含之物件的私用命名空間，因為沒有任何容器可理解另一個容器所產生的名稱。</span><span class="sxs-lookup"><span data-stu-id="5c370-113">Similarly, a container object also defines a private namespace for the objects that it contains because no container understands the names generated by another container.</span></span> <span data-ttu-id="5c370-114">因為可以組成檔案的標記和專案的名字標記，所以標記允許聯結這些命名空間。</span><span class="sxs-lookup"><span data-stu-id="5c370-114">Monikers allow these namespaces to be joined because file monikers and item monikers can be composed.</span></span> <span data-ttu-id="5c370-115">標記用戶端可以使用單一機制來搜尋所有物件的命名空間。</span><span class="sxs-lookup"><span data-stu-id="5c370-115">A moniker client can search the namespace for all objects using a single mechanism.</span></span> <span data-ttu-id="5c370-116">用戶端只會在標記上呼叫 [**IMoniker：： BindToObject**](/windows/desktop/api/ObjIdl/nf-objidl-imoniker-bindtoobject) ，而此標記代碼會處理其餘部分。</span><span class="sxs-lookup"><span data-stu-id="5c370-116">The client simply calls [**IMoniker::BindToObject**](/windows/desktop/api/ObjIdl/nf-objidl-imoniker-bindtoobject) on the moniker, and the moniker code handles the rest.</span></span> <span data-ttu-id="5c370-117">在複合上呼叫 [**IMoniker：： GetDisplayName**](/windows/desktop/api/ObjIdl/nf-objidl-imoniker-getdisplayname) ，會使用所有個別的名字標記之顯示名稱的串連來建立名稱。</span><span class="sxs-lookup"><span data-stu-id="5c370-117">A call to [**IMoniker::GetDisplayName**](/windows/desktop/api/ObjIdl/nf-objidl-imoniker-getdisplayname) on a composite creates a name using the concatenation of all the individual monikers' display names.</span></span>

<span data-ttu-id="5c370-118">此外，由於您可以撰寫自己的「標記」類別，因此，「標記撰寫」可讓您將自訂延伸加入至物件的命名空間。</span><span class="sxs-lookup"><span data-stu-id="5c370-118">Furthermore, because you can write your own moniker class, moniker composition allows you to add customized extensions to the namespace for objects.</span></span>

<span data-ttu-id="5c370-119">有時可以使用特殊方式結合特定類別的兩個名字標記。</span><span class="sxs-lookup"><span data-stu-id="5c370-119">Sometimes two monikers of specific classes can be combined in a special way.</span></span> <span data-ttu-id="5c370-120">例如，代表不完整路徑的檔案表示檔和另一個代表相對路徑的檔案表示檔，都可以合併成單一檔案的標記，代表完整的路徑。</span><span class="sxs-lookup"><span data-stu-id="5c370-120">For example, a file moniker representing an incomplete path and another file moniker representing a relative path can be combined to form a single file moniker representing the complete path.</span></span> <span data-ttu-id="5c370-121">例如，檔案的標記「c： \\ 工作 \\ 美工」可能由相對檔案的「名字標記」組成」。 \\備份 \\myfile.doc 「等於」 c： \\ work \\ 備份myfile.doc」 \\ 。</span><span class="sxs-lookup"><span data-stu-id="5c370-121">For example, the file monikers "c:\\work\\art" could be composed with the relative file moniker "..\\backup\\myfile.doc" to equal "c:\\work\\backup\\myfile.doc".</span></span> <span data-ttu-id="5c370-122">這是 *非泛型組合* 的範例。</span><span class="sxs-lookup"><span data-stu-id="5c370-122">This is an example of *nongeneric composition*.</span></span>

<span data-ttu-id="5c370-123">另一方面，*泛型組合* 允許任何兩個標記的連接，無論其類別為何。</span><span class="sxs-lookup"><span data-stu-id="5c370-123">*Generic composition*, on the other hand, permits the connection of any two monikers, no matter what their classes.</span></span> <span data-ttu-id="5c370-124">例如，您可以將專案的標記撰寫到檔案的名字標記上，不過當然不是如此。</span><span class="sxs-lookup"><span data-stu-id="5c370-124">For example, you could compose an item moniker onto a file moniker, although not, of course, the other way around.</span></span>

<span data-ttu-id="5c370-125">因為非泛型組合取決於所涉及的名字標記類別，所以其詳細資料是由特定的標記類別的實作為定義。</span><span class="sxs-lookup"><span data-stu-id="5c370-125">Because a nongeneric composition depends on the class of the monikers involved, its details are defined by the implementation of a particular moniker class.</span></span> <span data-ttu-id="5c370-126">如果您撰寫新的 [標記] 類別，則可以定義新的非泛型組合類型。</span><span class="sxs-lookup"><span data-stu-id="5c370-126">You can define new types of nongeneric compositions if you write a new moniker class.</span></span> <span data-ttu-id="5c370-127">相反地，泛型組合是由 OLE 定義。</span><span class="sxs-lookup"><span data-stu-id="5c370-127">By contrast, generic compositions are defined by OLE.</span></span> <span data-ttu-id="5c370-128">作為泛型撰寫結果而建立的標記稱為泛型複合標記。</span><span class="sxs-lookup"><span data-stu-id="5c370-128">Monikers created as a result of generic composition are called generic composite monikers.</span></span>

<span data-ttu-id="5c370-129">這三個類別、檔案擁有者、專案的名字和泛型複合標記、全部一起運作，而且是最常用的標記類別。</span><span class="sxs-lookup"><span data-stu-id="5c370-129">These three classes, file monikers, item monikers, and generic composite monikers, all work together, and they are the most commonly used classes of monikers.</span></span>

<span data-ttu-id="5c370-130">標記用戶端應該呼叫 [**IMoniker：： ComposeWith**](/windows/desktop/api/ObjIdl/nf-objidl-imoniker-composewith) ，在具有另一個的標記上建立複合。</span><span class="sxs-lookup"><span data-stu-id="5c370-130">Moniker clients should call [**IMoniker::ComposeWith**](/windows/desktop/api/ObjIdl/nf-objidl-imoniker-composewith) to create a composite on moniker with another.</span></span> <span data-ttu-id="5c370-131">它在內部呼叫的標記會決定是否可以進行泛型或非泛型組合。</span><span class="sxs-lookup"><span data-stu-id="5c370-131">The moniker it is called on internally decides whether it can do a generic or nongeneric composition.</span></span> <span data-ttu-id="5c370-132">如果「標記實行」判斷出一般組合可供使用，OLE 會提供 [**CreateGenericComposite**](/windows/desktop/api/Objbase/nf-objbase-creategenericcomposite) 函式來加速這項工作。</span><span class="sxs-lookup"><span data-stu-id="5c370-132">If the moniker implementation determines that a generic composition is usable, OLE provides the [**CreateGenericComposite**](/windows/desktop/api/Objbase/nf-objbase-creategenericcomposite) function to facilitate this.</span></span>

## <a name="related-topics"></a><span data-ttu-id="5c370-133">相關主題</span><span class="sxs-lookup"><span data-stu-id="5c370-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="5c370-134">反標記</span><span class="sxs-lookup"><span data-stu-id="5c370-134">Anti-Monikers</span></span>](anti-monikers.md)
</dt> <dt>

[<span data-ttu-id="5c370-135">類別名字標記</span><span class="sxs-lookup"><span data-stu-id="5c370-135">Class Monikers</span></span>](class-monikers.md)
</dt> <dt>

[<span data-ttu-id="5c370-136">檔案名字</span><span class="sxs-lookup"><span data-stu-id="5c370-136">File Monikers</span></span>](file-monikers.md)
</dt> <dt>

[<span data-ttu-id="5c370-137">專案的名字</span><span class="sxs-lookup"><span data-stu-id="5c370-137">Item Monikers</span></span>](item-monikers.md)
</dt> <dt>

[<span data-ttu-id="5c370-138">指標標記</span><span class="sxs-lookup"><span data-stu-id="5c370-138">Pointer Monikers</span></span>](pointer-monikers.md)
</dt> </dl>

 

 




