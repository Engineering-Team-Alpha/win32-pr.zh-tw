---
description: 執行命名空間延伸的程式類似于任何其他同進程元件物件模型 (COM) 物件。
title: 執行基本資料夾物件介面
ms.topic: article
ms.date: 05/31/2018
ms.assetid: a45b8011-5355-429b-8935-4a7bdb5d2316
api_name: ''
api_type: ''
api_location: ''
topic_type:
- kbArticle
ms.openlocfilehash: c05f5d2e4c21a923856c7324ad2d407230fa7595
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "104973373"
---
# <a name="implementing-the-basic-folder-object-interfaces"></a><span data-ttu-id="a8577-103">執行基本資料夾物件介面</span><span class="sxs-lookup"><span data-stu-id="a8577-103">Implementing the Basic Folder Object Interfaces</span></span>

<span data-ttu-id="a8577-104">執行命名空間延伸的程式類似于任何其他同進程元件物件模型 (COM) 物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-104">The procedure for implementing a namespace extension is similar to that for any other in-process Component Object Model (COM) object.</span></span> <span data-ttu-id="a8577-105">所有延伸模組都必須支援三個主要介面，為 Windows 檔案總管提供在樹狀檢視中顯示延伸模組資料夾所需的基本資訊。</span><span class="sxs-lookup"><span data-stu-id="a8577-105">All extensions must support three primary interfaces that provide Windows Explorer with the basic information needed to display the extension's folders in the tree view.</span></span> <span data-ttu-id="a8577-106">不過，若要充分利用 Windows 檔案總管的功能，您的延伸模組也必須公開一個或多個選用的介面，以支援更複雜的功能，例如快速鍵功能表或拖放功能，以及提供資料夾檢視。</span><span class="sxs-lookup"><span data-stu-id="a8577-106">However, to make full use of the capabilities of Windows Explorer, your extension must also expose one or more optional interfaces that support more sophisticated features, such as shortcut menus or drag-and-drop, and provide a folder view.</span></span>

<span data-ttu-id="a8577-107">本檔將討論如何執行 Windows 檔案總管呼叫您的延伸模組內容相關資訊的主要和選用介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-107">This document discusses how to implement the primary and optional interfaces that Windows Explorer calls for information about the contents of your extension.</span></span> <span data-ttu-id="a8577-108">如需如何執行資料夾檢視和如何自訂 Windows 檔案總管的討論，請參閱 [執行資料夾檢視](../lwef/nse-folderview.md)。</span><span class="sxs-lookup"><span data-stu-id="a8577-108">For a discussion of how to implement a folder view and how to customize Windows Explorer, see [Implementing a Folder View](../lwef/nse-folderview.md).</span></span>

-   [<span data-ttu-id="a8577-109">基本執行和註冊</span><span class="sxs-lookup"><span data-stu-id="a8577-109">Basic Implementation and Registration</span></span>](#basic-implementation-and-registration)
    -   [<span data-ttu-id="a8577-110">註冊擴充功能</span><span class="sxs-lookup"><span data-stu-id="a8577-110">Registering an Extension</span></span>](#registering-an-extension)
-   [<span data-ttu-id="a8577-111">處理 Pidl</span><span class="sxs-lookup"><span data-stu-id="a8577-111">Handling PIDLs</span></span>](#handling-pidls)
    -   [<span data-ttu-id="a8577-112">建立 SHITEMID 結構</span><span class="sxs-lookup"><span data-stu-id="a8577-112">Creating an SHITEMID Structure</span></span>](#creating-an-shitemid-structure)
    -   [<span data-ttu-id="a8577-113">建立 PIDL</span><span class="sxs-lookup"><span data-stu-id="a8577-113">Constructing a PIDL</span></span>](#constructing-a-pidl)
    -   [<span data-ttu-id="a8577-114">解讀 Pidl</span><span class="sxs-lookup"><span data-stu-id="a8577-114">Interpreting PIDLs</span></span>](#interpreting-pidls)
-   [<span data-ttu-id="a8577-115">執行主要介面</span><span class="sxs-lookup"><span data-stu-id="a8577-115">Implementing the Primary Interfaces</span></span>](#implementing-the-primary-interfaces)
    -   [<span data-ttu-id="a8577-116">IPersistFolder 介面</span><span class="sxs-lookup"><span data-stu-id="a8577-116">IPersistFolder Interface</span></span>](#ipersistfolder-interface)
    -   [<span data-ttu-id="a8577-117">IShellFolder 介面</span><span class="sxs-lookup"><span data-stu-id="a8577-117">IShellFolder Interface</span></span>](#ishellfolder-interface)
    -   [<span data-ttu-id="a8577-118">IEnumIDList 介面</span><span class="sxs-lookup"><span data-stu-id="a8577-118">IEnumIDList Interface</span></span>](#ienumidlist-interface)
-   [<span data-ttu-id="a8577-119">執行選用介面</span><span class="sxs-lookup"><span data-stu-id="a8577-119">Implementing the Optional Interfaces</span></span>](#implementing-the-optional-interfaces)
    -   [<span data-ttu-id="a8577-120">IExtractIcon</span><span class="sxs-lookup"><span data-stu-id="a8577-120">IExtractIcon</span></span>](#iextracticon)
    -   [<span data-ttu-id="a8577-121">ICoNtextMenu</span><span class="sxs-lookup"><span data-stu-id="a8577-121">IContextMenu</span></span>](#icontextmenu)
    -   [<span data-ttu-id="a8577-122">IQueryInfo</span><span class="sxs-lookup"><span data-stu-id="a8577-122">IQueryInfo</span></span>](#iqueryinfo)
    -   [<span data-ttu-id="a8577-123">IDataObject 和 IDropTarget</span><span class="sxs-lookup"><span data-stu-id="a8577-123">IDataObject and IDropTarget</span></span>](#idataobject-and-idroptarget)
-   [<span data-ttu-id="a8577-124">使用預設的 Shell 資料夾檢視執行</span><span class="sxs-lookup"><span data-stu-id="a8577-124">Working With the Default Shell Folder View Implementation</span></span>](#working-with-the-default-shell-folder-view-implementation)

## <a name="basic-implementation-and-registration"></a><span data-ttu-id="a8577-125">基本執行和註冊</span><span class="sxs-lookup"><span data-stu-id="a8577-125">Basic Implementation and Registration</span></span>

<span data-ttu-id="a8577-126">作為同進程 COM 伺服器，您的 DLL 必須公開數個標準函式和介面：</span><span class="sxs-lookup"><span data-stu-id="a8577-126">As an in-process COM server, your DLL must expose several standard functions and interfaces:</span></span>

-   [<span data-ttu-id="a8577-127">**DllCanUnloadNow**</span><span class="sxs-lookup"><span data-stu-id="a8577-127">**DllCanUnloadNow**</span></span>](/windows/win32/api/combaseapi/nf-combaseapi-dllcanunloadnow)
-   [<span data-ttu-id="a8577-128">**DllGetClassObject**</span><span class="sxs-lookup"><span data-stu-id="a8577-128">**DllGetClassObject**</span></span>](/windows/win32/api/combaseapi/nf-combaseapi-dllgetclassobject)
-   [<span data-ttu-id="a8577-129">**IClassFactory**</span><span class="sxs-lookup"><span data-stu-id="a8577-129">**IClassFactory**</span></span>](/windows/win32/api/unknwn/nn-unknwn-iclassfactory)
-   [<span data-ttu-id="a8577-130">**IUnknown**</span><span class="sxs-lookup"><span data-stu-id="a8577-130">**IUnknown**</span></span>](/windows/win32/api/unknwn/nn-unknwn-iunknown)

<span data-ttu-id="a8577-131">這些函式和介面的實與大部分其他 COM 物件的執行方式相同。</span><span class="sxs-lookup"><span data-stu-id="a8577-131">These functions and interfaces are implemented in the same way as they are for most other COM objects.</span></span> <span data-ttu-id="a8577-132">如需詳細資訊，請參閱 [COM 檔](../com/the-component-object-model.md)。</span><span class="sxs-lookup"><span data-stu-id="a8577-132">For details, see the [COM documentation](../com/the-component-object-model.md).</span></span>

### <a name="registering-an-extension"></a><span data-ttu-id="a8577-133">註冊擴充功能</span><span class="sxs-lookup"><span data-stu-id="a8577-133">Registering an Extension</span></span>

<span data-ttu-id="a8577-134">如同所有 COM 物件，您必須為您的延伸模組建立 (CLSID) GUID 的類別識別碼。</span><span class="sxs-lookup"><span data-stu-id="a8577-134">As with all COM objects, you must create a class identifier (CLSID) GUID for your extension.</span></span> <span data-ttu-id="a8577-135">藉由針對延伸模組的 CLSID，建立名為的 **HKEY \_ 類別 \_ 根** CLSID 的子機碼，以註冊物件 \\  。</span><span class="sxs-lookup"><span data-stu-id="a8577-135">Register the object by creating a subkey of **HKEY\_CLASSES\_ROOT**\\**CLSID** named for the CLSID of your extension.</span></span> <span data-ttu-id="a8577-136">DLL 應該註冊為同進程伺服器，而且應該指定單元執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="a8577-136">The DLL should be registered as an in-process server and should specify the apartment threading model.</span></span> <span data-ttu-id="a8577-137">您可以藉由將各種子機碼和值新增至延伸模組的 CLSID 機碼，來自訂延伸模組根資料夾的行為。</span><span class="sxs-lookup"><span data-stu-id="a8577-137">You can customize the behavior of an extension's root folder by adding a variety of subkeys and values to the extension's CLSID key.</span></span>

<span data-ttu-id="a8577-138">其中有幾個值僅適用于具有虛擬連接點的擴充功能。</span><span class="sxs-lookup"><span data-stu-id="a8577-138">Several of these values apply only to extensions with virtual junction points.</span></span> <span data-ttu-id="a8577-139">這些值不適用於連接點為檔系統資料夾的延伸模組。</span><span class="sxs-lookup"><span data-stu-id="a8577-139">These values do not apply to extensions whose junction points are file system folders.</span></span> <span data-ttu-id="a8577-140">如需進一步討論，請參閱 [指定命名空間延伸模組的位置](nse-junction.md)。</span><span class="sxs-lookup"><span data-stu-id="a8577-140">For further discussion, see [Specifying a Namespace Extension's Location](nse-junction.md).</span></span> <span data-ttu-id="a8577-141">若要使用虛擬連接點來修改擴充功能的行為，請將下列一或多個值新增至延伸模組的 CLSID 索引鍵：</span><span class="sxs-lookup"><span data-stu-id="a8577-141">To modify the behavior of an extension with a virtual junction point, add one or more of the following values to the extension's CLSID key:</span></span>

-   <span data-ttu-id="a8577-142">WantsFORPARSING.</span><span class="sxs-lookup"><span data-stu-id="a8577-142">WantsFORPARSING.</span></span> <span data-ttu-id="a8577-143">具有虛擬連接點的延伸模組剖析名稱通常會有格式：： {*GUID*}。</span><span class="sxs-lookup"><span data-stu-id="a8577-143">The parsing name for an extension with a virtual junction point will normally have the form ::{*GUID*}.</span></span> <span data-ttu-id="a8577-144">此類型的延伸模組通常包含虛擬專案。</span><span class="sxs-lookup"><span data-stu-id="a8577-144">Extensions of this type normally contain virtual items.</span></span> <span data-ttu-id="a8577-145">不過，某些延伸模組（例如我的檔）實際上會對應到檔系統資料夾，即使它們有虛擬連接點也一樣。</span><span class="sxs-lookup"><span data-stu-id="a8577-145">However, some extensions, such as My Documents, actually correspond to file system folders, even though they have virtual junction points.</span></span> <span data-ttu-id="a8577-146">如果您的延伸模組以這種方式表示檔案系統物件，您可以設定 WantsFORPARSING 值。</span><span class="sxs-lookup"><span data-stu-id="a8577-146">If your extension represents file system objects in this way, you can set the WantsFORPARSING value.</span></span> <span data-ttu-id="a8577-147">Windows 檔案總管接著會呼叫資料夾物件的 [**IShellFolder：： GetDisplayNameOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof) 方法，並將 *UFlags* 設定為 **SHGDN \_ FORPARSING** ，並將 *pidl* 設定為專案識別碼清單 (pidl) 的單一空白指標，藉此要求根資料夾的剖析名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-147">Windows Explorer will then request your root folder's parsing name by calling the folder object's [**IShellFolder::GetDisplayNameOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof) method with *uFlags* set to **SHGDN\_FORPARSING** and *pidl* set to a single empty pointer to an item identifier list (PIDL).</span></span> <span data-ttu-id="a8577-148">空的 PIDL 僅包含結束字元。</span><span class="sxs-lookup"><span data-stu-id="a8577-148">An empty PIDL contains only a terminator.</span></span> <span data-ttu-id="a8577-149">然後，您的方法應該會傳回根資料夾的：： {*GUID*} 剖析名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-149">Your method should then return the root folder's ::{*GUID*} parsing name.</span></span>
-   <span data-ttu-id="a8577-150">HideFolderVerbs.</span><span class="sxs-lookup"><span data-stu-id="a8577-150">HideFolderVerbs.</span></span> <span data-ttu-id="a8577-151">在 **HKEY \_ 類別 \_ 根** 資料夾下註冊的動詞 \\ 通常會與所有延伸模組相關聯。</span><span class="sxs-lookup"><span data-stu-id="a8577-151">The verbs registered under **HKEY\_CLASSES\_ROOT**\\**Folder** normally are associated with all extensions.</span></span> <span data-ttu-id="a8577-152">它們會出現在擴充功能的快捷方式功能表上，可由 [**ShellExecute**](/windows/desktop/api/Shellapi/nf-shellapi-shellexecutea)叫用。</span><span class="sxs-lookup"><span data-stu-id="a8577-152">They appear on the extension's shortcut menu and can be invoked by [**ShellExecute**](/windows/desktop/api/Shellapi/nf-shellapi-shellexecutea).</span></span> <span data-ttu-id="a8577-153">若要防止任何這些動詞與您的延伸模組相關聯，請設定 HideFolderVerbs 值。</span><span class="sxs-lookup"><span data-stu-id="a8577-153">To prevent any of these verbs from being associated with your extension, set the HideFolderVerbs value.</span></span>
-   <span data-ttu-id="a8577-154">HideAsDelete.</span><span class="sxs-lookup"><span data-stu-id="a8577-154">HideAsDelete.</span></span> <span data-ttu-id="a8577-155">如果使用者嘗試刪除您的延伸模組，Windows 檔案總管會改為隱藏延伸模組。</span><span class="sxs-lookup"><span data-stu-id="a8577-155">If a user attempts to delete your extension, Windows Explorer will instead hide the extension.</span></span>
-   <span data-ttu-id="a8577-156">HideAsDeletePerUser.</span><span class="sxs-lookup"><span data-stu-id="a8577-156">HideAsDeletePerUser.</span></span> <span data-ttu-id="a8577-157">此值的效果與 HideAsDelete 相同，但以每個使用者為基礎。</span><span class="sxs-lookup"><span data-stu-id="a8577-157">This value has the same effect as HideAsDelete but on a per-user basis.</span></span> <span data-ttu-id="a8577-158">只有已嘗試刪除的使用者，才會隱藏此延伸模組。</span><span class="sxs-lookup"><span data-stu-id="a8577-158">The extension is hidden only for those users who have attempted to delete it.</span></span> <span data-ttu-id="a8577-159">所有其他使用者都可以看到此延伸模組。</span><span class="sxs-lookup"><span data-stu-id="a8577-159">The extension is visible to all other users.</span></span>
-   <span data-ttu-id="a8577-160">QueryForOverlay.</span><span class="sxs-lookup"><span data-stu-id="a8577-160">QueryForOverlay.</span></span> <span data-ttu-id="a8577-161">設定此值以指出根資料夾的圖示可以有圖示重迭。</span><span class="sxs-lookup"><span data-stu-id="a8577-161">Set this value to indicate that the root folder's icon can have an icon overlay.</span></span> <span data-ttu-id="a8577-162">資料夾物件必須支援 [**IShellIconOverlay**](/windows/win32/api/shlobj_core/nn-shlobj_core-ishelliconoverlay) 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-162">The folder object must support the [**IShellIconOverlay**](/windows/win32/api/shlobj_core/nn-shlobj_core-ishelliconoverlay) interface.</span></span> <span data-ttu-id="a8577-163">在 Windows 檔案總管顯示根資料夾的圖示之前，它會呼叫兩個 **IShellIconOverlay** 方法的其中一個，並將 *pidlItem* 設定為空白 PIDL，以要求重迭圖示。</span><span class="sxs-lookup"><span data-stu-id="a8577-163">Before Windows Explorer displays the root folder's icon, it will request an overlay icon by calling one of the two **IShellIconOverlay** methods with *pidlItem* set to an empty PIDL.</span></span>

<span data-ttu-id="a8577-164">其餘的值和子機碼適用于所有延伸模組：</span><span class="sxs-lookup"><span data-stu-id="a8577-164">The remaining values and subkeys apply to all extensions:</span></span>

-   <span data-ttu-id="a8577-165">若要指定延伸模組的連接點資料夾的顯示名稱，請將擴充功能的 CLSID 子機碼預設值設定為適當的字串。</span><span class="sxs-lookup"><span data-stu-id="a8577-165">To specify the display name of the extension's junction point folder, set the default value of the extension's CLSID subkey to an appropriate string.</span></span>
-   <span data-ttu-id="a8577-166">當游標停留在資料夾上時，通常會顯示描述資料夾內容的提示。</span><span class="sxs-lookup"><span data-stu-id="a8577-166">When the cursor hovers over a folder, an infotip is typically displayed that describes the contents of the folder.</span></span> <span data-ttu-id="a8577-167">若要為您的延伸模組根資料夾提供提示，請建立延伸模組之 CLSID 索引鍵的提示字元 **REG \_** 值，並將它設定為適當的字串。</span><span class="sxs-lookup"><span data-stu-id="a8577-167">To provide an infotip for your extension's root folder, create an InfoTip **REG\_SZ** value for the extension's CLSID key, and set it to an appropriate string.</span></span>
-   <span data-ttu-id="a8577-168">若要為您的延伸模組根資料夾指定自訂圖示，請建立名為 **DefaultIcon** 的延伸模組 CLSID 子機碼的子機碼。</span><span class="sxs-lookup"><span data-stu-id="a8577-168">To specify a custom icon for your extension's root folder, create a subkey of the extension's CLSID subkey named **DefaultIcon**.</span></span> <span data-ttu-id="a8577-169">將 **DefaultIcon** 的預設值設定為 **REG \_ SZ** 值，其中包含包含圖示之檔案的名稱，後面接著一個逗號，後面接著減號，後面接著該檔案中的圖示索引。</span><span class="sxs-lookup"><span data-stu-id="a8577-169">Set the default value of **DefaultIcon** to a **REG\_SZ** value containing the name of the file that contains the icon, followed by a comma, followed by a minus sign, followed by the index of the icon in that file.</span></span>
-   <span data-ttu-id="a8577-170">根據預設，擴充功能根資料夾的快捷方式功能表將包含在 [ **HKEY \_ 類別 \_ 根 \\ 資料夾**] 底下定義的專案。</span><span class="sxs-lookup"><span data-stu-id="a8577-170">By default, the shortcut menu of your extension's root folder will contain the items defined under **HKEY\_CLASSES\_ROOT\\Folder**.</span></span> <span data-ttu-id="a8577-171">如果您已設定適當的 SFGAO XXX 旗標，則會新增 [ **刪除**]、[ **重新命名**] 和 [ **屬性** ] 專案 \_ 。</span><span class="sxs-lookup"><span data-stu-id="a8577-171">The **Delete**, **Rename**, and **Properties** items are added if you have set the appropriate SFGAO\_XXX flags.</span></span> <span data-ttu-id="a8577-172">您可以將其他專案新增至根資料夾的快捷方式功能表，或覆寫現有的專案，就像您針對 [檔案類型](fa-file-types.md)所做的一樣。</span><span class="sxs-lookup"><span data-stu-id="a8577-172">You can add other items to the root folder's shortcut menu, or override existing items, much as you would for a [file type](fa-file-types.md).</span></span> <span data-ttu-id="a8577-173">在延伸模組的 CLSID 機碼底下建立 **Shell** 子機碼，並定義命令，如 [擴充快速鍵功能表](context.md)中所述。</span><span class="sxs-lookup"><span data-stu-id="a8577-173">Create a **Shell** subkey under the extension's CLSID key, and define commands as discussed in [Extending Shortcut Menus](context.md).</span></span>
-   <span data-ttu-id="a8577-174">如果您需要更有彈性的方式來處理根資料夾的快捷方式功能表，您可以執行 [快捷方式功能表處理常式](context-menu-handlers.md)。</span><span class="sxs-lookup"><span data-stu-id="a8577-174">If you need a more flexible way to handle the root folder's shortcut menu, you can implement a [shortcut menu handler](context-menu-handlers.md).</span></span> <span data-ttu-id="a8577-175">若要註冊快捷方式功能表處理常式，請在擴充功能的 CLSID 機碼底下建立 **ShellEx** 索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a8577-175">To register the shortcut menu handler, create a **ShellEx** key under the extension's CLSID key.</span></span> <span data-ttu-id="a8577-176">如同傳統 [建立 Shell 延伸模組處理常式](handlers.md)一樣，註冊處理常式的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="a8577-176">Register the handler's CLSID as you would for a conventional [Creating Shell Extension Handlers](handlers.md).</span></span>
-   <span data-ttu-id="a8577-177">若要將頁面加入至根資料夾的 [屬性] 屬性工作表中，請為資料夾提供 **SFGAO \_ HASPROPSHEET** 屬性，並執行 [屬性工作表處理常式](propsheet-handlers.md)。</span><span class="sxs-lookup"><span data-stu-id="a8577-177">To add a page to the root folder's Properties property sheet, give the folder the **SFGAO\_HASPROPSHEET** attribute and implement a [property sheet handler](propsheet-handlers.md).</span></span> <span data-ttu-id="a8577-178">若要註冊屬性工作表處理常式，請在擴充功能的 CLSID 機碼底下建立 **ShellEx** 索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a8577-178">To register the property sheet handler, create a **ShellEx** key under the extension's CLSID key.</span></span> <span data-ttu-id="a8577-179">如同傳統 [建立 Shell 延伸模組處理常式](handlers.md)一樣，註冊處理常式的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="a8577-179">Register the handler's CLSID as you would for a conventional [Creating Shell Extension Handlers](handlers.md).</span></span>
-   <span data-ttu-id="a8577-180">若要指定根資料夾的屬性，請將 **ShellFolder** 子機碼新增至延伸模組的 CLSID 子機碼。</span><span class="sxs-lookup"><span data-stu-id="a8577-180">To specify the attributes of the root folder, add a **ShellFolder** subkey to the extension's CLSID subkey.</span></span> <span data-ttu-id="a8577-181">建立屬性值，並將它設定為適當的 [**SFGAO \_ XXX**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof) 旗標組合。</span><span class="sxs-lookup"><span data-stu-id="a8577-181">Create an Attributes value, and set it to the appropriate combination of [**SFGAO\_XXX**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof) flags.</span></span>

<span data-ttu-id="a8577-182">下表列出根資料夾的一些常用屬性。</span><span class="sxs-lookup"><span data-stu-id="a8577-182">The following table lists some commonly used attributes for root folders.</span></span>



| <span data-ttu-id="a8577-183">旗標</span><span class="sxs-lookup"><span data-stu-id="a8577-183">Flag</span></span>                | <span data-ttu-id="a8577-184">值</span><span class="sxs-lookup"><span data-stu-id="a8577-184">Value</span></span>      | <span data-ttu-id="a8577-185">描述</span><span class="sxs-lookup"><span data-stu-id="a8577-185">Description</span></span>                                                                                                                                                                                                                                                                                                       |
|---------------------|------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="a8577-186">SFGAO \_ 資料夾</span><span class="sxs-lookup"><span data-stu-id="a8577-186">SFGAO\_FOLDER</span></span>       | <span data-ttu-id="a8577-187">0x20000000</span><span class="sxs-lookup"><span data-stu-id="a8577-187">0x20000000</span></span> | <span data-ttu-id="a8577-188">擴充功能的根資料夾包含一或多個專案。</span><span class="sxs-lookup"><span data-stu-id="a8577-188">The extension's root folder contains one or more items.</span></span>                                                                                                                                                                                                                                                           |
| <span data-ttu-id="a8577-189">SFGAO \_ HASSUBFOLDER</span><span class="sxs-lookup"><span data-stu-id="a8577-189">SFGAO\_HASSUBFOLDER</span></span> | <span data-ttu-id="a8577-190">0x80000000</span><span class="sxs-lookup"><span data-stu-id="a8577-190">0x80000000</span></span> | <span data-ttu-id="a8577-191">擴充功能的根資料夾包含一或多個子資料夾。</span><span class="sxs-lookup"><span data-stu-id="a8577-191">The extension's root folder contains one or more subfolders.</span></span> <span data-ttu-id="a8577-192">Windows 檔案總管會在資料夾圖示旁邊放置一個加號 ( + ) 。</span><span class="sxs-lookup"><span data-stu-id="a8577-192">Windows Explorer will place a plus sign ( + ) next to the folder icon.</span></span>                                                                                                                                                                               |
| <span data-ttu-id="a8577-193">SFGAO \_ CANDELETE</span><span class="sxs-lookup"><span data-stu-id="a8577-193">SFGAO\_CANDELETE</span></span>    | <span data-ttu-id="a8577-194">0x00000020</span><span class="sxs-lookup"><span data-stu-id="a8577-194">0x00000020</span></span> | <span data-ttu-id="a8577-195">使用者可以刪除擴充功能的根資料夾。</span><span class="sxs-lookup"><span data-stu-id="a8577-195">The extension's root folder can be deleted by the user.</span></span> <span data-ttu-id="a8577-196">資料夾的快捷方式功能表會有 [ **刪除** ] 專案。</span><span class="sxs-lookup"><span data-stu-id="a8577-196">The folder's shortcut menu will have a **Delete** item.</span></span> <span data-ttu-id="a8577-197">此旗標應針對放置於其中一個 [虛擬資料夾](nse-junction.md)下的連接點進行設定。</span><span class="sxs-lookup"><span data-stu-id="a8577-197">This flag should be set for junction points that are placed under one of the [virtual folders](nse-junction.md).</span></span>                                                                                 |
| <span data-ttu-id="a8577-198">SFGAO \_ CANRENAME</span><span class="sxs-lookup"><span data-stu-id="a8577-198">SFGAO\_CANRENAME</span></span>    | <span data-ttu-id="a8577-199">0x00000010</span><span class="sxs-lookup"><span data-stu-id="a8577-199">0x00000010</span></span> | <span data-ttu-id="a8577-200">使用者可以重新命名延伸的根資料夾。</span><span class="sxs-lookup"><span data-stu-id="a8577-200">The extension's root folder can be renamed by the user.</span></span> <span data-ttu-id="a8577-201">資料夾的快捷方式功能表會有 [ **重新命名** ] 專案。</span><span class="sxs-lookup"><span data-stu-id="a8577-201">The folder's shortcut menu will have a **Rename** item.</span></span>                                                                                                                                                                                                   |
| <span data-ttu-id="a8577-202">SFGAO \_ HASPROPSHEET</span><span class="sxs-lookup"><span data-stu-id="a8577-202">SFGAO\_HASPROPSHEET</span></span> | <span data-ttu-id="a8577-203">0x00000040</span><span class="sxs-lookup"><span data-stu-id="a8577-203">0x00000040</span></span> | <span data-ttu-id="a8577-204">擴充功能的根資料夾具有 [ **屬性** ] 屬性工作表。</span><span class="sxs-lookup"><span data-stu-id="a8577-204">The extension's root folder has a **Properties** property sheet.</span></span> <span data-ttu-id="a8577-205">資料夾的快捷方式功能表將會有 **屬性** 專案。</span><span class="sxs-lookup"><span data-stu-id="a8577-205">The folder's shortcut menu will have a **Properties** item.</span></span> <span data-ttu-id="a8577-206">若要提供屬性工作表，您必須執行 [屬性工作表處理常式](propsheet-handlers.md)。</span><span class="sxs-lookup"><span data-stu-id="a8577-206">To provide the property sheet, you must implement a [property sheet handler](propsheet-handlers.md).</span></span> <span data-ttu-id="a8577-207">如先前所述，在擴充功能的 CLSID 機碼下註冊處理常式。</span><span class="sxs-lookup"><span data-stu-id="a8577-207">Register the handler under the extension's CLSID key, as discussed previously.</span></span> |



 

<span data-ttu-id="a8577-208">下列範例會顯示名稱為 MyExtension 之延伸模組的 CLSID 登錄專案。</span><span class="sxs-lookup"><span data-stu-id="a8577-208">The following example shows the CLSID registry entry for an extension with a display name of MyExtension.</span></span> <span data-ttu-id="a8577-209">擴充功能有一個自訂圖示，其包含在具有索引1的延伸模組 DLL 中。</span><span class="sxs-lookup"><span data-stu-id="a8577-209">The extension has a custom icon that is contained in the extension's DLL with an index of 1.</span></span> <span data-ttu-id="a8577-210">已設定 **SFGAO \_ 資料夾**、 **SFGAO \_ HASSUBFOLDER** 和 **SFGAO \_ CANDELETE** 屬性。</span><span class="sxs-lookup"><span data-stu-id="a8577-210">The **SFGAO\_FOLDER**, **SFGAO\_HASSUBFOLDER**, and **SFGAO\_CANDELETE** attributes are set.</span></span>

```
HKEY_CLASSES_ROOT
   CLSID
      {Extension CLSID}
         (Default) = MyExtension
         InfoTip = Some appropriate text
      DefaultIcon
         (Default) = c:\MyDir\MyExtension.dll,-1
      InProcServer32
         (Default) = c:\MyDir\MyExtension.dll
         ThreadingModel = Apartment
      ShellFolder
         Attributes = 0xA00000020
```

## <a name="handling-pidls"></a><span data-ttu-id="a8577-211">處理 Pidl</span><span class="sxs-lookup"><span data-stu-id="a8577-211">Handling PIDLs</span></span>

<span data-ttu-id="a8577-212">Shell 命名空間中的每個專案都必須有唯一的 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-212">Every item in the Shell namespace must have a unique PIDL.</span></span> <span data-ttu-id="a8577-213">Windows 檔案總管將 PIDL 指派給根資料夾，並在初始化期間將值傳遞至您的延伸模組。</span><span class="sxs-lookup"><span data-stu-id="a8577-213">Windows Explorer assigns a PIDL to your root folder and passes the value to your extension during initialization.</span></span> <span data-ttu-id="a8577-214">然後，您的擴充功能會負責將正確建立的 PIDL 指派給它的每一個物件，並提供這些 Pidl 來 Windows 檔案總管要求。</span><span class="sxs-lookup"><span data-stu-id="a8577-214">Your extension is then responsible for assigning a properly constructed PIDL to each of its objects and providing those PIDLs to Windows Explorer on request.</span></span> <span data-ttu-id="a8577-215">當 Shell 使用 PIDL 來識別您的其中一個延伸模組物件時，您的延伸模組必須能夠解讀 PIDL 並識別特定的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-215">When the Shell uses a PIDL to identify one of your extension's objects, your extension must be able to interpret the PIDL and identify the particular object.</span></span> <span data-ttu-id="a8577-216">您的延伸模組也必須將 [**顯示名稱**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-setnameof) 和 *剖析名稱* 指派給每個物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-216">Your extension must also assign a [**display name**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-setnameof) and a *parsing name* to each object.</span></span> <span data-ttu-id="a8577-217">由於 Pidl 是由幾乎每個資料夾介面使用，因此擴充功能通常會執行單一 *PIDL 管理員* 來處理所有這些工作。</span><span class="sxs-lookup"><span data-stu-id="a8577-217">Because PIDLs are used by virtually every folder interface, extensions commonly implement a single *PIDL manager* to handle all these tasks.</span></span>

<span data-ttu-id="a8577-218">PIDL 一詞是 [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) 結構的縮寫，或是這類結構的指標（視內容而定）。</span><span class="sxs-lookup"><span data-stu-id="a8577-218">The term PIDL is short for an [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) structure or a pointer to such a structure, depending on context.</span></span> <span data-ttu-id="a8577-219">如同宣告， **ITEMIDLIST** 結構具有單一成員（ [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構）。</span><span class="sxs-lookup"><span data-stu-id="a8577-219">As declared, an **ITEMIDLIST** structure has a single member, an [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure.</span></span> <span data-ttu-id="a8577-220">物件的 **ITEMIDLIST** 結構實際上是兩個或多個 **SHITEMID** 結構的封裝陣列。</span><span class="sxs-lookup"><span data-stu-id="a8577-220">An object's **ITEMIDLIST** structure is actually a packed array of two or more **SHITEMID** structures.</span></span> <span data-ttu-id="a8577-221">這些結構的順序會定義透過命名空間的路徑，與 c： \\ MyDirectory \\ myfile.txt 定義整個檔案系統路徑的方式大致相同。</span><span class="sxs-lookup"><span data-stu-id="a8577-221">The order of these structures defines a path through the namespace, in much the same way that c:\\MyDirectory\\MyFile defines a path through the file system.</span></span> <span data-ttu-id="a8577-222">一般而言，物件的 PIDL 會包含一系列的 **SHITEMID** 結構，這些結構會對應到定義命名空間路徑的資料夾，後面接著物件的 **SHITEMID** 結構，後面接著結束字元。</span><span class="sxs-lookup"><span data-stu-id="a8577-222">Typically, an object's PIDL will consist of a series of **SHITEMID** structures that correspond to the folders that define the namespace path, followed by the object's **SHITEMID** structure, followed by a terminator.</span></span>

<span data-ttu-id="a8577-223">結束字元是 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構，其 *cb* 成員設為 **Null**。</span><span class="sxs-lookup"><span data-stu-id="a8577-223">The terminator is an [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure, with the *cb* member set to **NULL**.</span></span> <span data-ttu-id="a8577-224">結束字元是必要的，因為物件 PIDL 中的 **SHITEMID** 結構數目取決於 Shell 命名空間中物件的位置，以及路徑的起點。</span><span class="sxs-lookup"><span data-stu-id="a8577-224">The terminator is necessary because the number of **SHITEMID** structures in an object's PIDL depends on the location of the object in the Shell namespace, and the starting point of the path.</span></span> <span data-ttu-id="a8577-225">此外，各種 **SHITEMID** 結構的大小可能會有所不同。</span><span class="sxs-lookup"><span data-stu-id="a8577-225">In addition, the size of the various **SHITEMID** structures can vary.</span></span> <span data-ttu-id="a8577-226">當您收到 PIDL 時，您沒有簡單的方法可以判斷其大小，甚至是 **SHITEMID** 結構的總數。</span><span class="sxs-lookup"><span data-stu-id="a8577-226">When you receive a PIDL, you have no simple way of determining its size or even the total number of **SHITEMID** structures.</span></span> <span data-ttu-id="a8577-227">相反地，您必須在到達結束字元之前，以結構的結構來「逐步」封裝的陣列。</span><span class="sxs-lookup"><span data-stu-id="a8577-227">Instead, you must "walk" the packed array, structure by structure, until you reach the terminator.</span></span>

<span data-ttu-id="a8577-228">若要建立 PIDL，您的應用程式必須：</span><span class="sxs-lookup"><span data-stu-id="a8577-228">To create a PIDL, your application needs to:</span></span>

1.  <span data-ttu-id="a8577-229">為每個物件建立 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構。</span><span class="sxs-lookup"><span data-stu-id="a8577-229">Create an [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure for each of its objects.</span></span>
2.  <span data-ttu-id="a8577-230">將相關的 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構組合成 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-230">Assemble the relevant [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structures into a PIDL.</span></span>

### <a name="creating-an-shitemid-structure"></a><span data-ttu-id="a8577-231">建立 SHITEMID 結構</span><span class="sxs-lookup"><span data-stu-id="a8577-231">Creating an SHITEMID Structure</span></span>

<span data-ttu-id="a8577-232">物件的 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構可唯一地識別其資料夾內的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-232">An object's [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure uniquely identifies the object within its folder.</span></span> <span data-ttu-id="a8577-233">事實上，許多 [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) 方法所使用的 PIDL 類型只包含物件的 **SHITEMID** 結構，後面接著結束字元。</span><span class="sxs-lookup"><span data-stu-id="a8577-233">In fact, a type of PIDL used by many of the [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) methods consists of just the object's **SHITEMID** structure, followed by a terminator.</span></span> <span data-ttu-id="a8577-234">**SHITEMID** 結構的定義如下：</span><span class="sxs-lookup"><span data-stu-id="a8577-234">The definition of an **SHITEMID** structure is:</span></span>


```C++
typedef struct _SHITEMID { 
    USHORT cb; 
    BYTE   abID[1]; 
} SHITEMID, * LPSHITEMID;
```



<span data-ttu-id="a8577-235">*AbID* 成員是物件的識別碼。</span><span class="sxs-lookup"><span data-stu-id="a8577-235">The *abID* member is the object's identifier.</span></span> <span data-ttu-id="a8577-236">因為 *abID* 的長度並未定義且可能不同，所以 *cb* 成員會設定為 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構的大小（以位元組為單位）。</span><span class="sxs-lookup"><span data-stu-id="a8577-236">Because the length of *abID* is not defined and can vary, the *cb* member is set to the size of the [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure, in bytes.</span></span>

<span data-ttu-id="a8577-237">因為 *abID* 的長度和內容都不是標準化的，所以您可以使用任何您想要指派 *abID* 值給物件的配置。</span><span class="sxs-lookup"><span data-stu-id="a8577-237">Because neither the length nor the content of *abID* is standardized, you can use any scheme you want to assign *abID* values to your objects.</span></span> <span data-ttu-id="a8577-238">唯一的需求是，您不能在相同的資料夾中有兩個具有相同值的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-238">The only requirement is that you cannot have two objects in the same folder with identical values.</span></span> <span data-ttu-id="a8577-239">不過，基於效能考慮，您的 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構應為 **DWORD** 對齊。</span><span class="sxs-lookup"><span data-stu-id="a8577-239">However, for performance reasons, your [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure should be **DWORD**-aligned.</span></span> <span data-ttu-id="a8577-240">換句話說，您應該建立 *abID* 值，讓 *cb* 成為4的整數倍數。</span><span class="sxs-lookup"><span data-stu-id="a8577-240">In other words, you should construct your *abID* values such that *cb* is an integral multiple of 4.</span></span>

<span data-ttu-id="a8577-241">一般而言， *abID* 會指向擴充功能定義的結構。</span><span class="sxs-lookup"><span data-stu-id="a8577-241">Typically, *abID* points to an extension-defined structure.</span></span> <span data-ttu-id="a8577-242">除了物件的識別碼之外，這個結構通常用來保存各種相關資訊，例如物件的型別或屬性。</span><span class="sxs-lookup"><span data-stu-id="a8577-242">In addition to the object's ID, this structure is often used to hold a variety of related information, such as the object's type or attributes.</span></span> <span data-ttu-id="a8577-243">然後，您的擴充功能資料夾物件可以從 PIDL 快速解壓縮資訊，而不需要查詢它。</span><span class="sxs-lookup"><span data-stu-id="a8577-243">Your extension's folder objects can then quickly extract the information from the PIDL instead of having to query for it.</span></span>

> [!Note]  
> <span data-ttu-id="a8577-244">設計 PIDL 資料結構的其中一個最重要層面，就是讓結構能夠持久且可轉移。</span><span class="sxs-lookup"><span data-stu-id="a8577-244">One of the most important aspects of designing a data structure for a PIDL is to make the structure persistable and transportable.</span></span> <span data-ttu-id="a8577-245">在 Pidl 的內容中，這些詞彙的意義如下：</span><span class="sxs-lookup"><span data-stu-id="a8577-245">In the context of PIDLs, the meaning of these terms is:</span></span>
>
> -   <span data-ttu-id="a8577-246">持久.</span><span class="sxs-lookup"><span data-stu-id="a8577-246">Persistable.</span></span> <span data-ttu-id="a8577-247">系統經常會將 Pidl 放在各種類型的長期儲存體中，例如快速鍵檔。</span><span class="sxs-lookup"><span data-stu-id="a8577-247">The system frequently places PIDLs in various types of long-term storage, such as shortcut files.</span></span> <span data-ttu-id="a8577-248">然後，它可以在系統重新開機之後，稍後再從儲存體復原這些 Pidl。</span><span class="sxs-lookup"><span data-stu-id="a8577-248">It can then recover these PIDLs from storage later, possibly after the system has been rebooted.</span></span> <span data-ttu-id="a8577-249">從儲存體復原的 PIDL 仍然必須有效且對您的延伸模組有意義。</span><span class="sxs-lookup"><span data-stu-id="a8577-249">A PIDL that has been recovered from storage must still be valid and meaningful to your extension.</span></span> <span data-ttu-id="a8577-250">這項需求表示，您不應該在 PIDL 結構中使用指標或控制碼。</span><span class="sxs-lookup"><span data-stu-id="a8577-250">This requirement means, for instance, that you should not use pointers or handles in your PIDL structure.</span></span> <span data-ttu-id="a8577-251">當系統稍後從儲存體復原時，包含這種資料類型的 Pidl 通常會沒有意義。</span><span class="sxs-lookup"><span data-stu-id="a8577-251">PIDLs containing this type of data will normally be meaningless when the system later recovers them from storage.</span></span>
> -   <span data-ttu-id="a8577-252">運輸。</span><span class="sxs-lookup"><span data-stu-id="a8577-252">Transportable.</span></span> <span data-ttu-id="a8577-253">從一部電腦傳輸到另一部電腦時，PIDL 必須保持有意義。</span><span class="sxs-lookup"><span data-stu-id="a8577-253">A PIDL must remain meaningful when transported from one computer to another.</span></span> <span data-ttu-id="a8577-254">例如，PIDL 可以寫入至快捷方式檔案，複製到磁片磁碟機，然後傳輸到另一部電腦。</span><span class="sxs-lookup"><span data-stu-id="a8577-254">For example, a PIDL can be written to a shortcut file, copied to a floppy disk, and transported to another computer.</span></span> <span data-ttu-id="a8577-255">該 PIDL 對您在第二部電腦上執行的延伸模組仍然有意義。</span><span class="sxs-lookup"><span data-stu-id="a8577-255">That PIDL should still be meaningful to your extension running on the second computer.</span></span> <span data-ttu-id="a8577-256">例如，若要確保您的 Pidl 可轉移，請明確使用 ANSI 或 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="a8577-256">For instance, to ensure that your PIDLs are transportable, use either ANSI or Unicode characters explicitly.</span></span> <span data-ttu-id="a8577-257">避免資料類型，例如 **TCHAR** 或 **LPTSTR**。</span><span class="sxs-lookup"><span data-stu-id="a8577-257">Avoid data types such as **TCHAR** or **LPTSTR**.</span></span> <span data-ttu-id="a8577-258">如果您使用這些資料類型，在不同電腦上執行之延伸模組的 ANSI 版本將無法讀取在執行副檔名 Unicode 的電腦上所建立的 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-258">If you use those data types, a PIDL created on a computer running a Unicode version of your extension will not be readable by an ANSI version of that extension running on a different computer.</span></span>

 

<span data-ttu-id="a8577-259">下列宣告顯示資料結構的簡單範例。</span><span class="sxs-lookup"><span data-stu-id="a8577-259">The following declaration shows a simple example of a data structure.</span></span>


```C++
typedef struct tagMYPIDLDATA {
  USHORT cb;
  DWORD dwType;
  WCHAR wszDisplayName[40];
} MYPIDLDATA, *LPMYPIDLDATA;
```



<span data-ttu-id="a8577-260">**Cb** 成員會設定為 **MYPIDLDATA** 結構的大小。</span><span class="sxs-lookup"><span data-stu-id="a8577-260">The **cb** member is set to the size of the **MYPIDLDATA** structure.</span></span> <span data-ttu-id="a8577-261">這個成員會使 **MYPIDLDATA** 成為有效的 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構，也就是本身的。</span><span class="sxs-lookup"><span data-stu-id="a8577-261">This member makes **MYPIDLDATA** a valid [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure, in and of itself.</span></span> <span data-ttu-id="a8577-262">其餘成員等同于 **SHITEMID** 結構的 **abID** 成員並保存私用資料。</span><span class="sxs-lookup"><span data-stu-id="a8577-262">The rest of the members are equivalent to the **abID** member of an **SHITEMID** structure and hold private data.</span></span> <span data-ttu-id="a8577-263">**DwType** 成員是延伸模組定義的值，表示物件的型別。</span><span class="sxs-lookup"><span data-stu-id="a8577-263">The **dwType** member is an extension-defined value that indicates the type of object.</span></span> <span data-ttu-id="a8577-264">在此範例中，資料夾的 **dwType** 設為 **TRUE** ，否則為 **FALSE** 。</span><span class="sxs-lookup"><span data-stu-id="a8577-264">For this example, **dwType** is set to **TRUE** for folders and **FALSE** otherwise.</span></span> <span data-ttu-id="a8577-265">例如，這個成員可讓您快速判斷物件是否為資料夾。</span><span class="sxs-lookup"><span data-stu-id="a8577-265">This member allows you, for instance, to quickly determine whether the object is a folder or not.</span></span> <span data-ttu-id="a8577-266">**WszDisplayName** 成員包含物件的顯示名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-266">The **wszDisplayName** member contains the object's display name.</span></span> <span data-ttu-id="a8577-267">由於您不會將相同的顯示名稱指派給相同資料夾中的兩個不同物件，因此顯示名稱也會當做物件識別碼。</span><span class="sxs-lookup"><span data-stu-id="a8577-267">Since you would not assign the same display name to two different objects in the same folder, the display name also serves as the object ID.</span></span> <span data-ttu-id="a8577-268">在此範例中， **wszDisplayName** 會設定為40個字元，以保證 **SHITEMID** 結構會對齊 **DWORD**。</span><span class="sxs-lookup"><span data-stu-id="a8577-268">In this example, **wszDisplayName** is set to 40 characters to guarantee that the **SHITEMID** structure will be **DWORD**-aligned.</span></span> <span data-ttu-id="a8577-269">若要限制 Pidl 的大小，您可以改為使用可變長度的字元陣列，並據以調整 cb 的值。</span><span class="sxs-lookup"><span data-stu-id="a8577-269">To limit the size of your PIDLs, you can instead use a variable-length character array and adjust the value of cb accordingly.</span></span> <span data-ttu-id="a8577-270">以足夠的 ' \\ 0 ' 字元填補顯示字串，以維護結構的 **DWORD** 對齊。</span><span class="sxs-lookup"><span data-stu-id="a8577-270">Pad the display string with enough '\\0' characters to maintain the structure's **DWORD** alignment.</span></span> <span data-ttu-id="a8577-271">其他可能有助於放置結構的成員包括物件的大小、屬性或剖析名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-271">Other members that might be useful to put in the structure include the object's size, attributes, or parsing name.</span></span>

### <a name="constructing-a-pidl"></a><span data-ttu-id="a8577-272">建立 PIDL</span><span class="sxs-lookup"><span data-stu-id="a8577-272">Constructing a PIDL</span></span>

<span data-ttu-id="a8577-273">一旦為物件定義了 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構之後，您就可以使用它們來建立 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-273">Once you have defined [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structures for your objects, you can then use them to construct a PIDL.</span></span> <span data-ttu-id="a8577-274">Pidl 可基於各種用途來建立，但大部分的工作會使用兩種 PIDL 類型的其中一種。</span><span class="sxs-lookup"><span data-stu-id="a8577-274">PIDLs can be constructed for a variety of purposes, but most tasks use one of two types of PIDL.</span></span> <span data-ttu-id="a8577-275">最簡單的單一層級 PIDL 會識別相對於其父資料夾的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-275">The simplest, a single-level PIDL, identifies the object relative to its parent folder.</span></span> <span data-ttu-id="a8577-276">許多 [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) 方法會使用這種類型的 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-276">This type of PIDL is used by many of the [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) methods.</span></span> <span data-ttu-id="a8577-277">單一層級的 PIDL 包含物件的 **SHITEMID** 結構，後面接著結束字元。</span><span class="sxs-lookup"><span data-stu-id="a8577-277">A single-level PIDL contains the object's **SHITEMID** structure, followed by a terminator.</span></span> <span data-ttu-id="a8577-278">完整的 PIDL 會定義從桌面到物件的命名空間階層路徑。</span><span class="sxs-lookup"><span data-stu-id="a8577-278">A fully qualified PIDL defines a path through the namespace hierarchy from the desktop to the object.</span></span> <span data-ttu-id="a8577-279">這種類型的 PIDL 會從桌面開始，並且針對路徑中的每個資料夾包含一個 **SHITEMID** 結構，後面接著物件和結束字元。</span><span class="sxs-lookup"><span data-stu-id="a8577-279">This type of PIDL starts at the desktop and contains one **SHITEMID** structure for each folder in the path, followed by the object and the terminator.</span></span> <span data-ttu-id="a8577-280">完整的 PIDL 可唯一識別整個 Shell 命名空間內的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-280">A fully qualified PIDL uniquely identifies the object within the entire Shell namespace.</span></span>

<span data-ttu-id="a8577-281">若要建立 PIDL，最簡單的方法就是直接使用 [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) 結構本身。</span><span class="sxs-lookup"><span data-stu-id="a8577-281">The simplest way to construct a PIDL is to work directly with the [**ITEMIDLIST**](/windows/desktop/api/Shtypes/ns-shtypes-itemidlist) structure itself.</span></span> <span data-ttu-id="a8577-282">建立 **ITEMIDLIST** 結構，但配置足夠的記憶體來保存所有 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構。</span><span class="sxs-lookup"><span data-stu-id="a8577-282">Create an **ITEMIDLIST** structure, but allocate enough memory to hold all the [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structures.</span></span> <span data-ttu-id="a8577-283">此結構的位址會指向初始 **SHITEMID** 結構。</span><span class="sxs-lookup"><span data-stu-id="a8577-283">The address of this structure will point to the initial **SHITEMID** structure.</span></span> <span data-ttu-id="a8577-284">為此初始結構的成員定義值，然後以適當的順序附加所需數量的額外 **SHITEMID** 結構。</span><span class="sxs-lookup"><span data-stu-id="a8577-284">Define values for the members of this initial structure, and then append as many additional **SHITEMID** structures as you need, in the appropriate order.</span></span> <span data-ttu-id="a8577-285">下列程式概述如何建立單一層級的 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-285">The following procedure outlines how to create a single-level PIDL.</span></span> <span data-ttu-id="a8577-286">它包含兩個 **SHITEMID** 結構- **MYPIDLDATA** 結構後面接著結束字元：</span><span class="sxs-lookup"><span data-stu-id="a8577-286">It contains two **SHITEMID** structures—a **MYPIDLDATA** structure followed by a terminator:</span></span>

1.  <span data-ttu-id="a8577-287">您可以使用 [**CoTaskMemAlloc**](/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemalloc) 函數來配置 PIDL 的記憶體。</span><span class="sxs-lookup"><span data-stu-id="a8577-287">Use the [**CoTaskMemAlloc**](/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemalloc) function to allocate memory for the PIDL.</span></span> <span data-ttu-id="a8577-288">為您的私用資料配置足夠的記憶體，再加上 **USHORT** (兩個位元組) 作為結束字元。</span><span class="sxs-lookup"><span data-stu-id="a8577-288">Allocate enough memory for your private data plus a **USHORT** (two bytes) for the terminator.</span></span> <span data-ttu-id="a8577-289">將結果轉換為 LPMYPIDLDATA。</span><span class="sxs-lookup"><span data-stu-id="a8577-289">Cast the result to LPMYPIDLDATA.</span></span>
2.  <span data-ttu-id="a8577-290">將第一個 **MYPIDLDATA** 結構的 cb 成員設定為該結構的大小。</span><span class="sxs-lookup"><span data-stu-id="a8577-290">Set the cb member of the first **MYPIDLDATA** structure to the size of that structure.</span></span> <span data-ttu-id="a8577-291">在此範例中，您會將 **cb** 設定為 SIZEOF (MYPIDLDATA) 。</span><span class="sxs-lookup"><span data-stu-id="a8577-291">For this example, you would set **cb** to sizeof(MYPIDLDATA).</span></span> <span data-ttu-id="a8577-292">如果您想要使用可變長度的結構，就必須計算 **cb** 的值。</span><span class="sxs-lookup"><span data-stu-id="a8577-292">If you want to use a variable-length structure, you will have to calculate the value of **cb**.</span></span>
3.  <span data-ttu-id="a8577-293">將適當的值指派給私用資料成員。</span><span class="sxs-lookup"><span data-stu-id="a8577-293">Assign appropriate values to the private data members.</span></span>
4.  <span data-ttu-id="a8577-294">計算下一個 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構的位址。</span><span class="sxs-lookup"><span data-stu-id="a8577-294">Calculate the address of the next [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure.</span></span> <span data-ttu-id="a8577-295">將目前 MYPIDLDATA 結構的位址轉換為 LPBYTE，並將該值新增至在步驟3中判斷的 **cb** 值。</span><span class="sxs-lookup"><span data-stu-id="a8577-295">Cast the address of the current MYPIDLDATA structure to LPBYTE, and add that value to the value of **cb** determined in step 3.</span></span>
5.  <span data-ttu-id="a8577-296">在此案例中，下一個 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構是結束字元。</span><span class="sxs-lookup"><span data-stu-id="a8577-296">In this case, the next [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure is the terminator.</span></span> <span data-ttu-id="a8577-297">將結構的 **cb** 成員設定為零。</span><span class="sxs-lookup"><span data-stu-id="a8577-297">Set the structure's **cb** member to zero.</span></span>

<span data-ttu-id="a8577-298">針對較長的 Pidl，請配置足夠的記憶體，然後針對每個額外的 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構重複步驟3-5。</span><span class="sxs-lookup"><span data-stu-id="a8577-298">For longer PIDLs, allocate sufficient memory and repeat steps 3-5 for each additional [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure.</span></span>

<span data-ttu-id="a8577-299">下列範例函式會採用物件的類型和顯示名稱，並傳回物件的單一層級 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-299">The following sample function takes an object's type and display name and returns the object's single-level PIDL.</span></span> <span data-ttu-id="a8577-300">函數假設顯示名稱（包括其結束的 **null** 字元）不超過針對 **MYPIDLDATA** 結構宣告的字元數。</span><span class="sxs-lookup"><span data-stu-id="a8577-300">The function assumes that the display name, including its terminating **null** character, does not exceed the number of characters declared for the **MYPIDLDATA** structure.</span></span> <span data-ttu-id="a8577-301">如果該假設結果是錯誤的， [**StringCbCopyW**](/windows/win32/api/strsafe/nf-strsafe-stringcbcopya) 函式將會截斷顯示名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-301">If that assumption turns out to be erroneous, the [**StringCbCopyW**](/windows/win32/api/strsafe/nf-strsafe-stringcbcopya) function will truncate the display name.</span></span> <span data-ttu-id="a8577-302">**G \_ pMalloc** 變數是在其他地方建立並儲存在全域變數中的 [**IMalloc**](/windows/win32/api/objidlbase/nn-objidlbase-imalloc)指標。</span><span class="sxs-lookup"><span data-stu-id="a8577-302">The **g\_pMalloc** variable is an [**IMalloc**](/windows/win32/api/objidlbase/nn-objidlbase-imalloc) pointer created elsewhere and stored in a global variable.</span></span>


```C++
LPITEMIDLIST CreatePIDL(DWORD dwType, LPCWSTR pwszDisplayName)
{
    LPMYPIDLDATA   pidlOut;
    USHORT         uSize;

    pidlOut = NULL;

    //Calculate the size of the MYPIDLDATA structure.
    uSize = sizeof(MYPIDLDATA);

    // Allocate enough memory for the PIDL to hold a MYPIDLDATA structure 
    // plus the terminator
    pidlOut = (LPMYPIDLDATA)m_pMalloc->Alloc(uSize + sizeof(USHORT));

    if(pidlOut)
    {
       //Assign values to the members of the MYPIDLDATA structure
       //that is the PIDL's first SHITEMID structure
       pidlOut->cb = uSize;
       pidlOut->dwType = dwType;
       hr = StringCbCopyW(pidlOut->wszDisplayName, 
                          sizeof(pidlOut->wszDisplayName), pwszDisplayName);
       
       // TODO: Add error handling here to verify the HRESULT returned 
       // by StringCbCopyW.

       //Advance the pointer to the start of the next SHITEMID structure.
       pidlOut = (LPMYPIDLDATA)((LPBYTE)pidlOut + pidlOut->cb);

       //Create the terminating null character by setting cb to 0.
       pidlOut->cb = 0;
    }

    return pidlOut;
```



<span data-ttu-id="a8577-303">完整的 PIDL 必須將每個物件的 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構，從桌面連接到您的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-303">A fully qualified PIDL must have [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structures for every object from the desktop to your object.</span></span> <span data-ttu-id="a8577-304">當 Shell 呼叫 [**IPersistFolder：： Initialize**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipersistfolder-initialize)時，您的擴充功能會收到根資料夾的完整 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-304">Your extension receives a fully qualified PIDL for your root folder when the Shell calls [**IPersistFolder::Initialize**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipersistfolder-initialize).</span></span> <span data-ttu-id="a8577-305">若要建立物件的完整 PIDL，請取得 Shell 已指派給根資料夾的 PIDL，然後將您從根資料夾中取得的 **SHITEMID** 結構附加至物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-305">To construct a fully qualified PIDL for an object, take the PIDL that the Shell has assigned to your root folder, and append the **SHITEMID** structures that are needed to take you from the root folder to the object.</span></span>

### <a name="interpreting-pidls"></a><span data-ttu-id="a8577-306">解讀 Pidl</span><span class="sxs-lookup"><span data-stu-id="a8577-306">Interpreting PIDLs</span></span>

<span data-ttu-id="a8577-307">當 Shell 或應用程式呼叫其中一個擴充功能介面來要求物件的相關資訊時，通常會透過 PIDL 來識別物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-307">When the Shell or an application calls one of your extension's interfaces to request information about an object, it will usually identify the object by a PIDL.</span></span> <span data-ttu-id="a8577-308">某些方法（例如 [**IShellFolder：： GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof)）會使用相對於父資料夾的 pidl，而且很容易解讀。</span><span class="sxs-lookup"><span data-stu-id="a8577-308">Some methods, such as [**IShellFolder::GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof), use PIDLs that are relative to the parent folder and are straightforward to interpret.</span></span> <span data-ttu-id="a8577-309">不過，您的延伸模組可能也會收到完整的 Pidl。</span><span class="sxs-lookup"><span data-stu-id="a8577-309">However, your extension will probably also receive fully qualified PIDLs.</span></span> <span data-ttu-id="a8577-310">然後，您的 PIDL manager 必須判斷 PIDL 參考的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-310">Your PIDL manager must then determine which of your objects that PIDL is referring to.</span></span>

<span data-ttu-id="a8577-311">將物件與完整 PIDL 相關聯的工作會變得更複雜，那就是 PIDL 中的一或多個初始 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構可能屬於在 Shell 命名空間的延伸範圍之外的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-311">What complicates the task of associating an object with a fully qualified PIDL is that one or more of the initial [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structures in the PIDL might belong to objects that lie outside your extension in the Shell namespace.</span></span> <span data-ttu-id="a8577-312">您沒有辦法解讀這些結構的 *abID* 成員意義。</span><span class="sxs-lookup"><span data-stu-id="a8577-312">You have no way of interpreting the meaning of the *abID* member of those structures.</span></span> <span data-ttu-id="a8577-313">您的延伸模組必須做的就是「逐步」 **SHITEMID** 結構清單，直到您到達對應到根資料夾的結構為止。</span><span class="sxs-lookup"><span data-stu-id="a8577-313">What your extension must do is to "walk" the list of **SHITEMID** structures, until you reach the structure that corresponds to your root folder.</span></span> <span data-ttu-id="a8577-314">接著，您將瞭解如何解讀 **SHITEMID** 結構中的資訊。</span><span class="sxs-lookup"><span data-stu-id="a8577-314">From then on, you will know how to interpret the information in the **SHITEMID** structures.</span></span>

<span data-ttu-id="a8577-315">若要進行 PIDL，請採用第一個 *cb* 值，並將它新增至 PIDL 的位址，以將指標前進至下一個 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構的開頭。</span><span class="sxs-lookup"><span data-stu-id="a8577-315">To walk the PIDL, take the first *cb* value and add it to the address of the PIDL to advance the pointer to the start of the next [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure.</span></span> <span data-ttu-id="a8577-316">然後，它會指向該結構的 *cb* 成員，您可以使用此成員將指標前進到下一個 **SHITEMID** 結構的開頭，依此類推。</span><span class="sxs-lookup"><span data-stu-id="a8577-316">It then will be pointing to that structure's *cb* member, which you can use to advance the pointer to the start of the next **SHITEMID** structure, and so on.</span></span> <span data-ttu-id="a8577-317">每次您前進指標時，請檢查 **SHITEMID** 結構，以判斷您是否已到達延伸模組命名空間的根目錄。</span><span class="sxs-lookup"><span data-stu-id="a8577-317">Each time you advance the pointer, examine the **SHITEMID** structure to determine whether you have reached the root of your extension's namespace.</span></span>

## <a name="implementing-the-primary-interfaces"></a><span data-ttu-id="a8577-318">執行主要介面</span><span class="sxs-lookup"><span data-stu-id="a8577-318">Implementing the Primary Interfaces</span></span>

<span data-ttu-id="a8577-319">如同所有 COM 物件，執行擴充功能的方式大多是執行介面集合。</span><span class="sxs-lookup"><span data-stu-id="a8577-319">As with all COM objects, implementing an extension is largely a matter of implementing a collection of interfaces.</span></span> <span data-ttu-id="a8577-320">本節討論所有延伸模組都必須執行的三個主要介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-320">This section discusses the three primary interfaces that must be implemented by all extensions.</span></span> <span data-ttu-id="a8577-321">它們是用來初始化和提供 Windows 檔案總管，其中包含有關延伸模組內容的基本資訊。</span><span class="sxs-lookup"><span data-stu-id="a8577-321">They are used for initialization and to provide Windows Explorer with basic information about the contents of the extension.</span></span> <span data-ttu-id="a8577-322">這些介面和 [資料夾檢視](../lwef/nse-folderview.md)都是功能延伸模組所需的所有介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-322">These interfaces, plus a [folder view](../lwef/nse-folderview.md), are all that is required for a functional extension.</span></span> <span data-ttu-id="a8577-323">不過，若要充分利用 Windows 檔案總管的功能，大部分的延伸模組也會執行一或多個選用的介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-323">However, to fully exploit the features of Windows Explorer, most extensions also implement one or more of the optional interfaces.</span></span>

### <a name="ipersistfolder-interface"></a><span data-ttu-id="a8577-324">IPersistFolder 介面</span><span class="sxs-lookup"><span data-stu-id="a8577-324">IPersistFolder Interface</span></span>

<span data-ttu-id="a8577-325">呼叫 [**IPersistFolder**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder) 介面來初始化新的資料夾物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-325">The [**IPersistFolder**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder) interface is called to initialize a new folder object.</span></span> <span data-ttu-id="a8577-326">[**IPersistFolder：： Initialize**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipersistfolder-initialize)方法會將完整的 PIDL 指派給新的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-326">The [**IPersistFolder::Initialize**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipersistfolder-initialize) method assigns a fully qualified PIDL to the new object.</span></span> <span data-ttu-id="a8577-327">儲存此 PIDL 以供稍後使用。</span><span class="sxs-lookup"><span data-stu-id="a8577-327">Store this PIDL for later use.</span></span> <span data-ttu-id="a8577-328">例如，資料夾物件必須使用這個 PIDL 來為物件的子系建立完整的 Pidl。</span><span class="sxs-lookup"><span data-stu-id="a8577-328">For instance, a folder object must use this PIDL to construct fully qualified PIDLs for the object's children.</span></span> <span data-ttu-id="a8577-329">資料夾物件的建立者也可以呼叫 [**IPersist：： GetClassID**](/windows/win32/api/objidl/nf-objidl-ipersist-getclassid) 來要求物件的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="a8577-329">The folder object's creator can also call [**IPersist::GetClassID**](/windows/win32/api/objidl/nf-objidl-ipersist-getclassid) to request the object's CLSID.</span></span>

<span data-ttu-id="a8577-330">一般而言，資料夾物件是由其父資料夾的 [**IShellFolder：： BindToObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject) 方法建立和初始化。</span><span class="sxs-lookup"><span data-stu-id="a8577-330">Typically, a folder object is created and initialized by its parent folder's [**IShellFolder::BindToObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject) method.</span></span> <span data-ttu-id="a8577-331">不過，當使用者流覽至您的延伸模組時，Windows 檔案總管會建立並初始化擴充功能的根資料夾物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-331">However, when a user browses into your extension, Windows Explorer creates and initializes the extension's root folder object.</span></span> <span data-ttu-id="a8577-332">根資料夾物件透過 [**IPersistFolder：： Initialize**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipersistfolder-initialize) 接收的 PIDL 包含從桌面到根資料夾的路徑，您將必須為您的延伸模組建立完整的 pidl。</span><span class="sxs-lookup"><span data-stu-id="a8577-332">The PIDL that the root folder object receives through [**IPersistFolder::Initialize**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipersistfolder-initialize) contains the path from the desktop to the root folder that you will need to construct fully qualified PIDLs for your extension.</span></span>

### <a name="ishellfolder-interface"></a><span data-ttu-id="a8577-333">IShellFolder 介面</span><span class="sxs-lookup"><span data-stu-id="a8577-333">IShellFolder Interface</span></span>

<span data-ttu-id="a8577-334">Shell 會將擴充功能視為資料夾物件的階層式排序集合。</span><span class="sxs-lookup"><span data-stu-id="a8577-334">The Shell treats an extension as a hierarchically ordered collection of folder objects.</span></span> <span data-ttu-id="a8577-335">[**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder)介面是任何延伸模組執行的核心。</span><span class="sxs-lookup"><span data-stu-id="a8577-335">The [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) interface is the core of any extension implementation.</span></span> <span data-ttu-id="a8577-336">它代表資料夾物件，並提供 Windows 檔案總管所需的大部分資訊，以顯示資料夾的內容。</span><span class="sxs-lookup"><span data-stu-id="a8577-336">It represents a folder object and provides Windows Explorer with much of the information needed to display the contents of the folder.</span></span>

<span data-ttu-id="a8577-337">[**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) 通常是資料夾物件直接公開之 [**IPersistFolder**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder) 以外的唯一資料夾介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-337">[**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) is typically the only folder interface other than [**IPersistFolder**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder) that is directly exposed by a folder object.</span></span> <span data-ttu-id="a8577-338">雖然 Windows 檔案總管使用各種必要和選用的介面來取得資料夾內容的相關資訊，但它會透過 **IShellFolder** 取得這些介面的指標。</span><span class="sxs-lookup"><span data-stu-id="a8577-338">While Windows Explorer uses a variety of required and optional interfaces to obtain information about the contents of the folder, it obtains pointers to those interfaces through **IShellFolder**.</span></span>

<span data-ttu-id="a8577-339">Windows 檔案總管會以各種不同的方式取得延伸模組根資料夾的 CLSID。</span><span class="sxs-lookup"><span data-stu-id="a8577-339">Windows Explorer obtains the CLSID of your extension's root folder in a variety of ways.</span></span> <span data-ttu-id="a8577-340">如需詳細資訊，請參閱 [指定命名空間延伸的位置](nse-junction.md) 或 [顯示命名空間延伸模組的 Self-Contained 視圖](nse-view.md)。</span><span class="sxs-lookup"><span data-stu-id="a8577-340">For details, see [Specifying a Namespace Extension's Location](nse-junction.md) or [Displaying a Self-Contained View of a Namespace Extension](nse-view.md).</span></span> <span data-ttu-id="a8577-341">Windows 檔案總管接著會使用該 CLSID 來建立和初始化根資料夾的實例，並查詢 [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-341">Windows Explorer then uses that CLSID to create and initialize an instance of the root folder and query for an [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) interface.</span></span> <span data-ttu-id="a8577-342">您的擴充功能會建立資料夾物件來代表根資料夾，並傳回物件的 **IShellFolder** 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-342">Your extension creates a folder object to represent the root folder and returns the object's **IShellFolder** interface.</span></span> <span data-ttu-id="a8577-343">擴充功能與 Windows 檔案總管之間的大部分互動都是透過 **IShellFolder** 進行。</span><span class="sxs-lookup"><span data-stu-id="a8577-343">Much of the remainder of the interaction between your extension and Windows Explorer then takes place through **IShellFolder**.</span></span> <span data-ttu-id="a8577-344">Windows 檔案總管會呼叫 **IShellFolder** 以：</span><span class="sxs-lookup"><span data-stu-id="a8577-344">Windows Explorer calls **IShellFolder** to:</span></span>

-   <span data-ttu-id="a8577-345">要求可以列舉根資料夾內容的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-345">Request an object that can enumerate the contents of the root folder.</span></span>
-   <span data-ttu-id="a8577-346">取得根資料夾內容的各種資訊類型。</span><span class="sxs-lookup"><span data-stu-id="a8577-346">Obtain various types of information about the contents of the root folder.</span></span>
-   <span data-ttu-id="a8577-347">要求公開其中一個選用介面的物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-347">Request an object that exposes one of the optional interfaces.</span></span> <span data-ttu-id="a8577-348">然後可以查詢這些介面，以取得其他資訊，例如圖示或快捷方式功能表。</span><span class="sxs-lookup"><span data-stu-id="a8577-348">Those interfaces can then be queried for additional information, such as icons or shortcut menus.</span></span>
-   <span data-ttu-id="a8577-349">要求一個資料夾物件，代表根資料夾的子資料夾。</span><span class="sxs-lookup"><span data-stu-id="a8577-349">Request a folder object that represents a subfolder of the root folder.</span></span>

<span data-ttu-id="a8577-350">當使用者開啟根資料夾的子資料夾時，Windows 檔案總管會呼叫 [**IShellFolder：： BindToObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject)。</span><span class="sxs-lookup"><span data-stu-id="a8577-350">When a user opens a subfolder of the root folder, Windows Explorer calls [**IShellFolder::BindToObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject).</span></span> <span data-ttu-id="a8577-351">您的擴充功能會建立並初始化新的資料夾物件，以代表子資料夾並傳回其 [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-351">Your extension creates and initializes a new folder object to represent the subfolder and returns its [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) interface.</span></span> <span data-ttu-id="a8577-352">Windows 檔案總管接著會針對各種類型的資訊呼叫這個介面，依此類推，直到使用者決定在 Shell 命名空間中的其他位置流覽或關閉 Windows 檔案總管為止。</span><span class="sxs-lookup"><span data-stu-id="a8577-352">Windows Explorer then calls this interface for various types of information, and so on until the user decides to navigate elsewhere in the Shell namespace or close Windows Explorer.</span></span>

<span data-ttu-id="a8577-353">本節的其餘部分將簡短討論更重要的 [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) 方法，以及如何執行這些方法。</span><span class="sxs-lookup"><span data-stu-id="a8577-353">The remainder of this section briefly discusses the more important [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) methods and how to implement them.</span></span>

### <a name="enumobjects"></a><span data-ttu-id="a8577-354">EnumObjects</span><span class="sxs-lookup"><span data-stu-id="a8577-354">EnumObjects</span></span>

<span data-ttu-id="a8577-355">在樹狀檢視中顯示資料夾的內容之前，Windows 檔案總管必須先藉由呼叫 [**IShellFolder：： EnumObjects**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-enumobjects) 方法來判斷資料夾包含的內容。</span><span class="sxs-lookup"><span data-stu-id="a8577-355">Before displaying the contents of a folder in the tree view, Windows Explorer must first determine what the folder contains by calling the [**IShellFolder::EnumObjects**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-enumobjects) method.</span></span> <span data-ttu-id="a8577-356">這個方法會建立一個標準的 OLE 列舉物件，此物件會公開 [**IEnumIDList**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumidlist) 介面並傳回該介面指標。</span><span class="sxs-lookup"><span data-stu-id="a8577-356">This method creates a standard OLE enumeration object that exposes an [**IEnumIDList**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumidlist) interface and returns that interface pointer.</span></span> <span data-ttu-id="a8577-357">**IEnumIDList** 介面可讓 Windows 檔案總管取得資料夾所包含之所有物件的 pidl。</span><span class="sxs-lookup"><span data-stu-id="a8577-357">The **IEnumIDList** interface allows Windows Explorer to obtain the PIDLs of all the objects contained by the folder.</span></span> <span data-ttu-id="a8577-358">這些 Pidl 接著會用來取得資料夾所包含之物件的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="a8577-358">These PIDLs are then used to obtain information about the objects contained by the folder.</span></span> <span data-ttu-id="a8577-359">如需詳細資訊，請參閱 [IEnumIDList 介面](#ienumidlist-interface)。</span><span class="sxs-lookup"><span data-stu-id="a8577-359">For further details, see [IEnumIDList Interface](#ienumidlist-interface).</span></span>

> [!Note]  
> <span data-ttu-id="a8577-360">[**IEnumIDList：： Next**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ienumidlist-next)方法應該只傳回相對於父資料夾的 pidl。</span><span class="sxs-lookup"><span data-stu-id="a8577-360">The [**IEnumIDList::Next**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ienumidlist-next) method should only return PIDLs that are relative to the parent folder.</span></span> <span data-ttu-id="a8577-361">PIDL 只能包含物件的 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構，後面接著結束字元。</span><span class="sxs-lookup"><span data-stu-id="a8577-361">The PIDL should contain only the object's [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure, followed by a terminator.</span></span>

 

### <a name="createviewobject"></a><span data-ttu-id="a8577-362">CreateViewObject</span><span class="sxs-lookup"><span data-stu-id="a8577-362">CreateViewObject</span></span>

<span data-ttu-id="a8577-363">在顯示資料夾的內容之前，Windows 檔案總管會呼叫這個方法來要求 [**IShellView**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview) 介面的指標。</span><span class="sxs-lookup"><span data-stu-id="a8577-363">Before the contents of a folder are displayed, Windows Explorer calls this method to request a pointer to an [**IShellView**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview) interface.</span></span> <span data-ttu-id="a8577-364">Windows 檔案總管使用此介面來管理資料夾檢視。</span><span class="sxs-lookup"><span data-stu-id="a8577-364">This interface is used by Windows Explorer to manage the folder view.</span></span> <span data-ttu-id="a8577-365">建立資料夾 view 物件，並傳回其 **IShellView** 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-365">Create a folder view object and return its **IShellView** interface.</span></span>

<span data-ttu-id="a8577-366">也會呼叫 [**IShellFolder：： CreateViewObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-createviewobject) 方法來要求資料夾本身的其中一個選用介面，例如 [**ICoNtextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu)。</span><span class="sxs-lookup"><span data-stu-id="a8577-366">The [**IShellFolder::CreateViewObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-createviewobject) method is also called to request one of the optional interfaces, such as [**IContextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu), for the folder itself.</span></span> <span data-ttu-id="a8577-367">您的這個方法的執行應該建立一個物件，此物件會公開所要求的介面，並傳回介面指標。</span><span class="sxs-lookup"><span data-stu-id="a8577-367">Your implementation of this method should create an object that exposes the requested interface and returns the interface pointer.</span></span> <span data-ttu-id="a8577-368">如果 Windows 檔案總管需要資料夾所包含的其中一個物件的選擇性介面，則會呼叫 [**IShellFolder：： GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof)。</span><span class="sxs-lookup"><span data-stu-id="a8577-368">If Windows Explorer needs an optional interface for one of the objects contained by the folder, it will call [**IShellFolder::GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof).</span></span>

### <a name="getuiobjectof"></a><span data-ttu-id="a8577-369">GetUIObjectOf</span><span class="sxs-lookup"><span data-stu-id="a8577-369">GetUIObjectOf</span></span>

<span data-ttu-id="a8577-370">雖然您可以透過 [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) 方法使用資料夾內容的基本資訊，但您的延伸模組也可以提供不同類型的額外資訊 Windows 檔案總管。</span><span class="sxs-lookup"><span data-stu-id="a8577-370">While basic information about the contents of a folder is available through the [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) methods, your extension can also provide Windows Explorer with various kinds of additional information.</span></span> <span data-ttu-id="a8577-371">例如，您可以指定資料夾內容或物件快捷方式功能表的圖示。</span><span class="sxs-lookup"><span data-stu-id="a8577-371">For instance, you can specify icons for the contents of a folder or an object's shortcut menu.</span></span> <span data-ttu-id="a8577-372">Windows 檔案總管會呼叫 [**IShellFolder：： GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) 方法，以嘗試抓取資料夾所包含之物件的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="a8577-372">Windows Explorer calls the [**IShellFolder::GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) method to attempt to retrieve additional information about an object that is contained by a folder.</span></span> <span data-ttu-id="a8577-373">Windows 檔案總管指定要取得資訊的物件，以及相關介面的 IID。</span><span class="sxs-lookup"><span data-stu-id="a8577-373">Windows Explorer specifies which object it wants the information for, and the IID of the relevant interface.</span></span> <span data-ttu-id="a8577-374">資料夾物件接著會建立物件，此物件會公開所要求的介面，並傳回介面指標。</span><span class="sxs-lookup"><span data-stu-id="a8577-374">The folder object then creates an object that exposes the requested interface and returns the interface pointer.</span></span>

<span data-ttu-id="a8577-375">如果您的延伸模組允許使用者使用拖放或剪貼簿來傳送物件，Windows 檔案總管會呼叫 [**IShellFolder：： GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) 來要求 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 或 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-375">If your extension allows users to transfer objects with drag-and-drop or the clipboard, Windows Explorer will call [**IShellFolder::GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) to request an [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) or [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span> <span data-ttu-id="a8577-376">如需詳細資訊，請參閱 [使用拖放和剪貼簿來傳送 Shell 物件](dragdrop.md)。</span><span class="sxs-lookup"><span data-stu-id="a8577-376">For details, see [Transferring Shell Objects with Drag-and-Drop and the Clipboard](dragdrop.md).</span></span>

<span data-ttu-id="a8577-377">Windows 檔案總管會在需要與資料夾本身相同的資訊類型時，呼叫 [**IShellFolder：： CreateViewObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-createviewobject) 。</span><span class="sxs-lookup"><span data-stu-id="a8577-377">Windows Explorer calls [**IShellFolder::CreateViewObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-createviewobject) when it wants the same sort of information about the folder itself.</span></span>

### <a name="bindtoobject"></a><span data-ttu-id="a8577-378">BindToObject</span><span class="sxs-lookup"><span data-stu-id="a8577-378">BindToObject</span></span>

<span data-ttu-id="a8577-379">當使用者嘗試開啟您的其中一個延伸的子資料夾時，Windows 檔案總管會呼叫 [**IShellFolder：： BindToObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject) 方法。</span><span class="sxs-lookup"><span data-stu-id="a8577-379">Windows Explorer calls the [**IShellFolder::BindToObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject) method when a user attempts to open one of your extension's subfolders.</span></span> <span data-ttu-id="a8577-380">如果 *riid* 設定為 IID \_ IShellFolder，您應該建立並初始化代表子資料夾的資料夾物件，並傳回物件的 [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-380">If *riid* is set to IID\_IShellFolder, you should create and initialize a folder object that represents the subfolder and return the object's [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) interface.</span></span>

> [!Note]  
> <span data-ttu-id="a8577-381">目前，Windows 檔案總管只會呼叫這個方法來要求 [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-381">At present, Windows Explorer calls this method only to request an [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) interface.</span></span> <span data-ttu-id="a8577-382">但是，請勿假設這種情況一律會是如此。</span><span class="sxs-lookup"><span data-stu-id="a8577-382">However, do not assume that this will always be the case.</span></span> <span data-ttu-id="a8577-383">您應該一律先檢查 *riid* 的值，再繼續進行。</span><span class="sxs-lookup"><span data-stu-id="a8577-383">You should always check the value of *riid* before proceeding.</span></span>

 

### <a name="getdisplaynameof"></a><span data-ttu-id="a8577-384">GetDisplayNameOf</span><span class="sxs-lookup"><span data-stu-id="a8577-384">GetDisplayNameOf</span></span>

<span data-ttu-id="a8577-385">Windows 檔案總管會呼叫 [**IShellFolder：： GetDisplayNameOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof) 方法，將其中一個資料夾物件的 PIDL 轉換成名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-385">Windows Explorer calls the [**IShellFolder::GetDisplayNameOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof) method to convert the PIDL of one of the folder's objects into a name.</span></span> <span data-ttu-id="a8577-386">該 PIDL 必須相對於物件的父資料夾。</span><span class="sxs-lookup"><span data-stu-id="a8577-386">That PIDL must be relative to the object's parent folder.</span></span> <span data-ttu-id="a8577-387">換句話說，它必須包含單一非 **Null** 的 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構。</span><span class="sxs-lookup"><span data-stu-id="a8577-387">In other words, it must contain a single non-**NULL** [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure.</span></span> <span data-ttu-id="a8577-388">因為有一個以上的方法可以命名物件，Windows 檔案總管藉由在 *uFlags* 參數中設定一或多個 [**SHGDNF**](/windows/win32/api/shobjidl_core/ne-shobjidl_core-_shgdnf)旗標來指定名稱的類型。</span><span class="sxs-lookup"><span data-stu-id="a8577-388">Because there is more than one possible way to name objects, Windows Explorer specifies the type of name by setting one or more [**SHGDNF**](/windows/win32/api/shobjidl_core/ne-shobjidl_core-_shgdnf) flags in the *uFlags* parameter.</span></span> <span data-ttu-id="a8577-389">**SHGDN \_ NORMAL** 或 **SHGDN \_ INFOLDER** 這兩個值的其中一個，將設定為指定名稱是否應相對於資料夾或相對於桌面。</span><span class="sxs-lookup"><span data-stu-id="a8577-389">One of two values, **SHGDN\_NORMAL** or **SHGDN\_INFOLDER**, will be set to specify whether the name should be relative to the folder or relative to the desktop.</span></span> <span data-ttu-id="a8577-390">您可以設定其他三個值的其中之一： **SHGDN \_ FOREDITING**、 **SHGDN \_ FORADDRESSBAR** 或 **SHGDN \_ FORPARSING**，以指定名稱將使用的名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-390">One of the other three values, **SHGDN\_FOREDITING**, **SHGDN\_FORADDRESSBAR**, or **SHGDN\_FORPARSING**, can be set to specify what the name will be used for.</span></span>

<span data-ttu-id="a8577-391">您必須以 [**STRRET**](/windows/desktop/api/Shtypes/ns-shtypes-strret) 結構的形式傳回名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-391">You must return the name in the form of an [**STRRET**](/windows/desktop/api/Shtypes/ns-shtypes-strret) structure.</span></span> <span data-ttu-id="a8577-392">如果未設定 **SHGDN \_ FOREDITING**、 **SHGDN \_ FORADDRESSBAR** 和 **SHGDN \_ FORPARSING** ，則會傳回物件的顯示名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-392">If **SHGDN\_FOREDITING**, **SHGDN\_FORADDRESSBAR**, and **SHGDN\_FORPARSING** are not set, return the object's display name.</span></span> <span data-ttu-id="a8577-393">如果已設定 **SHGDN \_ FORPARSING** 旗標，Windows 檔案總管會要求剖析名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-393">If the **SHGDN\_FORPARSING** flag is set, Windows Explorer is requesting a parsing name.</span></span> <span data-ttu-id="a8577-394">剖析名稱會傳遞至 [**IShellFolder：:P arsedisplayname**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname) 來取得物件的 PIDL，即使它可能位於命名空間階層中目前資料夾的一或多個層級，也是一樣。</span><span class="sxs-lookup"><span data-stu-id="a8577-394">Parsing names are passed to [**IShellFolder::ParseDisplayName**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname) to obtain an object's PIDL, even though it might be located one or more levels below the current folder in the namespace hierarchy.</span></span> <span data-ttu-id="a8577-395">例如，檔案系統物件的剖析名稱是它的路徑。</span><span class="sxs-lookup"><span data-stu-id="a8577-395">For example, the parsing name of a file system object is its path.</span></span> <span data-ttu-id="a8577-396">您可以將檔案系統中任何物件的完整路徑傳遞至桌面的 **IShellFolder：:P arsedisplayname** 方法，它會傳回物件的完整 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-396">You can pass the fully qualified path of any object in the file system to the desktop's **IShellFolder::ParseDisplayName** method, and it will return the object's fully qualified PIDL.</span></span>

<span data-ttu-id="a8577-397">雖然剖析名稱是文字字串，但不一定要包含顯示名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-397">While parsing names are text strings, they do not necessarily have to include the display name.</span></span> <span data-ttu-id="a8577-398">當呼叫 IShellFolder 時，您應該根據最有效率的運作方式來指派剖析名稱 [**：:P arsedisplayname**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname) 。</span><span class="sxs-lookup"><span data-stu-id="a8577-398">You should assign parsing names based on what will work most efficiently when [**IShellFolder::ParseDisplayName**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname) is called.</span></span> <span data-ttu-id="a8577-399">比方說，許多 Shell 的虛擬資料夾不是檔案系統的一部分，而且沒有完整路徑。</span><span class="sxs-lookup"><span data-stu-id="a8577-399">For instance, many of the Shell's virtual folders are not part of the file system and do not have a fully qualified path.</span></span> <span data-ttu-id="a8577-400">相反地，會將 GUID 指派給每個資料夾，而且剖析名稱的格式如下：： {GUID}。</span><span class="sxs-lookup"><span data-stu-id="a8577-400">Instead, each folder is assigned a GUID and the parsing name takes the form ::{GUID}.</span></span> <span data-ttu-id="a8577-401">無論您使用何種配置，都應該能夠可靠地「往返」。</span><span class="sxs-lookup"><span data-stu-id="a8577-401">Regardless of what scheme you use, it should be able to reliably "round trip."</span></span> <span data-ttu-id="a8577-402">比方說，如果呼叫者將剖析名稱傳遞給 **IShellFolder：:P arsedisplayname** 抓取物件的 PIDL，然後將該 PIDL 傳遞給 [**IShellFolder：： GetDisplayNameOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof) ，並設定 **SHGDN \_ FORPARSING** 旗標，則呼叫端應該復原原始剖析名稱。</span><span class="sxs-lookup"><span data-stu-id="a8577-402">For instance, if a caller passes a parsing name to **IShellFolder::ParseDisplayName** to retrieve an object's PIDL, and then passes that PIDL to [**IShellFolder::GetDisplayNameOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof) with the **SHGDN\_FORPARSING** flag set, the caller should recover the original parsing name.</span></span>

### <a name="getattributesof"></a><span data-ttu-id="a8577-403">GetAttributesOf</span><span class="sxs-lookup"><span data-stu-id="a8577-403">GetAttributesOf</span></span>

<span data-ttu-id="a8577-404">Windows 檔案總管會呼叫 [**IShellFolder：： GetAttributesOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof) 方法來判斷資料夾物件所包含的一或多個專案的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8577-404">Windows Explorer calls the [**IShellFolder::GetAttributesOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof) method to determine the attributes of one or more items contained by a folder object.</span></span> <span data-ttu-id="a8577-405">*Cidl* 的值會提供查詢中的專案數，而 *aPidl* 則會指向其 pidl 的清單。</span><span class="sxs-lookup"><span data-stu-id="a8577-405">The value of *cidl* gives the number of items in the query, and *aPidl* points to a list of their PIDLs.</span></span>

<span data-ttu-id="a8577-406">因為某些屬性的測試可能相當耗時，Windows 檔案總管通常會在 *rfgInOut* 中設定其值，以將查詢限制為可用旗標的子集。</span><span class="sxs-lookup"><span data-stu-id="a8577-406">Because testing for some attributes can be time consuming, Windows Explorer typically restricts the query to a subset of the available flags by setting their values in *rfgInOut*.</span></span> <span data-ttu-id="a8577-407">您的方法應該只測試在 *rfgInOut* 中設定旗標的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8577-407">Your method should test for only those attributes whose flags are set in *rfgInOut*.</span></span> <span data-ttu-id="a8577-408">保留有效的旗標集，並清除餘數。</span><span class="sxs-lookup"><span data-stu-id="a8577-408">Leave the valid flags set and clear the remainder.</span></span> <span data-ttu-id="a8577-409">如果查詢中包含一個以上的專案，請只設定適用于所有專案的旗標。</span><span class="sxs-lookup"><span data-stu-id="a8577-409">If more than one item is included in the query, set only those flags that apply to all items.</span></span>

> [!Note]  
> <span data-ttu-id="a8577-410">必須正確設定屬性，才能正確顯示專案。</span><span class="sxs-lookup"><span data-stu-id="a8577-410">The attributes must be properly set for an item to be correctly displayed.</span></span> <span data-ttu-id="a8577-411">比方說，如果專案是包含子資料夾的資料夾，您必須設定 **SFGAO \_ HASSUBFOLDER** 旗標。</span><span class="sxs-lookup"><span data-stu-id="a8577-411">For instance, if an item is a folder that contains subfolders, you must set the **SFGAO\_HASSUBFOLDER** flag.</span></span> <span data-ttu-id="a8577-412">否則，Windows 檔案總管不會在樹狀檢視中顯示專案圖示旁的 +。</span><span class="sxs-lookup"><span data-stu-id="a8577-412">Otherwise, Windows Explorer will not display a + next to the item's icon in the tree view.</span></span>

 

### <a name="parsedisplayname"></a><span data-ttu-id="a8577-413">ParseDisplayName</span><span class="sxs-lookup"><span data-stu-id="a8577-413">ParseDisplayName</span></span>

<span data-ttu-id="a8577-414">[**IShellFolder：:P arsedisplayname**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname)方法在某種意義上是 [**IShellFolder：： GetDisplayNameOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof)的鏡像影像。</span><span class="sxs-lookup"><span data-stu-id="a8577-414">The [**IShellFolder::ParseDisplayName**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname) method is in some sense a mirror image of [**IShellFolder::GetDisplayNameOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof).</span></span> <span data-ttu-id="a8577-415">這個方法最常見的用法是將物件的剖析名稱轉換成相關聯的 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-415">The most common use of this method is to convert an object's parsing name into the associated PIDL.</span></span> <span data-ttu-id="a8577-416">剖析名稱可以參考位於命名空間階層中資料夾底下的任何物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-416">The parsing name can refer to any object that lies below the folder in the namespace hierarchy.</span></span> <span data-ttu-id="a8577-417">傳回的 PIDL 是相對於公開方法的資料夾物件，而且通常不是完整的。</span><span class="sxs-lookup"><span data-stu-id="a8577-417">The returned PIDL is relative to the folder object that exposes the method and is usually not fully qualified.</span></span> <span data-ttu-id="a8577-418">換句話說，雖然 PIDL 可以包含數個 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構，但第一個是物件本身或路徑中的第一個子資料夾，也就是該物件的資料夾。</span><span class="sxs-lookup"><span data-stu-id="a8577-418">In other words, although the PIDL can contain several [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structures, the first will either be that of the object itself or the first subfolder in the path from the folder to the object.</span></span> <span data-ttu-id="a8577-419">呼叫端必須將此 PIDL 附加至資料夾的完整 PIDL，才能取得物件的完整 PIDL。</span><span class="sxs-lookup"><span data-stu-id="a8577-419">The caller will have to append this PIDL to the folder's fully qualified PIDL to obtain a fully qualified PIDL for the object.</span></span>

<span data-ttu-id="a8577-420">[**IShellFolder：**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname) 也可以呼叫:P arsedisplayname 來要求物件的屬性。</span><span class="sxs-lookup"><span data-stu-id="a8577-420">[**IShellFolder::ParseDisplayName**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname) can also be called to request an object's attributes.</span></span> <span data-ttu-id="a8577-421">由於判斷所有適用的屬性可能相當耗時，因此呼叫者只會設定代表呼叫者感興趣之資訊的 [**SFGAO \_ XXX**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof) 旗標。</span><span class="sxs-lookup"><span data-stu-id="a8577-421">Because determining all the applicable attributes can be time consuming, the caller will set only those [**SFGAO\_XXX**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof) flags that represent information that the caller is interested in.</span></span> <span data-ttu-id="a8577-422">您應判斷物件的哪些屬性是 true，並清除其餘的旗標。</span><span class="sxs-lookup"><span data-stu-id="a8577-422">You should determine which of those attributes are true for the object, and clear the remaining flags.</span></span>

### <a name="ienumidlist-interface"></a><span data-ttu-id="a8577-423">IEnumIDList 介面</span><span class="sxs-lookup"><span data-stu-id="a8577-423">IEnumIDList Interface</span></span>

<span data-ttu-id="a8577-424">當 Windows 檔案總管需要列舉資料夾所包含的物件時，它會呼叫 [**IShellFolder：： EnumObjects**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-enumobjects)。</span><span class="sxs-lookup"><span data-stu-id="a8577-424">When Windows Explorer needs to enumerate the objects that are contained by a folder, it calls [**IShellFolder::EnumObjects**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-enumobjects).</span></span> <span data-ttu-id="a8577-425">資料夾物件必須建立公開 [**IEnumIDList**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumidlist) 介面的列舉物件，並傳回該介面指標。</span><span class="sxs-lookup"><span data-stu-id="a8577-425">The folder object must create an enumeration object that exposes the [**IEnumIDList**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumidlist) interface and return that interface pointer.</span></span> <span data-ttu-id="a8577-426">然後，Windows 檔案總管通常會使用 **IEnumIDList** 來列舉資料夾所包含之所有物件的 pidl。</span><span class="sxs-lookup"><span data-stu-id="a8577-426">Windows Explorer will then typically use **IEnumIDList** to enumerate the PIDLs of all the objects contained by the folder.</span></span>

<span data-ttu-id="a8577-427">[**IEnumIDList**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumidlist) 是標準的 OLE 列舉介面，並且會以一般方式執行。</span><span class="sxs-lookup"><span data-stu-id="a8577-427">[**IEnumIDList**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumidlist) is a standard OLE enumeration interface and is implemented in the usual way.</span></span> <span data-ttu-id="a8577-428">不過請記住，您傳回的 Pidl 必須相對於資料夾，而且只包含物件的 [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) 結構和結束字元。</span><span class="sxs-lookup"><span data-stu-id="a8577-428">Remember, however, that the PIDLs that you return must be relative to the folder and contain only the object's [**SHITEMID**](/windows/desktop/api/Shtypes/ns-shtypes-shitemid) structure and a terminator.</span></span>

## <a name="implementing-the-optional-interfaces"></a><span data-ttu-id="a8577-429">執行選用介面</span><span class="sxs-lookup"><span data-stu-id="a8577-429">Implementing the Optional Interfaces</span></span>

<span data-ttu-id="a8577-430">有一些選用的 Shell 介面可供延伸模組的資料夾物件支援。</span><span class="sxs-lookup"><span data-stu-id="a8577-430">There are a number of optional Shell interfaces that your extension's folder objects can support.</span></span> <span data-ttu-id="a8577-431">其中有許多專案（例如 [**IExtractIcon**](/windows/win32/api/shlobj_core/nn-shlobj_core-iextracticona)）可讓您自訂使用者查看延伸模組的方式的各種層面。</span><span class="sxs-lookup"><span data-stu-id="a8577-431">Many of them, such as [**IExtractIcon**](/windows/win32/api/shlobj_core/nn-shlobj_core-iextracticona), allow you to customize various aspects of the way the user views your extension.</span></span> <span data-ttu-id="a8577-432">其他（例如 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject)）可讓您的延伸模組支援拖放功能。</span><span class="sxs-lookup"><span data-stu-id="a8577-432">Others, such as [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject), allow your extension to support features such as drag-and-drop.</span></span>

<span data-ttu-id="a8577-433">資料夾物件不會直接公開任何選用的介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-433">None of the optional interfaces are exposed directly by a folder object.</span></span> <span data-ttu-id="a8577-434">相反地，Windows 檔案總管會呼叫兩個 [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) 方法的其中一個來要求介面：</span><span class="sxs-lookup"><span data-stu-id="a8577-434">Instead, Windows Explorer calls one of two [**IShellFolder**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder) methods to request an interface:</span></span>

-   <span data-ttu-id="a8577-435">Windows 檔案總管會呼叫資料夾物件的 [**IShellFolder：： GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) ，以針對該資料夾所包含的其中一個物件要求介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-435">Windows Explorer calls a folder object's [**IShellFolder::GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) to request an interface for one of the objects contained by the folder.</span></span>
-   <span data-ttu-id="a8577-436">Windows 檔案總管會呼叫資料夾物件的 [**IShellFolder：： CreateViewObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-createviewobject) 來要求資料夾本身的介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-436">Windows Explorer calls a folder object's [**IShellFolder::CreateViewObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-createviewobject) to request an interface for the folder itself.</span></span>

<span data-ttu-id="a8577-437">為了提供資訊，folder 物件會建立公開所要求介面的物件，並傳回介面指標。</span><span class="sxs-lookup"><span data-stu-id="a8577-437">To provide the information, the folder object creates an object that exposes the requested interface and returns the interface pointer.</span></span> <span data-ttu-id="a8577-438">Windows 檔案總管接著會呼叫該介面以取得所需的資訊。</span><span class="sxs-lookup"><span data-stu-id="a8577-438">Windows Explorer then calls that interface to retrieve the needed information.</span></span> <span data-ttu-id="a8577-439">本節將討論最常使用的選用介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-439">This section discusses the most commonly used optional interfaces.</span></span>

### <a name="iextracticon"></a><span data-ttu-id="a8577-440">IExtractIcon</span><span class="sxs-lookup"><span data-stu-id="a8577-440">IExtractIcon</span></span>

<span data-ttu-id="a8577-441">Windows 檔案總管會在顯示資料夾內容之前要求 [**IExtractIcon**](/windows/win32/api/shlobj_core/nn-shlobj_core-iextracticona) 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-441">Windows Explorer requests an [**IExtractIcon**](/windows/win32/api/shlobj_core/nn-shlobj_core-iextracticona) interface before it displays the contents of a folder.</span></span> <span data-ttu-id="a8577-442">介面可讓您的延伸模組為資料夾所包含的物件指定自訂圖示。</span><span class="sxs-lookup"><span data-stu-id="a8577-442">The interface allows your extension to specify custom icons for the objects that are contained by the folder.</span></span> <span data-ttu-id="a8577-443">否則，將會使用標準的檔案和資料夾圖示。</span><span class="sxs-lookup"><span data-stu-id="a8577-443">Otherwise, the standard file and folder icons will be used.</span></span> <span data-ttu-id="a8577-444">若要提供自訂圖示，請建立顯示 **IExtractIcon** 的圖示抽取物件，並將指標傳回至該介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-444">To provide a custom icon, create an icon extraction object that exposes **IExtractIcon** and return a pointer to that interface.</span></span> <span data-ttu-id="a8577-445">如需進一步討論，請參閱 **IExtractIcon** 參考檔或 [建立圖示處理常式](./how-to-create-icon-handlers.md)。</span><span class="sxs-lookup"><span data-stu-id="a8577-445">For further discussion, see the **IExtractIcon** reference documentation or [Creating Icon Handlers](./how-to-create-icon-handlers.md).</span></span>

### <a name="icontextmenu"></a><span data-ttu-id="a8577-446">ICoNtextMenu</span><span class="sxs-lookup"><span data-stu-id="a8577-446">IContextMenu</span></span>

<span data-ttu-id="a8577-447">當使用者以滑鼠右鍵按一下物件時，Windows 檔案總管會要求 [**ICoNtextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu) 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-447">When a user right-clicks an object, Windows Explorer requests an [**IContextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu) interface.</span></span> <span data-ttu-id="a8577-448">若要提供物件的快捷方式功能表，請建立功能表處理常式物件，並傳回其 **ICoNtextMenu** 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-448">To provide shortcut menus for your objects, create a menu handler object and return its **IContextMenu** interface.</span></span>

<span data-ttu-id="a8577-449">建立功能表處理常式物件的程式與用來建立功能表處理常式 Shell 延伸模組的程式非常類似。</span><span class="sxs-lookup"><span data-stu-id="a8577-449">The procedures for creating a menu handler object are very similar to those used to create a menu handler Shell extension.</span></span> <span data-ttu-id="a8577-450">如需詳細資訊，請參閱 [建立內容功能表處理常式](context-menu-handlers.md) 或 [**ICoNtextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu)、 [**ICoNtextMenu2**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu2)或 [**ICoNtextMenu3**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu3) 參考。</span><span class="sxs-lookup"><span data-stu-id="a8577-450">For details, see [Creating Context Menu Handlers](context-menu-handlers.md) or the [**IContextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu), [**IContextMenu2**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu2), or [**IContextMenu3**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu3) reference.</span></span>

### <a name="iqueryinfo"></a><span data-ttu-id="a8577-451">IQueryInfo</span><span class="sxs-lookup"><span data-stu-id="a8577-451">IQueryInfo</span></span>

<span data-ttu-id="a8577-452">Windows 檔案總管會呼叫 [**IQueryInfo**](/windows/win32/api/shlobj_core/nn-shlobj_core-iqueryinfo) 介面，以抓取提示文字字串。</span><span class="sxs-lookup"><span data-stu-id="a8577-452">Windows Explorer calls the [**IQueryInfo**](/windows/win32/api/shlobj_core/nn-shlobj_core-iqueryinfo) interface to retrieve an infotip text string.</span></span>

### <a name="idataobject-and-idroptarget"></a><span data-ttu-id="a8577-453">IDataObject 和 IDropTarget</span><span class="sxs-lookup"><span data-stu-id="a8577-453">IDataObject and IDropTarget</span></span>

<span data-ttu-id="a8577-454">當 Windows 檔案總管顯示物件時，資料夾物件無法直接知道使用者何時嘗試剪下、複製或拖曳物件。</span><span class="sxs-lookup"><span data-stu-id="a8577-454">When your objects are displayed by Windows Explorer, a folder object has no direct way to know when a user is attempting to cut, copy, or drag an object.</span></span> <span data-ttu-id="a8577-455">相反地，Windows 檔案總管會要求 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-455">Instead, Windows Explorer requests an [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="a8577-456">若要允許傳送物件，請建立資料物件，並傳回其 **IDataObject** 介面的指標。</span><span class="sxs-lookup"><span data-stu-id="a8577-456">To allow the object to be transferred, create a data object and return a pointer to its **IDataObject** interface.</span></span>

<span data-ttu-id="a8577-457">同樣地，使用者可能會嘗試將資料物件放在其中一個物件的 Windows 檔案總管標記法，例如圖示或網址列路徑。</span><span class="sxs-lookup"><span data-stu-id="a8577-457">Similarly, a user might attempt to drop a data object on a Windows Explorer representation of one of your objects, such as an icon or address bar path.</span></span> <span data-ttu-id="a8577-458">Windows 檔案總管接著會要求 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 介面。</span><span class="sxs-lookup"><span data-stu-id="a8577-458">Windows Explorer then requests an [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span> <span data-ttu-id="a8577-459">若要允許卸載資料物件，請建立公開 **IDropTarget** 介面的物件，並傳回介面指標。</span><span class="sxs-lookup"><span data-stu-id="a8577-459">To allow the data object to be dropped, create an object that exposes an **IDropTarget** interface and return the interface pointer.</span></span>

<span data-ttu-id="a8577-460">處理資料傳輸是撰寫命名空間延伸模組的最棘手層面之一。</span><span class="sxs-lookup"><span data-stu-id="a8577-460">Handling data transfer is one of the trickier aspects of writing namespace extensions.</span></span> <span data-ttu-id="a8577-461">如需詳細的討論，請參閱 [使用拖放和剪貼簿來傳送 Shell 物件](dragdrop.md)。</span><span class="sxs-lookup"><span data-stu-id="a8577-461">For a detailed discussion, see [Transferring Shell Objects with Drag-and-Drop and the Clipboard](dragdrop.md).</span></span>

## <a name="working-with-the-default-shell-folder-view-implementation"></a><span data-ttu-id="a8577-462">使用預設的 Shell 資料夾檢視執行</span><span class="sxs-lookup"><span data-stu-id="a8577-462">Working With the Default Shell Folder View Implementation</span></span>

<span data-ttu-id="a8577-463">使用預設 Shell 資料夾 view 物件 (DefView) 的資料來源必須執行這些介面：</span><span class="sxs-lookup"><span data-stu-id="a8577-463">Data sources that use the default Shell folder view object (DefView) must implement these interfaces:</span></span>

-   [<span data-ttu-id="a8577-464">**IShellFolder**</span><span class="sxs-lookup"><span data-stu-id="a8577-464">**IShellFolder**</span></span>](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder)
-   [<span data-ttu-id="a8577-465">**IShellFolder2**</span><span class="sxs-lookup"><span data-stu-id="a8577-465">**IShellFolder2**</span></span>](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder2)
-   [<span data-ttu-id="a8577-466">**IPersistFolder**</span><span class="sxs-lookup"><span data-stu-id="a8577-466">**IPersistFolder**</span></span>](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder)
-   [<span data-ttu-id="a8577-467">**IPersistFolder2**</span><span class="sxs-lookup"><span data-stu-id="a8577-467">**IPersistFolder2**</span></span>](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder2)

<span data-ttu-id="a8577-468">也可以選擇執行 [**IPersistFolder3**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder3)。</span><span class="sxs-lookup"><span data-stu-id="a8577-468">Optionally, they can also implement [**IPersistFolder3**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder3).</span></span>

 

 
