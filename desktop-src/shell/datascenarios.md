---
description: 本檔提供常見的 Shell 資料傳輸案例，並討論如何在應用程式中執行每一個。
ms.assetid: 7fce555c-a93d-4414-9119-7ae9acdd4d89
title: 處理命令介面資料傳輸案例
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 35855b66e4108580d5bac305855837563ca59785
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104972029"
---
# <a name="handling-shell-data-transfer-scenarios"></a><span data-ttu-id="3ff38-103">處理命令介面資料傳輸案例</span><span class="sxs-lookup"><span data-stu-id="3ff38-103">Handling Shell Data Transfer Scenarios</span></span>

<span data-ttu-id="3ff38-104">[Shell 資料物件](dataobject.md)檔探討用來透過拖放或剪貼簿傳輸 Shell 資料的一般方法。</span><span class="sxs-lookup"><span data-stu-id="3ff38-104">The [Shell Data Object](dataobject.md) document discussed the general approach that is used to transfer Shell data with drag-and-drop or the Clipboard.</span></span> <span data-ttu-id="3ff38-105">不過，若要在您的應用程式中執行 Shell 資料傳輸，您也必須瞭解如何將這些一般原則和技術套用到各種不同的方式來傳送 Shell 資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-105">However, to implement Shell data transfer in your application, you must also understand how to apply these general principles and techniques to the variety of ways that Shell data can be transferred.</span></span> <span data-ttu-id="3ff38-106">本檔提供常見的 Shell 資料傳輸案例，並討論如何在應用程式中執行每一個。</span><span class="sxs-lookup"><span data-stu-id="3ff38-106">This document presents common Shell data transfer scenarios and discusses how to implement each one in your application.</span></span>

-   [<span data-ttu-id="3ff38-107">一般指導方針</span><span class="sxs-lookup"><span data-stu-id="3ff38-107">General Guidelines</span></span>](#general-guidelines)
-   [<span data-ttu-id="3ff38-108">將檔案名稱從剪貼簿複製到應用程式</span><span class="sxs-lookup"><span data-stu-id="3ff38-108">Copying File Names from the Clipboard to an Application</span></span>](#copying-file-names-from-the-clipboard-to-an-application)
    -   [<span data-ttu-id="3ff38-109">從資料物件中解壓縮檔案名稱</span><span class="sxs-lookup"><span data-stu-id="3ff38-109">Extracting the File Names from the Data Object</span></span>](#extracting-the-file-names-from-the-data-object)
-   [<span data-ttu-id="3ff38-110">將已放置檔案的內容複寫到應用程式中</span><span class="sxs-lookup"><span data-stu-id="3ff38-110">Copying the Contents of a Dropped File into an Application</span></span>](#copying-the-contents-of-a-dropped-file-into-an-application)
    -   [<span data-ttu-id="3ff38-111">使用 CFSTR \_ FILECONTENTS 格式將檔案中的資料解壓縮</span><span class="sxs-lookup"><span data-stu-id="3ff38-111">Using the CFSTR\_FILECONTENTS Format to Extract Data from a File</span></span>](/windows)
-   [<span data-ttu-id="3ff38-112">處理優化的移動作業</span><span class="sxs-lookup"><span data-stu-id="3ff38-112">Handling Optimized Move Operations</span></span>](#handling-optimized-move-operations)
-   [<span data-ttu-id="3ff38-113">處理刪除作業-貼上作業</span><span class="sxs-lookup"><span data-stu-id="3ff38-113">Handling Delete-on-Paste Operations</span></span>](#handling-delete-on-paste-operations)
-   [<span data-ttu-id="3ff38-114">從虛擬資料夾傳輸資料</span><span class="sxs-lookup"><span data-stu-id="3ff38-114">Transfering Data to and from Virtual Folders</span></span>](#transfering-data-to-and-from-virtual-folders)
    -   [<span data-ttu-id="3ff38-115">接受虛擬資料夾中的資料</span><span class="sxs-lookup"><span data-stu-id="3ff38-115">Accepting Data from a Virtual Folder</span></span>](#accepting-data-from-a-virtual-folder)
    -   [<span data-ttu-id="3ff38-116">從命名空間延伸模組來回傳送資料</span><span class="sxs-lookup"><span data-stu-id="3ff38-116">Transferring Data to and from a NameSpace Extension</span></span>](#transferring-data-to-and-from-a-namespace-extension)
-   [<span data-ttu-id="3ff38-117">將檔案放在資源回收筒</span><span class="sxs-lookup"><span data-stu-id="3ff38-117">Dropping Files on the Recycle Bin</span></span>](#dropping-files-on-the-recycle-bin)
-   [<span data-ttu-id="3ff38-118">建立和匯入片段檔案</span><span class="sxs-lookup"><span data-stu-id="3ff38-118">Creating and Importing Scrap Files</span></span>](#creating-and-importing-scrap-files)
    -   [<span data-ttu-id="3ff38-119">來回支援</span><span class="sxs-lookup"><span data-stu-id="3ff38-119">Round-trip Support</span></span>](#round-trip-support)
    -   [<span data-ttu-id="3ff38-120">快取的資料格式</span><span class="sxs-lookup"><span data-stu-id="3ff38-120">Cached Data Formats</span></span>](#cached-data-formats)
    -   [<span data-ttu-id="3ff38-121">延遲轉譯</span><span class="sxs-lookup"><span data-stu-id="3ff38-121">Delayed Rendering</span></span>](#delayed-rendering)
-   [<span data-ttu-id="3ff38-122">非同步地拖放 Shell 物件</span><span class="sxs-lookup"><span data-stu-id="3ff38-122">Dragging and Dropping Shell Objects Asynchronously</span></span>](#dragging-and-dropping-shell-objects-asynchronously)
    -   [<span data-ttu-id="3ff38-123">使用 Iasyncoperation<tresult>HTTP/IDataObjectAsyncCapability</span><span class="sxs-lookup"><span data-stu-id="3ff38-123">Using IASyncOperation/IDataObjectAsyncCapability</span></span>](#using-iasyncoperationidataobjectasynccapability)

> [!Note]  
> <span data-ttu-id="3ff38-124">雖然每個案例都討論特定的資料傳輸作業，但其中有許多都適用于各種相關的案例。</span><span class="sxs-lookup"><span data-stu-id="3ff38-124">Although each of these scenarios discusses a specific data transfer operation, many of them apply to a variety of related scenarios.</span></span> <span data-ttu-id="3ff38-125">例如，大部分剪貼簿與拖放傳輸之間的主要差異在於資料物件抵達目標的方式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-125">For instance, the primary difference between most Clipboard and drag-and-drop transfers is in how the data object arrives at the target.</span></span> <span data-ttu-id="3ff38-126">一旦目標有指向資料物件 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 介面的指標，則這兩種資料傳輸類型的解壓縮資訊程式大致相同。</span><span class="sxs-lookup"><span data-stu-id="3ff38-126">Once the target has a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface, the procedures for extracting information are largely the same for both types of data transfer.</span></span> <span data-ttu-id="3ff38-127">不過，某些案例僅限於特定類型的作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-127">However, some of the scenarios are limited to a specific type of operation.</span></span> <span data-ttu-id="3ff38-128">如需詳細資料，請參閱個別案例。</span><span class="sxs-lookup"><span data-stu-id="3ff38-128">Refer to the individual scenario for details.</span></span>

 

## <a name="general-guidelines"></a><span data-ttu-id="3ff38-129">一般準則</span><span class="sxs-lookup"><span data-stu-id="3ff38-129">General Guidelines</span></span>

<span data-ttu-id="3ff38-130">下列各節將討論單一、相當特定的資料傳輸案例。</span><span class="sxs-lookup"><span data-stu-id="3ff38-130">Each of the following sections discusses a single, fairly specific data transfer scenario.</span></span> <span data-ttu-id="3ff38-131">不過，資料傳輸通常更複雜，而且可能牽涉到幾個案例的層面。</span><span class="sxs-lookup"><span data-stu-id="3ff38-131">However, data transfers are often more complex and might involve aspects of several scenarios.</span></span> <span data-ttu-id="3ff38-132">您通常不知道實際需要處理的案例。</span><span class="sxs-lookup"><span data-stu-id="3ff38-132">You typically do not know, in advance, which scenario you will actually need to handle.</span></span> <span data-ttu-id="3ff38-133">以下是一些要牢記在心的一般方針。</span><span class="sxs-lookup"><span data-stu-id="3ff38-133">Here are a few general guidelines to keep in mind.</span></span>

<span data-ttu-id="3ff38-134">針對資料來源：</span><span class="sxs-lookup"><span data-stu-id="3ff38-134">For data sources:</span></span>

-   <span data-ttu-id="3ff38-135">Shell 剪貼簿格式（除了 [CF \_ HDROP](clipboard.md)）不會預先定義。</span><span class="sxs-lookup"><span data-stu-id="3ff38-135">The Shell Clipboard formats, with the exception of [CF\_HDROP](clipboard.md), are not predefined.</span></span> <span data-ttu-id="3ff38-136">您要使用的每一種格式都必須透過呼叫 [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata)來註冊。</span><span class="sxs-lookup"><span data-stu-id="3ff38-136">Each format you want to use must be registered by calling [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span></span>
-   <span data-ttu-id="3ff38-137">資料物件中的格式是以來源的喜好設定順序提供。</span><span class="sxs-lookup"><span data-stu-id="3ff38-137">The formats in the data objects are provided in the order of preference from the source.</span></span> <span data-ttu-id="3ff38-138">列舉資料物件，並挑選您可以取用的第一個物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-138">Enumerate the data object and pick the first one you can consume.</span></span>
-   <span data-ttu-id="3ff38-139">包含您可以支援的任意數量格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-139">Include as many formats as you can support.</span></span> <span data-ttu-id="3ff38-140">您通常不知道資料物件將會放在哪裡。</span><span class="sxs-lookup"><span data-stu-id="3ff38-140">You generally do not know where the data object will be dropped.</span></span> <span data-ttu-id="3ff38-141">這種作法可改善資料物件包含放置目標可接受之格式的機率。</span><span class="sxs-lookup"><span data-stu-id="3ff38-141">This practice improves the odds that the data object will contain a format that the drop target can accept.</span></span>
-   <span data-ttu-id="3ff38-142">您應以 [CF \_ HDROP](clipboard.md) 格式提供現有的檔案。</span><span class="sxs-lookup"><span data-stu-id="3ff38-142">Existing files should be offered with the [CF\_HDROP](clipboard.md) format.</span></span>
-   <span data-ttu-id="3ff38-143">使用[CFSTR \_ FILECONTENTS](clipboard.md) / [CFSTR \_ FILEDESCRIPTOR](clipboard.md)格式提供類似檔案的資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-143">Offer file-like data with [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md) formats.</span></span> <span data-ttu-id="3ff38-144">這種方法可讓目標從資料物件建立檔案，而不需要知道有關基礎資料儲存的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="3ff38-144">This approach allows the target to create a file from a data object without needing to know anything about the underlying data storage.</span></span> <span data-ttu-id="3ff38-145">您通常應該將資料顯示為 [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) 介面。</span><span class="sxs-lookup"><span data-stu-id="3ff38-145">You should normally present the data as an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface.</span></span> <span data-ttu-id="3ff38-146">這種資料傳輸機制比全域記憶體物件更有彈性，而且使用的記憶體更少。</span><span class="sxs-lookup"><span data-stu-id="3ff38-146">This data transfer mechanism is more flexible than a global memory object and uses much less memory.</span></span>
-   <span data-ttu-id="3ff38-147">拖曳 Shell 專案時，拖曳來源應該提供 [CFSTR \_ SHELLIDLIST](clipboard.md) 格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-147">Drag sources should offer the [CFSTR\_SHELLIDLIST](clipboard.md) format when dragging Shell items.</span></span> <span data-ttu-id="3ff38-148">您可以透過 [**IShellFolder：： GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) 或 [**IShellItem：： BindToHandler**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem-bindtohandler) 方法取得專案的資料物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-148">Data objects for items can be acquired through either the [**IShellFolder::GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) or [**IShellItem::BindToHandler**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem-bindtohandler) methods.</span></span> <span data-ttu-id="3ff38-149">資料來源可以使用 [**SHCreateDataObject**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedataobject)來建立支援 [CFSTR \_ SHELLIDLIST](clipboard.md)格式的標準資料物件執行。</span><span class="sxs-lookup"><span data-stu-id="3ff38-149">Data sources can create a standard data object implementation that supports the [CFSTR\_SHELLIDLIST](clipboard.md) format by using [**SHCreateDataObject**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedataobject).</span></span>
-   <span data-ttu-id="3ff38-150">使用 shell 專案程式設計模型來放置要拖曳之專案的目標，可以使用 [**SHCreateShellItemArrayFromDataObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject)將 IDataObject 轉換成 [**IShellItemArray**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray) 。</span><span class="sxs-lookup"><span data-stu-id="3ff38-150">Drop targets that want to reason about the items being dragged using the shell item programming model can convert an IDataObject into an [**IShellItemArray**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray) using [**SHCreateShellItemArrayFromDataObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject).</span></span>
-   <span data-ttu-id="3ff38-151">使用標準的意見反應資料指標。</span><span class="sxs-lookup"><span data-stu-id="3ff38-151">Use standard feedback cursors.</span></span>
-   <span data-ttu-id="3ff38-152">支援向左和向右拖曳。</span><span class="sxs-lookup"><span data-stu-id="3ff38-152">Support left and right drag.</span></span>
-   <span data-ttu-id="3ff38-153">從内嵌物件使用資料物件本身。</span><span class="sxs-lookup"><span data-stu-id="3ff38-153">Use the data object itself from an embedded object.</span></span> <span data-ttu-id="3ff38-154">這種方法可讓您的應用程式取出資料物件提供的任何額外格式，並避免建立額外的內含專案層。</span><span class="sxs-lookup"><span data-stu-id="3ff38-154">This approach allows your application to retrieve any extra formats the data object has to offer and avoids creating an extra layer of containment.</span></span> <span data-ttu-id="3ff38-155">例如，來自伺服器 A 的内嵌物件會從伺服器/容器 B 拖曳出來，並放在容器 C 上。 C 應建立伺服器 A 的内嵌物件，而不是伺服器 B 的内嵌物件（包含伺服器 A 的内嵌物件）。</span><span class="sxs-lookup"><span data-stu-id="3ff38-155">For instance, an embedded object from server A is dragged from server/container B and dropped on container C. C should create an embedded object of server A, not an embedded object of server B containing an embedded object of server A.</span></span>
-   <span data-ttu-id="3ff38-156">請記住，Shell 可能會在移動檔案時使用 [優化移動](#handling-optimized-move-operations) 或 [刪除貼上](#handling-delete-on-paste-operations) 作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-156">Remember that the Shell might use [optimized moves](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operations when moving files.</span></span> <span data-ttu-id="3ff38-157">您的應用程式應該能夠辨識這些作業並適當地回應。</span><span class="sxs-lookup"><span data-stu-id="3ff38-157">Your application should be able to recognize these operations and respond appropriately.</span></span>

<span data-ttu-id="3ff38-158">針對資料目標：</span><span class="sxs-lookup"><span data-stu-id="3ff38-158">For data targets:</span></span>

-   <span data-ttu-id="3ff38-159">Shell 剪貼簿格式（除了 [CF \_ HDROP](clipboard.md)）不會預先定義。</span><span class="sxs-lookup"><span data-stu-id="3ff38-159">The Shell Clipboard formats, with the exception of [CF\_HDROP](clipboard.md), are not predefined.</span></span> <span data-ttu-id="3ff38-160">您要使用的每一種格式都必須透過呼叫 [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata)來註冊。</span><span class="sxs-lookup"><span data-stu-id="3ff38-160">Each format you want to use must be registered by calling [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span></span>
-   <span data-ttu-id="3ff38-161">執行並註冊 OLE 放置目標。</span><span class="sxs-lookup"><span data-stu-id="3ff38-161">Implement and register an OLE drop target.</span></span> <span data-ttu-id="3ff38-162">如果可能的話，請避免使用 Windows 3.1 目標或 [**WM \_ DROPFILES**](wm-dropfiles.md) 訊息。</span><span class="sxs-lookup"><span data-stu-id="3ff38-162">Avoid using Windows 3.1 targets or the [**WM\_DROPFILES**](wm-dropfiles.md) message, if possible.</span></span>
-   <span data-ttu-id="3ff38-163">資料物件所包含的格式會根據物件的來源而有所不同。</span><span class="sxs-lookup"><span data-stu-id="3ff38-163">The formats contained by a data object vary, depending on where the object comes from.</span></span> <span data-ttu-id="3ff38-164">因為您通常不事先知道資料物件的來源，所以不會假設會有特定的格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-164">Since you generally do not know in advance where a data object comes from, do not assume that a particular format will be present.</span></span> <span data-ttu-id="3ff38-165">資料物件應該以品質的順序來列舉格式，從最佳的開始。</span><span class="sxs-lookup"><span data-stu-id="3ff38-165">The data object should enumerate the formats in order of quality, starting with the best.</span></span> <span data-ttu-id="3ff38-166">因此，若要取得最佳的可用格式，應用程式通常會列舉可用的格式，並使用列舉中可支援的第一種格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-166">Thus, to get the best available format, applications normally enumerate the available formats and use the first format in the enumeration that they can support.</span></span>
-   <span data-ttu-id="3ff38-167">支援由右拖曳。</span><span class="sxs-lookup"><span data-stu-id="3ff38-167">Support right-drag.</span></span> <span data-ttu-id="3ff38-168">您可以藉由建立 [拖放處理常式](context-menu-handlers.md)來自訂拖曳快捷方式功能表。</span><span class="sxs-lookup"><span data-stu-id="3ff38-168">You can customize the drag shortcut menu by creating a [drag-and-drop handler](context-menu-handlers.md).</span></span>
-   <span data-ttu-id="3ff38-169">如果您的應用程式將接受現有的檔案，它必須能夠處理 [CF \_ HDROP](clipboard.md) 格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-169">If your application will accept existing files, it must be able to handle the [CF\_HDROP](clipboard.md) format.</span></span>
-   <span data-ttu-id="3ff38-170">一般情況下，接受檔案的應用程式也應該處理[CFSTR \_ FILECONTENTS](clipboard.md) / [CFSTR \_ FILEDESCRIPTOR](clipboard.md)格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-170">In general, applications that accept files should also handle the [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md) formats.</span></span> <span data-ttu-id="3ff38-171">雖然檔案系統的檔案具有[CF \_ HDROP](clipboard.md)格式，但命名空間延伸模組等提供者的檔案通常會使用[CFSTR \_ FILECONTENTS](clipboard.md) / [CFSTR \_ FILEDESCRIPTOR](clipboard.md)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-171">While files from the file system have the [CF\_HDROP](clipboard.md) format, files from providers such as namespace extensions generally use [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md).</span></span> <span data-ttu-id="3ff38-172">範例包括 Windows CE 資料夾、檔案傳輸通訊協定 (FTP) 資料夾、web 資料夾和 CAB 資料夾。</span><span class="sxs-lookup"><span data-stu-id="3ff38-172">Examples include Windows CE folders, File Transfer Protocol (FTP) folders, web folders, and CAB folders.</span></span> <span data-ttu-id="3ff38-173">來源通常會實執行 [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) 介面，以檔案形式呈現其儲存區中的資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-173">The source normally implements an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface to present data from its storage as a file.</span></span>
-   <span data-ttu-id="3ff38-174">請記住，Shell 可能會在移動檔案時使用 [優化移動](#handling-optimized-move-operations) 或 [刪除貼上](#handling-delete-on-paste-operations) 作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-174">Remember that the Shell might use [optimized moves](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operations when moving files.</span></span> <span data-ttu-id="3ff38-175">您的應用程式應該能夠辨識這些作業並適當地回應。</span><span class="sxs-lookup"><span data-stu-id="3ff38-175">Your application should be able to recognize these operations and respond appropriately.</span></span>

## <a name="copying-file-names-from-the-clipboard-to-an-application"></a><span data-ttu-id="3ff38-176">將檔案名稱從剪貼簿複製到應用程式</span><span class="sxs-lookup"><span data-stu-id="3ff38-176">Copying File Names from the Clipboard to an Application</span></span>

<span data-ttu-id="3ff38-177">**案例：** 使用者選取 Windows 檔案總管中的一或多個檔案，並將其複製到剪貼簿。</span><span class="sxs-lookup"><span data-stu-id="3ff38-177">**Scenario:** A user selects one or more files in Windows Explorer and copies them to the Clipboard.</span></span> <span data-ttu-id="3ff38-178">您的應用程式會解壓縮檔案名，並將其貼到檔中。</span><span class="sxs-lookup"><span data-stu-id="3ff38-178">Your application extracts the file names and pastes them into the document.</span></span>

<span data-ttu-id="3ff38-179">例如，您可以將檔案剪下並貼到您的應用程式中，以允許使用者建立 HTML 連結。</span><span class="sxs-lookup"><span data-stu-id="3ff38-179">This scenario could be used, for instance, to allow a user to create an HTML link by cutting and pasting the file to your application.</span></span> <span data-ttu-id="3ff38-180">然後，您的應用程式可以從資料物件中解壓縮檔案名稱，並加以處理以建立錨點標記。</span><span class="sxs-lookup"><span data-stu-id="3ff38-180">Your application can then extract the file name from the data object and process it to create an anchor tag.</span></span>

<span data-ttu-id="3ff38-181">當使用者選取 Windows 檔案總管中的檔案，並將它複製到剪貼簿時，Shell 會建立資料物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-181">When a user selects a file in Windows Explorer and copies it to the Clipboard, the Shell creates a data object.</span></span> <span data-ttu-id="3ff38-182">然後，它會呼叫 [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) ，將資料物件的 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 介面指標放到剪貼簿上。</span><span class="sxs-lookup"><span data-stu-id="3ff38-182">It then calls [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) to place a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface on the Clipboard.</span></span>

<span data-ttu-id="3ff38-183">當使用者從您的應用程式功能表或工具列中選取 [ **貼** 上] 命令時：</span><span class="sxs-lookup"><span data-stu-id="3ff38-183">When the user selects the **Paste** command from your application's menu or toolbar:</span></span>

1.  <span data-ttu-id="3ff38-184">呼叫 [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard) 以取得資料物件的 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 介面。</span><span class="sxs-lookup"><span data-stu-id="3ff38-184">Call [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard) to retrieve the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span>
2.  <span data-ttu-id="3ff38-185">呼叫 [**IDataObject：： EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) 來要求列舉值物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-185">Call [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) to request an enumerator object.</span></span>
3.  <span data-ttu-id="3ff38-186">使用列舉值物件的 [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) 介面來列舉資料物件所包含的格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-186">Use the enumerator object's [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) interface to enumerate the formats contained by the data object.</span></span>

> [!Note]  
> <span data-ttu-id="3ff38-187">這項程式中的最後兩個步驟是為了完整性而納入。</span><span class="sxs-lookup"><span data-stu-id="3ff38-187">The final two steps in this procedure are included for completeness.</span></span> <span data-ttu-id="3ff38-188">簡單的檔案傳輸通常不需要它們。</span><span class="sxs-lookup"><span data-stu-id="3ff38-188">They are typically not necessary for simple file transfers.</span></span> <span data-ttu-id="3ff38-189">這種資料傳輸類型所使用的所有資料物件，都應該包含 [CF \_ HDROP](clipboard.md) 格式，可用來判斷物件所包含的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="3ff38-189">All data objects used for this type of data transfer should contain the [CF\_HDROP](clipboard.md) format, which can be used to determine the names of the files contained by the object.</span></span> <span data-ttu-id="3ff38-190">不過，若要進行更一般的資料傳輸，您應該列舉格式，然後選取您的應用程式可以處理的最佳格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-190">However, for more general data transfers, you should enumerate the formats and select the best one that your application can handle.</span></span>

 

### <a name="extracting-the-file-names-from-the-data-object"></a><span data-ttu-id="3ff38-191">從資料物件中解壓縮檔案名稱</span><span class="sxs-lookup"><span data-stu-id="3ff38-191">Extracting the File Names from the Data Object</span></span>

<span data-ttu-id="3ff38-192">下一步是從資料物件中解壓縮一或多個檔案名，並將其貼到您的應用程式中。</span><span class="sxs-lookup"><span data-stu-id="3ff38-192">The next step is to extract one or more file names from the data object and paste them into your application.</span></span> <span data-ttu-id="3ff38-193">請注意，在本節中討論從資料物件解壓縮檔案名稱的程式同樣適用于拖放傳輸。</span><span class="sxs-lookup"><span data-stu-id="3ff38-193">Note that the procedure discussed in this section for extracting a file name from a data object applies equally well to drag-and-drop transfers.</span></span>

<span data-ttu-id="3ff38-194">從資料物件取出檔案名的最簡單方式是 [CF \_ HDROP](clipboard.md) 格式：</span><span class="sxs-lookup"><span data-stu-id="3ff38-194">The simplest way to retrieve file names from a data object is the [CF\_HDROP](clipboard.md) format:</span></span>

1.  <span data-ttu-id="3ff38-195">呼叫 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-195">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span></span> <span data-ttu-id="3ff38-196">將 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc)結構的 **cfFormat** 成員設定為 [CF \_ HDROP](clipboard.md) ，並將 **tymed** 成員設定為 [tymed \_ HGLOBAL](dataobject.md)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-196">Set the **cfFormat** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to [CF\_HDROP](clipboard.md) and the **tymed** member to [TYMED\_HGLOBAL](dataobject.md).</span></span> <span data-ttu-id="3ff38-197">**DwAspect** 成員通常會設定為 >dvaspect \_ 內容。</span><span class="sxs-lookup"><span data-stu-id="3ff38-197">The **dwAspect** member is normally set to DVASPECT\_CONTENT.</span></span> <span data-ttu-id="3ff38-198">但是，如果您需要以簡短的 (8.3) 格式來取得檔案的路徑，請將 **dwAspect** 設定為 >dvaspect \_ short。</span><span class="sxs-lookup"><span data-stu-id="3ff38-198">However, if you need to have the file's path in short (8.3) format, set **dwAspect** to DVASPECT\_SHORT.</span></span>

    <span data-ttu-id="3ff38-199">當 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) hGlobal 成員傳回時， [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構的成員會指向包含資料的全域記憶體物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-199">When [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns, the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure points to a global memory object that contains the data.</span></span>

2.  <span data-ttu-id="3ff38-200">建立 HDROP 變數，並將它設定為 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構的 **hGlobal** 成員。</span><span class="sxs-lookup"><span data-stu-id="3ff38-200">Create an HDROP variable and set it to the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="3ff38-201">HDROP 變數現在是 [**DROPFILES**](/windows/desktop/api/shlobj_core/ns-shlobj_core-dropfiles) 結構的控制碼，後面接著雙以 null 終止的字串，其中包含已複製檔案的完整檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="3ff38-201">The HDROP variable is now a handle to a [**DROPFILES**](/windows/desktop/api/shlobj_core/ns-shlobj_core-dropfiles) structure followed by a double null-terminated string containing the fully qualified file paths of the copied files.</span></span>
3.  <span data-ttu-id="3ff38-202">藉由呼叫 [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) ，並將 *iFile* 參數設定為0xffffffff，判斷清單中有多少個檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="3ff38-202">Determine how many file paths are in the list by calling [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) with the *iFile* parameter set to 0xFFFFFFFF.</span></span> <span data-ttu-id="3ff38-203">函數會傳回清單中的檔案路徑數目。</span><span class="sxs-lookup"><span data-stu-id="3ff38-203">The function returns the number of file paths in the list.</span></span> <span data-ttu-id="3ff38-204">在下一個步驟中，會使用此清單中以零為基底的檔案路徑來識別特定路徑。</span><span class="sxs-lookup"><span data-stu-id="3ff38-204">The file path's zero-based index in this list is used in the next step to identify a particular path.</span></span>
4.  <span data-ttu-id="3ff38-205">針對每個檔案呼叫 [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) 一次，將檔案路徑從全域記憶體物件中解壓縮，並將 *iFile* 設定為檔案的索引。</span><span class="sxs-lookup"><span data-stu-id="3ff38-205">Extract the file paths from the global memory object by calling [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) once for each file, with *iFile* set to the file's index.</span></span>
5.  <span data-ttu-id="3ff38-206">視需要處理檔案路徑，並將其貼入您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-206">Process the file paths as needed and paste them into your application.</span></span>
6.  <span data-ttu-id="3ff38-207">呼叫 [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) ，然後將指標傳遞至您在步驟1中傳遞給 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata)的 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構。</span><span class="sxs-lookup"><span data-stu-id="3ff38-207">Call [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) and pass in the pointer to the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that you passed to [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) in step 1.</span></span> <span data-ttu-id="3ff38-208">一旦您發行結構之後，您在步驟2中建立的 HDROP 值將不再有效，且不應該使用。</span><span class="sxs-lookup"><span data-stu-id="3ff38-208">Once you have released the structure, the HDROP value that you created in step 2 is no longer valid and should not be used.</span></span>

## <a name="copying-the-contents-of-a-dropped-file-into-an-application"></a><span data-ttu-id="3ff38-209">將已放置檔案的內容複寫到應用程式中</span><span class="sxs-lookup"><span data-stu-id="3ff38-209">Copying the Contents of a Dropped File into an Application</span></span>

<span data-ttu-id="3ff38-210">**案例：** 使用者從 Windows 檔案總管拖曳一或多個檔案，並將它們放在應用程式的視窗上。</span><span class="sxs-lookup"><span data-stu-id="3ff38-210">**Scenario:** A user drags one or more files from Windows Explorer and drops them on your application's window.</span></span> <span data-ttu-id="3ff38-211">您的應用程式會將檔案的內容解壓縮 (的) ，並將其貼入應用程式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-211">Your application extracts the content of the file (s) and pastes it into the application.</span></span>

<span data-ttu-id="3ff38-212">此案例使用拖放將檔案從 Windows 檔案總管傳送至應用程式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-212">This scenario uses drag-and-drop to transfer the files from Windows Explorer to the application.</span></span> <span data-ttu-id="3ff38-213">在操作之前，您的應用程式必須：</span><span class="sxs-lookup"><span data-stu-id="3ff38-213">Prior to the operation, your application must:</span></span>

1.  <span data-ttu-id="3ff38-214">呼叫 [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) 以註冊任何需要的 Shell 剪貼簿格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-214">Call [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) to register any needed Shell Clipboard formats.</span></span>
2.  <span data-ttu-id="3ff38-215">呼叫 [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) 以註冊目標視窗和您應用程式的 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 介面。</span><span class="sxs-lookup"><span data-stu-id="3ff38-215">Call [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) to register a target window and your application's [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span>

<span data-ttu-id="3ff38-216">使用者啟動作業之後，請選取一或多個檔案，然後開始拖曳：</span><span class="sxs-lookup"><span data-stu-id="3ff38-216">After the user initiates the operation by selecting one or more files and starting to drag them:</span></span>

1.  <span data-ttu-id="3ff38-217">Windows 檔案總管會建立資料物件，並將支援的格式載入其中。</span><span class="sxs-lookup"><span data-stu-id="3ff38-217">Windows Explorer creates a data object and loads the supported formats into it.</span></span>
2.  <span data-ttu-id="3ff38-218">Windows 檔案總管會呼叫 [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) 來起始拖曳迴圈。</span><span class="sxs-lookup"><span data-stu-id="3ff38-218">Windows Explorer calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) to initiate the drag loop.</span></span>
3.  <span data-ttu-id="3ff38-219">當拖曳影像到達您的目標視窗時，系統會呼叫 [**IDropTarget：:D ragenter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter)來通知您。</span><span class="sxs-lookup"><span data-stu-id="3ff38-219">When the drag image reaches your target window, the system notifies you by calling [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span></span>
4.  <span data-ttu-id="3ff38-220">若要判斷資料物件包含的內容，請呼叫資料物件的 [**IDataObject：： EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) 方法。</span><span class="sxs-lookup"><span data-stu-id="3ff38-220">To determine what the data object contains, call the data object's [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) method.</span></span> <span data-ttu-id="3ff38-221">使用方法所傳回的列舉值物件來列舉資料物件所包含的格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-221">Use the enumerator object returned by the method to enumerate the formats contained by the data object.</span></span> <span data-ttu-id="3ff38-222">如果您的應用程式不想接受其中任何一種格式，則傳回 DROPEFFECT \_ NONE。</span><span class="sxs-lookup"><span data-stu-id="3ff38-222">If your application does not want to accept any of these formats, return DROPEFFECT\_NONE.</span></span> <span data-ttu-id="3ff38-223">基於此案例的目的，您的應用程式應該忽略任何不包含用來傳輸檔案之格式的資料物件，例如 [CF \_ HDROP](clipboard.md)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-223">For the purposes of this scenario, your application should ignore any data objects that do not contain formats used to transfer files, such as [CF\_HDROP](clipboard.md).</span></span>
5.  <span data-ttu-id="3ff38-224">當使用者拖放資料時，系統會呼叫 [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-224">When the user drops the data, the system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop).</span></span>
6.  <span data-ttu-id="3ff38-225">使用 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 介面解壓縮檔案的內容。</span><span class="sxs-lookup"><span data-stu-id="3ff38-225">Use the [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface to extract the contents of the files.</span></span>

<span data-ttu-id="3ff38-226">有幾種不同的方式可從資料物件解壓縮 Shell 物件的內容。</span><span class="sxs-lookup"><span data-stu-id="3ff38-226">There are several different ways to extract the contents of a Shell object from a data object.</span></span> <span data-ttu-id="3ff38-227">一般情況下，請使用下列順序：</span><span class="sxs-lookup"><span data-stu-id="3ff38-227">In general, use the following order:</span></span>

-   <span data-ttu-id="3ff38-228">如果檔案包含 [CF \_ 文字](clipboard.md) 格式，則資料是 ANSI 文字。</span><span class="sxs-lookup"><span data-stu-id="3ff38-228">If the file contains a [CF\_TEXT](clipboard.md) format, the data is ANSI text.</span></span> <span data-ttu-id="3ff38-229">您可以使用 CF \_ 文字格式來解壓縮資料，而不是開啟檔案本身。</span><span class="sxs-lookup"><span data-stu-id="3ff38-229">You can use the CF\_TEXT format to extract the data, rather than opening the file itself.</span></span>
-   <span data-ttu-id="3ff38-230">如果檔案包含連結或內嵌的 OLE 物件，資料物件會包含 CF \_ EMBEDDEDOBJECT 格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-230">If the file contains a linked or embedded OLE object, the data object contains a CF\_EMBEDDEDOBJECT format.</span></span> <span data-ttu-id="3ff38-231">使用標準的 OLE 技術來將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-231">Use standard OLE techniques to extract the data.</span></span> <span data-ttu-id="3ff38-232">[廢料](#creating-and-importing-scrap-files) 檔案一律包含 CF \_ EMBEDDEDOBJECT 格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-232">[Scrap files](#creating-and-importing-scrap-files) always contain a CF\_EMBEDDEDOBJECT format.</span></span>
-   <span data-ttu-id="3ff38-233">如果 Shell 物件來自檔案系統，資料物件會包含 [CF \_ HDROP](clipboard.md) 格式以及檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="3ff38-233">If the Shell object is from the file system, the data object contains a [CF\_HDROP](clipboard.md) format with the names of the files.</span></span> <span data-ttu-id="3ff38-234">從 [CF \_ HDROP](clipboard.md) 中解壓縮檔案名稱，並呼叫 [**OleCreateFromFile**](/windows/win32/api/ole2/nf-ole2-olecreatefromfile) 以建立新的連結或內嵌的物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-234">Extract the file name from [CF\_HDROP](clipboard.md) and call [**OleCreateFromFile**](/windows/win32/api/ole2/nf-ole2-olecreatefromfile) to create a new linked or embedded object.</span></span> <span data-ttu-id="3ff38-235">如需如何從 [CF \_ HDROP](clipboard.md) 格式取得檔案名的討論，請參閱 [將檔案名從剪貼簿複製到應用程式](#copying-file-names-from-the-clipboard-to-an-application)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-235">For a discussion of how to retrieve a file name from a [CF\_HDROP](clipboard.md) format, see [Copying File Names from the Clipboard to an Application](#copying-file-names-from-the-clipboard-to-an-application).</span></span>
-   <span data-ttu-id="3ff38-236">如果資料物件包含 [CFSTR \_ FILEDESCRIPTOR](clipboard.md) 格式，您可以從檔案的 [CFSTR \_ FILECONTENTS](clipboard.md) 格式解壓縮檔案的內容。</span><span class="sxs-lookup"><span data-stu-id="3ff38-236">If the data object contains a [CFSTR\_FILEDESCRIPTOR](clipboard.md) format, you can extract a file's contents from the file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="3ff38-237">如需此程式的討論，請參閱 [使用 CFSTR \_ FILECONTENTS 格式將資料從檔案解壓縮](/windows)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-237">For a discussion of this procedure, see [Using the CFSTR\_FILECONTENTS Format to Extract Data from a File](/windows).</span></span>
-   <span data-ttu-id="3ff38-238">在 Shell [版本 4.71](versions.md)之前，應用程式會藉由在 [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora)結構的 **dwFlags** 成員中設定 **FD \_ LINKUI** ，來指出它正在傳送快捷方式檔案類型。</span><span class="sxs-lookup"><span data-stu-id="3ff38-238">Prior to Shell [version 4.71](versions.md), an application indicated that it was transferring a shortcut file type by setting **FD\_LINKUI** in the **dwFlags** member of the [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structure.</span></span> <span data-ttu-id="3ff38-239">針對較新版本的 Shell，表示要傳送快捷方式的慣用方式是使用 [ [CFSTR \_ PREFERREDDROPEFFECT](clipboard.md) 格式] 設定為 [DROPEFFECT] \_ 連結。</span><span class="sxs-lookup"><span data-stu-id="3ff38-239">For later versions of the Shell, the preferred way to indicate that shortcuts are being transferred is to use the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_LINK.</span></span> <span data-ttu-id="3ff38-240">這種方法比只為了檢查旗標而解壓縮 **FILEDESCRIPTOR** 結構更有效率。</span><span class="sxs-lookup"><span data-stu-id="3ff38-240">This approach is much more efficient than extracting the **FILEDESCRIPTOR** structure just to check a flag.</span></span>

<span data-ttu-id="3ff38-241">如果資料解壓縮程式很長，您可能會想要以非同步方式在背景執行緒上進行作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-241">If the data extraction process will be lengthy, you might want to do the operation asynchronously on a background thread.</span></span> <span data-ttu-id="3ff38-242">然後，您的主要執行緒就可以繼續進行，不需要延遲。</span><span class="sxs-lookup"><span data-stu-id="3ff38-242">Your primary thread can then proceed without unnecessary delays.</span></span> <span data-ttu-id="3ff38-243">如需如何處理非同步資料解壓縮的討論，請參閱 [非同步地拖放 Shell 物件](#dragging-and-dropping-shell-objects-asynchronously)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-243">For a discussion of how to handle asynchronous data extraction, see [Dragging and Dropping Shell Objects Asynchronously](#dragging-and-dropping-shell-objects-asynchronously).</span></span>

### <a name="using-the-cfstr_filecontents-format-to-extract-data-from-a-file"></a><span data-ttu-id="3ff38-244">使用 CFSTR \_ FILECONTENTS 格式將檔案中的資料解壓縮</span><span class="sxs-lookup"><span data-stu-id="3ff38-244">Using the CFSTR\_FILECONTENTS Format to Extract Data from a File</span></span>

<span data-ttu-id="3ff38-245">[CFSTR \_ FILECONTENTS](clipboard.md)格式提供極具彈性且功能強大的方式來傳送檔案的內容。</span><span class="sxs-lookup"><span data-stu-id="3ff38-245">The [CFSTR\_FILECONTENTS](clipboard.md) format provides a very flexible and powerful way to transfer the contents of a file.</span></span> <span data-ttu-id="3ff38-246">您甚至不需要將資料儲存為單一檔案。</span><span class="sxs-lookup"><span data-stu-id="3ff38-246">It is not even necessary for the data to be stored as a single file.</span></span> <span data-ttu-id="3ff38-247">這種格式所需的全部都是資料物件將資料呈現至目標，就像是檔案一樣。</span><span class="sxs-lookup"><span data-stu-id="3ff38-247">All that is required for this format is that the data object present the data to the target as if it were a file.</span></span> <span data-ttu-id="3ff38-248">例如，實際的資料可能是文字檔的區段，或是從資料庫解壓縮的資料區塊。</span><span class="sxs-lookup"><span data-stu-id="3ff38-248">For instance, the actual data might be a section of a text document or a block of data extracted from a database.</span></span> <span data-ttu-id="3ff38-249">目標可以將資料視為檔案，而且不需要知道基礎儲存機制的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="3ff38-249">The target can treat the data as a file and does not need to know anything about the underlying storage mechanism.</span></span>

<span data-ttu-id="3ff38-250">命名空間延伸模組通常會使用 [CFSTR \_ FILECONTENTS](clipboard.md) 來傳送資料，因為此格式不會採用任何特定的儲存機制。</span><span class="sxs-lookup"><span data-stu-id="3ff38-250">Namespace extensions normally use [CFSTR\_FILECONTENTS](clipboard.md) to transfer data because this format does not assume any particular storage mechanism.</span></span> <span data-ttu-id="3ff38-251">命名空間延伸可以使用任何便利的儲存機制，並使用此格式將其物件呈現給應用程式，就好像它們是檔案一樣。</span><span class="sxs-lookup"><span data-stu-id="3ff38-251">A namespace extension can use whatever storage mechanism is convenient, and use this format to present its objects to applications as if they were files.</span></span>

<span data-ttu-id="3ff38-252">[CFSTR \_ FILECONTENTS](clipboard.md)的資料傳輸機制通常是[TYMED \_ ISTREAM](dataobject.md)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-252">The data transfer mechanism for [CFSTR\_FILECONTENTS](clipboard.md) is normally [TYMED\_ISTREAM](dataobject.md).</span></span> <span data-ttu-id="3ff38-253">傳輸 [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) 介面指標所需的記憶體比將資料載入至全域記憶體物件的記憶體少得多，而且 **IStream** 是表示資料比 [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage)更簡單的方法。</span><span class="sxs-lookup"><span data-stu-id="3ff38-253">Transferring an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface pointer requires much less memory than loading the data into a global memory object, and **IStream** is a simpler way to represent data than [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span></span>

<span data-ttu-id="3ff38-254">[CFSTR \_ FILECONTENTS](clipboard.md)格式一律會伴隨[CFSTR \_ FILEDESCRIPTOR](clipboard.md)格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-254">A [CFSTR\_FILECONTENTS](clipboard.md) format is always accompanied by a [CFSTR\_FILEDESCRIPTOR](clipboard.md) format.</span></span> <span data-ttu-id="3ff38-255">您必須先檢查此格式的內容。</span><span class="sxs-lookup"><span data-stu-id="3ff38-255">You must examine the contents of this format first.</span></span> <span data-ttu-id="3ff38-256">如果正在傳送多個檔案，資料物件實際上會包含多個 [CFSTR \_ FILECONTENTS](clipboard.md) 格式，每個檔案各有一個格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-256">If more than one file is being transferred, the data object will actually contain multiple [CFSTR\_FILECONTENTS](clipboard.md) formats, one for each file.</span></span> <span data-ttu-id="3ff38-257">[CFSTR \_ FILEDESCRIPTOR](clipboard.md)格式包含每個檔案的名稱和屬性，並提供解壓縮特定檔案的[CFSTR \_ FILECONTENTS](clipboard.md)格式所需的每個檔案的索引值。</span><span class="sxs-lookup"><span data-stu-id="3ff38-257">The [CFSTR\_FILEDESCRIPTOR](clipboard.md) format contains the name and attributes of each file, and provides an index value for each file that is needed to extract a particular file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span>

<span data-ttu-id="3ff38-258">若要將 [CFSTR \_ FILECONTENTS](clipboard.md) 格式解壓縮：</span><span class="sxs-lookup"><span data-stu-id="3ff38-258">To extract a [CFSTR\_FILECONTENTS](clipboard.md) format:</span></span>

1.  <span data-ttu-id="3ff38-259">將 [CFSTR \_ FILEDESCRIPTOR](clipboard.md) 格式解壓縮為 [TYMED \_ HGLOBAL](dataobject.md) 值。</span><span class="sxs-lookup"><span data-stu-id="3ff38-259">Extract the [CFSTR\_FILEDESCRIPTOR](clipboard.md) format as a [TYMED\_HGLOBAL](dataobject.md) value.</span></span>
2.  <span data-ttu-id="3ff38-260">傳回之 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構的 **hGlobal** 成員會指向全域記憶體物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-260">The **hGlobal** member of the returned [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure points to a global memory object.</span></span> <span data-ttu-id="3ff38-261">藉由將 **hGlobal** 值傳遞給 [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock)來鎖定該物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-261">Lock that object by passing the **hGlobal** value to [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock).</span></span>
3.  <span data-ttu-id="3ff38-262">將 [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) 傳回的指標轉換為 [**FILEGROUPDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filegroupdescriptora) 指標。</span><span class="sxs-lookup"><span data-stu-id="3ff38-262">Cast the pointer returned by [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) to a [**FILEGROUPDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filegroupdescriptora) pointer.</span></span> <span data-ttu-id="3ff38-263">它會指向 **FILEGROUPDESCRIPTOR** 結構，後面接著一或多個 [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) 結構。</span><span class="sxs-lookup"><span data-stu-id="3ff38-263">It will point to a **FILEGROUPDESCRIPTOR** structure followed by one or more [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structures.</span></span> <span data-ttu-id="3ff38-264">每個 **FILEDESCRIPTOR** 結構都包含一個隨附的 [CFSTR \_ FILECONTENTS](clipboard.md) 格式所包含的檔案描述。</span><span class="sxs-lookup"><span data-stu-id="3ff38-264">Each **FILEDESCRIPTOR** structure contains a description of a file that is contained by one of the accompanying [CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span>
4.  <span data-ttu-id="3ff38-265">檢查 [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) 結構，以判斷哪一個對應至您要解壓縮的檔案。</span><span class="sxs-lookup"><span data-stu-id="3ff38-265">Examine the [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structures to determine which one corresponds to the file you want to extract.</span></span> <span data-ttu-id="3ff38-266">該 **FILEDESCRIPTOR** 結構以零為起始的索引，用來識別檔案的 [CFSTR \_ FILECONTENTS](clipboard.md) 格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-266">The zero-based index of that **FILEDESCRIPTOR** structure is used to identify the file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="3ff38-267">因為全域記憶體區塊的大小不是位元組精確的，所以請使用結構的 **nFileSizeLow** 和 **nFileSizeHigh** 成員來判斷全域記憶體物件中代表檔案的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="3ff38-267">Because the size of a global memory block is not byte-precise, use the structure's **nFileSizeLow** and **nFileSizeHigh** members to determine how many bytes represent the file in the global memory object.</span></span>
5.  <span data-ttu-id="3ff38-268">呼叫 [**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) ，並將 [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc)結構的 **cfFormat** 成員設為 [CFSTR \_ FILECONTENTS](clipboard.md)值，並將 **lIndex** 成員設定為您在上一個步驟中決定的索引。</span><span class="sxs-lookup"><span data-stu-id="3ff38-268">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) with the **cfFormat** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure set to the [CFSTR\_FILECONTENTS](clipboard.md) value and the **lIndex** member set to the index that you determined in the previous step.</span></span> <span data-ttu-id="3ff38-269">**Tymed** 成員通常會設定為 [tymed \_ HGLOBAL](dataobject.md) \| tymed \_ ISTREAM \| tymed \_ ISTORAGE。</span><span class="sxs-lookup"><span data-stu-id="3ff38-269">The **tymed** member is typically set to [TYMED\_HGLOBAL](dataobject.md) \| TYMED\_ISTREAM \| TYMED\_ISTORAGE.</span></span> <span data-ttu-id="3ff38-270">然後，資料物件可以選擇其慣用的資料傳輸機制。</span><span class="sxs-lookup"><span data-stu-id="3ff38-270">The data object can then choose its preferred data transfer mechanism.</span></span>
6.  <span data-ttu-id="3ff38-271">[**IDataObject：：**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata)硬碟傳回的 [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1)結構將包含檔案資料的指標。</span><span class="sxs-lookup"><span data-stu-id="3ff38-271">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns will contain a pointer to the file's data.</span></span> <span data-ttu-id="3ff38-272">檢查結構的 **tymed** 成員，以決定資料傳輸機制。</span><span class="sxs-lookup"><span data-stu-id="3ff38-272">Examine the **tymed** member of the structure to determine the data transfer mechanism.</span></span>
7.  <span data-ttu-id="3ff38-273">如果 **tymed** 設定為 [TYMED \_ ISTREAM](dataobject.md) 或 tymed \_ ISTORAGE，請使用介面來將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-273">If **tymed** is set to [TYMED\_ISTREAM](dataobject.md) or TYMED\_ISTORAGE, use the interface to extract the data.</span></span> <span data-ttu-id="3ff38-274">如果 **tymed** 設定為 tymed \_ HGLOBAL，資料就會包含在全域記憶體物件中。</span><span class="sxs-lookup"><span data-stu-id="3ff38-274">If **tymed** is set to TYMED\_HGLOBAL, the data is contained in a global memory object.</span></span> <span data-ttu-id="3ff38-275">如需如何從全域記憶體物件中解壓縮資料的討論，請參閱從 [Shell 資料物件](dataobject.md)的 *資料物件區段解壓縮全域記憶體物件*。</span><span class="sxs-lookup"><span data-stu-id="3ff38-275">For a discussion of how to extract data from a global memory object, see the *Extracting a global memory object from a data object* section of [Shell Data Object](dataobject.md).</span></span>
8.  <span data-ttu-id="3ff38-276">呼叫 [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) 來解除鎖定您在步驟2中鎖定的全域記憶體物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-276">Call [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) to unlock the global memory object that you locked in step 2.</span></span>

## <a name="handling-optimized-move-operations"></a><span data-ttu-id="3ff38-277">處理優化的移動作業</span><span class="sxs-lookup"><span data-stu-id="3ff38-277">Handling Optimized Move Operations</span></span>

<span data-ttu-id="3ff38-278">**案例：** 使用優化的移動，將檔案從檔案系統移至命名空間延伸模組。</span><span class="sxs-lookup"><span data-stu-id="3ff38-278">**Scenario:** A file is moved from the file system to a namespace extension using an optimized move.</span></span>

<span data-ttu-id="3ff38-279">在傳統移動作業中，目標會建立資料的複本，而來源會刪除原始的。</span><span class="sxs-lookup"><span data-stu-id="3ff38-279">In a conventional move operation, the target makes a copy of the data and the source deletes the original.</span></span> <span data-ttu-id="3ff38-280">此程式可能沒有效率，因為它需要兩個數據複本。</span><span class="sxs-lookup"><span data-stu-id="3ff38-280">This procedure can be inefficient because it requires two copies of the data.</span></span> <span data-ttu-id="3ff38-281">使用大型物件（例如資料庫）時，傳統的移動作業可能無法實際運作。</span><span class="sxs-lookup"><span data-stu-id="3ff38-281">With large objects such as databases, a conventional move operation might not even be practical.</span></span>

<span data-ttu-id="3ff38-282">藉由優化的移動，目標會使用其對資料儲存方式的瞭解，以處理整個移動作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-282">With an optimized move, the target uses its understanding of how the data is stored to handle the entire move operation.</span></span> <span data-ttu-id="3ff38-283">資料永遠不會有第二個複本，也不需要來源刪除原始資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-283">There is never a second copy of the data, and there is no need for the source to delete the original data.</span></span> <span data-ttu-id="3ff38-284">Shell 資料很適合用於優化移動，因為目標可以使用 Shell API 來處理整個作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-284">Shell data is well suited to optimized moves because the target can handle the entire operation using the Shell API.</span></span> <span data-ttu-id="3ff38-285">移動檔案的一般範例。</span><span class="sxs-lookup"><span data-stu-id="3ff38-285">A typical example is moving files.</span></span> <span data-ttu-id="3ff38-286">一旦目標具有要移動之檔案的路徑，它就可以使用 [**SHFileOperation**](/windows/desktop/api/Shellapi/nf-shellapi-shfileoperationa) 來移動它。</span><span class="sxs-lookup"><span data-stu-id="3ff38-286">Once the target has the path of a file to be moved, it can use [**SHFileOperation**](/windows/desktop/api/Shellapi/nf-shellapi-shfileoperationa) to move it.</span></span> <span data-ttu-id="3ff38-287">來源不需要刪除原始檔案。</span><span class="sxs-lookup"><span data-stu-id="3ff38-287">There is no need for the source to delete the original file.</span></span>

> [!Note]  
> <span data-ttu-id="3ff38-288">Shell 通常會使用優化的移動來移動檔案。</span><span class="sxs-lookup"><span data-stu-id="3ff38-288">The Shell normally uses an optimized move to move files.</span></span> <span data-ttu-id="3ff38-289">若要適當地處理 Shell 資料傳輸，您的應用程式必須能夠偵測和處理優化的移動。</span><span class="sxs-lookup"><span data-stu-id="3ff38-289">To handle Shell data transfer properly, your application must be capable of detecting and handling an optimized move.</span></span>

 

<span data-ttu-id="3ff38-290">優化的移動會以下列方式處理：</span><span class="sxs-lookup"><span data-stu-id="3ff38-290">Optimized moves are handled in the following way:</span></span>

1.  <span data-ttu-id="3ff38-291">來源會呼叫 [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) ，並將 *dwEffect* 參數設定為 DROPEFFECT \_ MOVE，以表示可以移動來源物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-291">The source calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) with the *dwEffect* parameter set to DROPEFFECT\_MOVE to indicate that the source objects can be moved.</span></span>
2.  <span data-ttu-id="3ff38-292">目標 \_ 會透過其 [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 方法的其中一個來接收 DROPEFFECT 移動值，表示允許移動。</span><span class="sxs-lookup"><span data-stu-id="3ff38-292">The target receives the DROPEFFECT\_MOVE value through one of its [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) methods, indicating that a move is allowed.</span></span>
3.  <span data-ttu-id="3ff38-293">目標是複製物件 (未優化的移動) 或移動物件 (優化的移動) 。</span><span class="sxs-lookup"><span data-stu-id="3ff38-293">The target either copies the object (unoptimized move) or moves the object (optimized move).</span></span>
4.  <span data-ttu-id="3ff38-294">然後，目標會告知來源是否需要刪除原始資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-294">The target then tells the source whether it needs to delete the original data.</span></span>

    <span data-ttu-id="3ff38-295">優化的移動是預設作業，並由目標刪除資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-295">An optimized move is the default operation, with the data deleted by the target.</span></span> <span data-ttu-id="3ff38-296">若要通知來源已執行優化的移動：</span><span class="sxs-lookup"><span data-stu-id="3ff38-296">To inform the source that an optimized move was performed:</span></span>

    -   -   <span data-ttu-id="3ff38-297">目標會將它透過其 [**:D IDropTarget**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop)所收到的 *pdwEffect* 值設定為 DROPEFFECT MOVE 以外的某個值 \_ 。</span><span class="sxs-lookup"><span data-stu-id="3ff38-297">The target sets the *pdwEffect* value it received through its [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to some value other than DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="3ff38-298">它通常會設定為 DROPEFFECT \_ NONE 或 DROPEFFECT \_ COPY。</span><span class="sxs-lookup"><span data-stu-id="3ff38-298">It is typically set to either DROPEFFECT\_NONE or DROPEFFECT\_COPY.</span></span> <span data-ttu-id="3ff38-299">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop)會將值傳回到來源。</span><span class="sxs-lookup"><span data-stu-id="3ff38-299">The value will be returned to the source by [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span>
        -   <span data-ttu-id="3ff38-300">目標也會呼叫資料物件的 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 方法，並將 [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) 格式識別碼設定為 DROPEFFECT \_ NONE。</span><span class="sxs-lookup"><span data-stu-id="3ff38-300">The target also calls the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method and passes it a [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format identifier set to DROPEFFECT\_NONE.</span></span> <span data-ttu-id="3ff38-301">這個方法呼叫是必要的，因為某些卸載目標可能不會正確地設定 [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop)的 *pdwEffect* 參數。</span><span class="sxs-lookup"><span data-stu-id="3ff38-301">This method call is necessary because some drop targets might not set the *pdwEffect* parameter of [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) properly.</span></span> <span data-ttu-id="3ff38-302">[CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md)格式是用來表示已進行優化移動的可靠方式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-302">The [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format is the reliable way to indicate that an optimized move has taken place.</span></span>

    <span data-ttu-id="3ff38-303">如果目標執行未優化的移動，則必須由來源刪除資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-303">If the target did an unoptimized move, the data must be deleted by the source.</span></span> <span data-ttu-id="3ff38-304">若要通知來源已執行未優化的移動：</span><span class="sxs-lookup"><span data-stu-id="3ff38-304">To inform the source that an unoptimized move was performed:</span></span>

    -   -   <span data-ttu-id="3ff38-305">目標會將它透過其 [**:D IDropTarget**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop)所收到的 *pdwEffect* 值設定為 DROPEFFECT \_ 移動。</span><span class="sxs-lookup"><span data-stu-id="3ff38-305">The target sets the *pdwEffect* value it received through its [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="3ff38-306">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop)會將值傳回到來源。</span><span class="sxs-lookup"><span data-stu-id="3ff38-306">The value will be returned to the source by [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span>
        -   <span data-ttu-id="3ff38-307">目標也會呼叫資料物件的 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 方法，並將 [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) 格式識別碼設定為 DROPEFFECT \_ MOVE。</span><span class="sxs-lookup"><span data-stu-id="3ff38-307">The target also calls the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method and passes it a [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format identifier set to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="3ff38-308">這個方法呼叫是必要的，因為某些卸載目標可能不會正確地設定 [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop)的 *pdwEffect* 參數。</span><span class="sxs-lookup"><span data-stu-id="3ff38-308">This method call is necessary because some drop targets might not set the *pdwEffect* parameter of [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) properly.</span></span> <span data-ttu-id="3ff38-309">[CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md)格式是表示已進行未優化移動的可靠方式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-309">The [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format is the reliable way to indicate that an unoptimized move has taken place.</span></span>

5.  <span data-ttu-id="3ff38-310">來源會檢查目標所能傳回的兩個值。</span><span class="sxs-lookup"><span data-stu-id="3ff38-310">The source inspects the two values that can be returned by the target.</span></span> <span data-ttu-id="3ff38-311">如果兩者都設定為 DROPEFFECT \_ move，則會藉由刪除原始資料來完成未優化的移動。</span><span class="sxs-lookup"><span data-stu-id="3ff38-311">If both are set to DROPEFFECT\_MOVE, it completes the unoptimized move by deleting the original data.</span></span> <span data-ttu-id="3ff38-312">否則，目標會進行優化的移動，並刪除原始資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-312">Otherwise, the target did an optimized move and the original data has been deleted.</span></span>

## <a name="handling-delete-on-paste-operations"></a><span data-ttu-id="3ff38-313">處理刪除作業-貼上作業</span><span class="sxs-lookup"><span data-stu-id="3ff38-313">Handling Delete-on-Paste Operations</span></span>

<span data-ttu-id="3ff38-314">**案例：** 從 Windows 檔案總管中的資料夾剪下一或多個檔案，並貼到命名空間延伸模組中。</span><span class="sxs-lookup"><span data-stu-id="3ff38-314">**Scenario:** One or more files are cut from a folder in Windows Explorer and pasted into a namespace extension.</span></span> <span data-ttu-id="3ff38-315">Windows 檔案總管會將檔案保留在反白顯示，直到其收到貼上作業結果的意見反應為止。</span><span class="sxs-lookup"><span data-stu-id="3ff38-315">Windows Explorer leaves the files highlighted until it receives feedback on the outcome of the paste operation.</span></span>

<span data-ttu-id="3ff38-316">傳統上，當使用者剪下資料時，它會立即從 view 中消失。</span><span class="sxs-lookup"><span data-stu-id="3ff38-316">Traditionally, when a user cuts data it immediately disappears from view.</span></span> <span data-ttu-id="3ff38-317">這可能不會很有效率，而且如果使用者對資料所做的事很在意，可能會導致可用性問題。</span><span class="sxs-lookup"><span data-stu-id="3ff38-317">This might not be efficient, and it can lead to usability problems if the user becomes concerned about what has happened to the data.</span></span> <span data-ttu-id="3ff38-318">替代方法是使用「刪除時貼上」作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-318">An alternative approach is to use a delete-on-paste operation.</span></span>

<span data-ttu-id="3ff38-319">使用「刪除時複製」作業時，不會立即從 view 中移除選取的資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-319">With a delete-on-paste operation, the selected data is not immediately removed from view.</span></span> <span data-ttu-id="3ff38-320">相反地，來源應用程式會將它標示為已選取，或許是藉由變更字型或背景色彩。</span><span class="sxs-lookup"><span data-stu-id="3ff38-320">Instead, the source application marks it as selected, perhaps by changing the font or background color.</span></span> <span data-ttu-id="3ff38-321">目標應用程式貼上資料之後，會通知來源有關作業的結果。</span><span class="sxs-lookup"><span data-stu-id="3ff38-321">After the target application has pasted the data, it notifies the source about the outcome of the operation.</span></span> <span data-ttu-id="3ff38-322">如果目標執行了 [優化的移動](#handling-optimized-move-operations)，則來源可以直接更新其顯示。</span><span class="sxs-lookup"><span data-stu-id="3ff38-322">If the target performed an [optimized move](#handling-optimized-move-operations), the source can simply update its display.</span></span> <span data-ttu-id="3ff38-323">如果目標執行的是一般的移動，則來源也必須刪除其資料複本。</span><span class="sxs-lookup"><span data-stu-id="3ff38-323">If the target performed a normal move, the source must also delete its copy of the data.</span></span> <span data-ttu-id="3ff38-324">如果貼上失敗，來源應用程式會將選取的資料還原為其原始外觀。</span><span class="sxs-lookup"><span data-stu-id="3ff38-324">If the paste fails, the source application restores the selected data to its original appearance.</span></span>

> [!Note]  
> <span data-ttu-id="3ff38-325">當使用剪下/貼上作業來移動檔案時，Shell 通常會使用「刪除時貼上」。</span><span class="sxs-lookup"><span data-stu-id="3ff38-325">The Shell normally uses delete-on-paste when a cut/paste operation is used to move files.</span></span> <span data-ttu-id="3ff38-326">使用 Shell 物件的刪除開啟貼上作業通常會使用 [優化的移動](#handling-optimized-move-operations) 來移動檔案。</span><span class="sxs-lookup"><span data-stu-id="3ff38-326">Delete-on-paste operations with Shell objects normally use an [optimized move](#handling-optimized-move-operations) to move the files.</span></span> <span data-ttu-id="3ff38-327">若要適當地處理 Shell 資料傳輸，您的應用程式必須能夠偵測和處理刪除貼上作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-327">To handle Shell data transfer properly, your application must be capable of detecting and handling delete-on-paste operations.</span></span>

 

<span data-ttu-id="3ff38-328">「刪除時刪除」的基本需求是目標必須向來源報告作業的結果。</span><span class="sxs-lookup"><span data-stu-id="3ff38-328">The essential requirement for delete-on-paste is that the target must report the outcome of the operation to the source.</span></span> <span data-ttu-id="3ff38-329">不過，標準剪貼簿技術無法用來執行「刪除時貼上」，因為它們無法提供目標與來源進行通訊的方式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-329">However, standard Clipboard techniques cannot be used to implement delete-on-paste because they do not provide a way for the target to communicate with the source.</span></span> <span data-ttu-id="3ff38-330">相反地，目標應用程式會使用資料物件的 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 方法將結果報告給資料物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-330">Instead, the target application uses the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method to report the outcome to the data object.</span></span> <span data-ttu-id="3ff38-331">然後，資料物件可以透過私用介面與來源進行通訊。</span><span class="sxs-lookup"><span data-stu-id="3ff38-331">The data object can then communicate with the source through a private interface.</span></span>

<span data-ttu-id="3ff38-332">刪除貼上操作的基本程式如下：</span><span class="sxs-lookup"><span data-stu-id="3ff38-332">The basic procedure for a delete-on-paste operation is as follows:</span></span>

1.  <span data-ttu-id="3ff38-333">來源會標示所選取資料的螢幕顯示。</span><span class="sxs-lookup"><span data-stu-id="3ff38-333">The source marks the screen display of the selected data.</span></span>
2.  <span data-ttu-id="3ff38-334">來源會建立資料物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-334">The source creates a data object.</span></span> <span data-ttu-id="3ff38-335">它會藉由新增 [CFSTR \_ PREFERREDDROPEFFECT](clipboard.md) 格式和 DROPEFFECT MOVE 的資料值，來指出剪下作業 \_ 。</span><span class="sxs-lookup"><span data-stu-id="3ff38-335">It indicates a cut operation by adding the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) format with a data value of DROPEFFECT\_MOVE.</span></span>
3.  <span data-ttu-id="3ff38-336">來源會使用 [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard)將資料物件放在剪貼簿上。</span><span class="sxs-lookup"><span data-stu-id="3ff38-336">The source places the data object on the Clipboard using [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard).</span></span>
4.  <span data-ttu-id="3ff38-337">目標會使用 [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard)從剪貼簿抓取資料物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-337">The target retrieves the data object from the Clipboard using [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span></span>
5.  <span data-ttu-id="3ff38-338">目標會將 [CFSTR \_ PREFERREDDROPEFFECT](clipboard.md) 資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-338">The target extracts the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) data.</span></span> <span data-ttu-id="3ff38-339">如果設定為 [僅 DROPEFFECT \_ 移動]，目標可以進行優化的移動，或只複製資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-339">If it is set to only DROPEFFECT\_MOVE, the target can either do an optimized move or simply copy the data.</span></span>
6.  <span data-ttu-id="3ff38-340">如果目標沒有優化的移動，它會呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 方法，並將 [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) 格式設定為 DROPEFFECT \_ move。</span><span class="sxs-lookup"><span data-stu-id="3ff38-340">If the target does not do an optimized move, it calls the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with the [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span>
7.  <span data-ttu-id="3ff38-341">當貼上完成時，目標會呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 方法，並將 [CFSTR \_ PASTESUCCEEDED](clipboard.md) 格式設定為 DROPEFFECT \_ MOVE。</span><span class="sxs-lookup"><span data-stu-id="3ff38-341">When the paste is complete, the target calls the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with the [CFSTR\_PASTESUCCEEDED](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span>
8.  <span data-ttu-id="3ff38-342">當呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 方法，並將 [CFSTR \_ PASTESUCCEEDED](clipboard.md) 格式設定為 DROPEFFECT \_ MOVE 時，它必須檢查它是否也會收到 [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) 格式設定為 DROPEFFECT \_ move。</span><span class="sxs-lookup"><span data-stu-id="3ff38-342">When the source's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method is called with the [CFSTR\_PASTESUCCEEDED](clipboard.md) format set to DROPEFFECT\_MOVE, it must check to see if it also received the [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="3ff38-343">如果這兩種格式都是由目標傳送，來源就必須刪除資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-343">If both formats are sent by the target, the source will have to delete the data.</span></span> <span data-ttu-id="3ff38-344">如果只收到 [CFSTR \_ PASTESUCCEEDED](clipboard.md) 格式，則來源可以直接從其顯示中移除資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-344">If only the [CFSTR\_PASTESUCCEEDED](clipboard.md) format is received, the source can simply remove the data from its display.</span></span> <span data-ttu-id="3ff38-345">如果傳輸失敗，來源會將顯示更新為其原始外觀。</span><span class="sxs-lookup"><span data-stu-id="3ff38-345">If the transfer fails, the source updates the display to its original appearance.</span></span>

## <a name="transfering-data-to-and-from-virtual-folders"></a><span data-ttu-id="3ff38-346">從虛擬資料夾傳輸資料</span><span class="sxs-lookup"><span data-stu-id="3ff38-346">Transfering Data to and from Virtual Folders</span></span>

<span data-ttu-id="3ff38-347">**案例：** 使用者將物件拖曳到虛擬資料夾，或將它放在虛擬資料夾中。</span><span class="sxs-lookup"><span data-stu-id="3ff38-347">**Scenario:** A user drags an object from or drops it on a virtual folder.</span></span>

<span data-ttu-id="3ff38-348">虛擬資料夾包含通常不屬於檔案系統的物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-348">Virtual folders contain objects that are generally not part of the file system.</span></span> <span data-ttu-id="3ff38-349">某些虛擬資料夾（例如資源回收筒）可以代表儲存在硬碟上，但不是一般檔案系統物件的資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-349">Some virtual folders, such as the Recycle Bin, can represent data that is stored on the hard disk but not as ordinary file system objects.</span></span> <span data-ttu-id="3ff38-350">有些可以代表位於遠端系統上的儲存資料，例如掌上型電腦或 FTP 網站。</span><span class="sxs-lookup"><span data-stu-id="3ff38-350">Some can represent stored data that is on a remote system, such as a handheld PC, or an FTP site.</span></span> <span data-ttu-id="3ff38-351">其他（例如 [印表機] 資料夾）包含不代表儲存資料的物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-351">Others, such as the Printers folder, contain objects that do not represent stored data at all.</span></span> <span data-ttu-id="3ff38-352">雖然某些虛擬資料夾是系統的一部分，但開發人員也可以藉由執行命名空間延伸來建立和安裝自訂虛擬資料夾。</span><span class="sxs-lookup"><span data-stu-id="3ff38-352">While some virtual folders are part of the system, developers can also create and install custom virtual folders by implementing a namespace extension.</span></span>

<span data-ttu-id="3ff38-353">無論資料類型或其儲存方式為何，命令介面都會將虛擬資料夾所包含的資料夾和檔案物件顯示為一般檔案和資料夾。</span><span class="sxs-lookup"><span data-stu-id="3ff38-353">Regardless of the type of data or how it is stored, the folder and file objects that are contained by a virtual folder are presented by the Shell as if they were normal files and folders.</span></span> <span data-ttu-id="3ff38-354">虛擬資料夾會負責取得其所包含的任何資料，並適當地呈現給 Shell。</span><span class="sxs-lookup"><span data-stu-id="3ff38-354">It is the responsibility of the virtual folder to take whatever data it contains and present it to the Shell appropriately.</span></span> <span data-ttu-id="3ff38-355">這項需求表示虛擬資料夾通常支援拖放和剪貼簿資料傳輸。</span><span class="sxs-lookup"><span data-stu-id="3ff38-355">This requirement means that virtual folders normally support drag-and-drop and Clipboard data transfers.</span></span>

<span data-ttu-id="3ff38-356">因此，有兩個開發人員需要關注虛擬資料夾的資料傳輸：</span><span class="sxs-lookup"><span data-stu-id="3ff38-356">There are thus two groups of developers who need to be concerned with data transfer to and from virtual folders:</span></span>

-   <span data-ttu-id="3ff38-357">應用程式需要接受從虛擬資料夾傳輸之資料的開發人員。</span><span class="sxs-lookup"><span data-stu-id="3ff38-357">Developers whose applications need to accept data that is transferred from a virtual folder.</span></span>
-   <span data-ttu-id="3ff38-358">其命名空間延伸模組需要適當支援資料傳輸的開發人員。</span><span class="sxs-lookup"><span data-stu-id="3ff38-358">Developers whose namespace extensions need to properly support data transfer.</span></span>

### <a name="accepting-data-from-a-virtual-folder"></a><span data-ttu-id="3ff38-359">接受虛擬資料夾中的資料</span><span class="sxs-lookup"><span data-stu-id="3ff38-359">Accepting Data from a Virtual Folder</span></span>

<span data-ttu-id="3ff38-360">虛擬資料夾幾乎可代表任何類型的資料，而且可以用任何選擇的方式儲存該資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-360">Virtual folders can represent virtually any type of data and can store that data in any way they choose.</span></span> <span data-ttu-id="3ff38-361">某些虛擬資料夾實際上可能包含一般的檔案系統檔案和資料夾。</span><span class="sxs-lookup"><span data-stu-id="3ff38-361">Some virtual folders might actually contain normal file system files and folders.</span></span> <span data-ttu-id="3ff38-362">比方說，有些人可能會將所有的物件封裝成單一檔或資料庫。</span><span class="sxs-lookup"><span data-stu-id="3ff38-362">Others might, for instance, pack all their objects into a single document or database.</span></span>

<span data-ttu-id="3ff38-363">當檔案系統物件傳輸至應用程式時，資料物件通常會包含具有物件完整路徑的 [CF \_ HDROP](clipboard.md) 格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-363">When a file system object is transferred to an application, the data object normally contains a [CF\_HDROP](clipboard.md) format with the object's fully qualified path.</span></span> <span data-ttu-id="3ff38-364">您的應用程式可以將此字串解壓縮，並使用一般檔案系統函式來開啟檔案並將其資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-364">Your application can extract this string and use the normal file system functions to open the file and extract its data.</span></span> <span data-ttu-id="3ff38-365">不過，由於虛擬資料夾通常不包含一般的檔案系統物件，因此通常不會使用 [CF \_ HDROP](clipboard.md)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-365">However, because virtual folders typically do not contain normal file system objects, they generally do not use [CF\_HDROP](clipboard.md).</span></span>

<span data-ttu-id="3ff38-366">資料通常會從具有[CFSTR \_ FILEDESCRIPTOR](clipboard.md)CFSTR FILECONTENTS 格式的虛擬資料夾傳輸，而不是[CF \_ HDROP](clipboard.md) / [ \_ ](clipboard.md) 。</span><span class="sxs-lookup"><span data-stu-id="3ff38-366">Instead of [CF\_HDROP](clipboard.md), data is normally transferred from virtual folders with the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span> <span data-ttu-id="3ff38-367">[CFSTR \_ FILECONTENTS](clipboard.md)格式有兩個優於[CF \_ HDROP](clipboard.md)的優點：</span><span class="sxs-lookup"><span data-stu-id="3ff38-367">The [CFSTR\_FILECONTENTS](clipboard.md) format has two advantages over [CF\_HDROP](clipboard.md):</span></span>

-   <span data-ttu-id="3ff38-368">未採用任何特定的資料儲存方法。</span><span class="sxs-lookup"><span data-stu-id="3ff38-368">No particular method of data storage is assumed.</span></span>
-   <span data-ttu-id="3ff38-369">格式較有彈性。</span><span class="sxs-lookup"><span data-stu-id="3ff38-369">The format is more flexible.</span></span> <span data-ttu-id="3ff38-370">它支援三種資料傳輸機制：全域記憶體物件、 [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) 介面或 [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) 介面。</span><span class="sxs-lookup"><span data-stu-id="3ff38-370">It supports three data transfer mechanisms: a global memory object, an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface, or an [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span>

<span data-ttu-id="3ff38-371">全域記憶體物件很少用來將資料傳送至虛擬物件或從中傳送資料，因為資料必須完整複製到記憶體中。</span><span class="sxs-lookup"><span data-stu-id="3ff38-371">Global memory objects are rarely used to transfer data to or from virtual objects because the data must be copied into memory in its entirety.</span></span> <span data-ttu-id="3ff38-372">傳送介面指標幾乎不需要記憶體，而且效率更高。</span><span class="sxs-lookup"><span data-stu-id="3ff38-372">Transferring an interface pointer requires almost no memory and is much more efficient.</span></span> <span data-ttu-id="3ff38-373">使用非常大型的檔案時，介面指標可能是唯一實用的資料傳輸機制。</span><span class="sxs-lookup"><span data-stu-id="3ff38-373">With very large files, an interface pointer might be the only practical data transfer mechanism.</span></span> <span data-ttu-id="3ff38-374">通常，資料是以 [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) 指標表示，因為該介面比 [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage)更有彈性。</span><span class="sxs-lookup"><span data-stu-id="3ff38-374">Typically, data is represented by an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) pointer, because that interface is somewhat more flexible than [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span></span> <span data-ttu-id="3ff38-375">目標會從資料物件中解壓縮指標，並使用介面方法來將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-375">The target extracts the pointer from the data object and uses the interface methods to extract the data.</span></span>

<span data-ttu-id="3ff38-376">如需如何處理[CFSTR \_ FILEDESCRIPTOR](clipboard.md) / [CFSTR \_ FILECONTENTS](clipboard.md)格式的進一步討論，請參閱[使用 CFSTR \_ FILECONTENTS 格式將資料從檔案解壓縮](/windows)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-376">For further discussion of how to handle the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats, see [Using the CFSTR\_FILECONTENTS Format to Extract Data from a File](/windows).</span></span>

### <a name="transferring-data-to-and-from-a-namespace-extension"></a><span data-ttu-id="3ff38-377">從命名空間延伸模組來回傳送資料</span><span class="sxs-lookup"><span data-stu-id="3ff38-377">Transferring Data to and from a NameSpace Extension</span></span>

<span data-ttu-id="3ff38-378">當您執行命名空間延伸模組時，您通常會想要支援拖放功能。</span><span class="sxs-lookup"><span data-stu-id="3ff38-378">When you implement a namespace extension, you will normally want to support drag-and-drop capabilities.</span></span> <span data-ttu-id="3ff38-379">遵循 [一般指導方針](#general-guidelines)中所討論之卸載來源和目標的建議。</span><span class="sxs-lookup"><span data-stu-id="3ff38-379">Follow the recommendations for drop sources and targets discussed in [General Guidelines](#general-guidelines).</span></span> <span data-ttu-id="3ff38-380">尤其是命名空間延伸模組必須：</span><span class="sxs-lookup"><span data-stu-id="3ff38-380">In particular, a namespace extension must:</span></span>

-   <span data-ttu-id="3ff38-381">可以處理[CFSTR \_ FILEDESCRIPTOR](clipboard.md) / [CFSTR \_ FILECONTENTS](clipboard.md)格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-381">Be able to handle the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span> <span data-ttu-id="3ff38-382">這兩種格式通常用來在命名空間延伸中傳送物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-382">These two formats are normally used to transfer objects to and from namespace extensions.</span></span>
-   <span data-ttu-id="3ff38-383">可以處理優化的 [移動](#handling-optimized-move-operations)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-383">Be able to handle [optimized moves](#handling-optimized-move-operations).</span></span> <span data-ttu-id="3ff38-384">Shell 預期會使用優化的移動來移動 Shell 物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-384">The Shell expects that Shell objects will be moved with an optimized move.</span></span>
-   <span data-ttu-id="3ff38-385">可以處理 [刪除貼上](#handling-delete-on-paste-operations) 作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-385">Be able to handle a [delete-on-paste](#handling-delete-on-paste-operations) operation.</span></span> <span data-ttu-id="3ff38-386">當使用剪下/貼上作業從 Shell 移動物件時，Shell 會使用「刪除時貼上」。</span><span class="sxs-lookup"><span data-stu-id="3ff38-386">The Shell uses delete-on-paste when objects are moved from the Shell with a cut/paste operation.</span></span>
-   <span data-ttu-id="3ff38-387">能夠處理透過 [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) 或 [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) 介面的資料傳輸。</span><span class="sxs-lookup"><span data-stu-id="3ff38-387">Be able to handle data transfer through an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) or [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span> <span data-ttu-id="3ff38-388">通常會透過傳送這兩個介面指標的其中一個（通常是 **IStream** 指標）來處理從虛擬資料夾傳輸到或傳出的資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-388">Data transfer to or from a virtual folder is normally handled by transferring one of these two interface pointers, typically an **IStream** pointer.</span></span> <span data-ttu-id="3ff38-389">然後，目標會呼叫介面方法來將資料解壓縮：</span><span class="sxs-lookup"><span data-stu-id="3ff38-389">The target then calls the interface methods to extract the data:</span></span>
    -   -   <span data-ttu-id="3ff38-390">作為卸載來源，命名空間延伸模組必須從儲存體解壓縮資料，並透過此介面將資料傳遞至目標。</span><span class="sxs-lookup"><span data-stu-id="3ff38-390">As a drop source, the namespace extension must extract the data from storage and pass it through this interface to the target.</span></span>
        -   <span data-ttu-id="3ff38-391">做為放置目標，命名空間延伸必須透過此介面接受來自來源的資料，並正確地儲存。</span><span class="sxs-lookup"><span data-stu-id="3ff38-391">As a drop target, a namespace extension must accept data from a source through this interface and store it properly.</span></span>

## <a name="dropping-files-on-the-recycle-bin"></a><span data-ttu-id="3ff38-392">將檔案放在資源回收筒</span><span class="sxs-lookup"><span data-stu-id="3ff38-392">Dropping Files on the Recycle Bin</span></span>

<span data-ttu-id="3ff38-393">**案例：** 使用者會將檔案放在 **資源回收筒** 上。</span><span class="sxs-lookup"><span data-stu-id="3ff38-393">**Scenario:** The user drops a file on the **Recycle Bin**.</span></span> <span data-ttu-id="3ff38-394">您的應用程式或命名空間延伸模組會刪除原始檔案。</span><span class="sxs-lookup"><span data-stu-id="3ff38-394">Your application or namespace extension deletes the original file.</span></span>

<span data-ttu-id="3ff38-395">資源回收筒是虛擬資料夾，用來做為不再需要之檔案的儲存機制。</span><span class="sxs-lookup"><span data-stu-id="3ff38-395">The Recycle Bin is a virtual folder that is used as a repository for files that are no longer needed.</span></span> <span data-ttu-id="3ff38-396">只要資源回收筒尚未清空，使用者就可以在稍後復原檔案，並將它傳回檔案系統。</span><span class="sxs-lookup"><span data-stu-id="3ff38-396">As long as the Recycle Bin has not been emptied, the user can later recover the file and return it to the file system.</span></span>

<span data-ttu-id="3ff38-397">在大部分的情況下，將 Shell 物件傳送至資源回收筒的運作方式與任何其他資料夾相同。</span><span class="sxs-lookup"><span data-stu-id="3ff38-397">For the most part, transferring Shell objects to the Recycle Bin works much like any other folder.</span></span> <span data-ttu-id="3ff38-398">不過，當使用者卸載 **資源回收筒** 上的檔案時，來源必須刪除原始的，即使來自資料夾的意見反應表示複製作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-398">However, when a user drops a file on the **Recycle Bin**, the source needs to delete the original, even if the feedback from the folder indicates a copy operation.</span></span> <span data-ttu-id="3ff38-399">通常，卸載來源無法得知其資料物件已卸載的資料夾。</span><span class="sxs-lookup"><span data-stu-id="3ff38-399">Normally, a drop source has no way of knowing which folder its data object has been dropped on.</span></span> <span data-ttu-id="3ff38-400">不過，對於 Windows 2000 和更新版本的系統，當資料物件放在 **資源回收筒** 上時，Shell 會呼叫資料物件的 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 方法，並將 [CFSTR \_ TARGETCLSID](clipboard.md) 格式設定為資源回收筒的類別識別碼 (clsid)  (clsid \_ clear-recyclebin) 。</span><span class="sxs-lookup"><span data-stu-id="3ff38-400">However, for Windows 2000 and later systems, when a data object is dropped on the **Recycle Bin**, the Shell will call the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with a [CFSTR\_TARGETCLSID](clipboard.md) format set to the Recycle Bin's class identifier (CLSID) (CLSID\_RecycleBin).</span></span> <span data-ttu-id="3ff38-401">若要適當地處理資源回收筒案例，您的資料物件應該能夠辨識此格式，並透過私用介面將資訊傳達給來源。</span><span class="sxs-lookup"><span data-stu-id="3ff38-401">To handle the Recycle Bin case properly, your data object should be able to recognize this format and communicate the information to the source through a private interface.</span></span>

> [!Note]  
> <span data-ttu-id="3ff38-402">當呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 時，如果將 [CFSTR \_ TARGETCLSID](clipboard.md) 格式設定為 CLSID \_ clear-recyclebin，資料來源應該會關閉從方法傳回之前所傳送之物件的任何開啟控制碼。</span><span class="sxs-lookup"><span data-stu-id="3ff38-402">When [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) is called with a [CFSTR\_TARGETCLSID](clipboard.md) format set to CLSID\_RecycleBin, the data source should close any open handles to the objects that are being transferred before returning from the method.</span></span> <span data-ttu-id="3ff38-403">否則，您可能會建立共用違規。</span><span class="sxs-lookup"><span data-stu-id="3ff38-403">Otherwise, you might create sharing violations.</span></span>

 

## <a name="creating-and-importing-scrap-files"></a><span data-ttu-id="3ff38-404">建立和匯入片段檔案</span><span class="sxs-lookup"><span data-stu-id="3ff38-404">Creating and Importing Scrap Files</span></span>

<span data-ttu-id="3ff38-405">**案例：** 使用者從 OLE 應用程式的資料檔案拖曳一些資料，然後將它放在桌面上或 Windows 檔案總管。</span><span class="sxs-lookup"><span data-stu-id="3ff38-405">**Scenario:** A user drags some data from an OLE application's data file and drops it on the desktop or Windows Explorer.</span></span>

<span data-ttu-id="3ff38-406">Windows 可讓使用者從 OLE 應用程式的資料檔案拖曳物件，並將它放在桌面或檔系統資料夾中。</span><span class="sxs-lookup"><span data-stu-id="3ff38-406">Windows allows users to drag an object from an OLE application's data file and drop it on the desktop or a file system folder.</span></span> <span data-ttu-id="3ff38-407">此作業會建立一個包含資料的 *廢料* 檔或資料的連結。</span><span class="sxs-lookup"><span data-stu-id="3ff38-407">This operation creates a *scrap file*, which contains the data or a link to the data.</span></span> <span data-ttu-id="3ff38-408">檔案名取自針對物件 CLSID 和 [CF \_ 文字](clipboard.md) 資料註冊的簡短名稱。</span><span class="sxs-lookup"><span data-stu-id="3ff38-408">The file name is taken from the short name registered for the CLSID of the object and the [CF\_TEXT](clipboard.md) data.</span></span> <span data-ttu-id="3ff38-409">若要讓 Shell 建立包含資料的碎片檔案，應用程式的 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 介面必須支援 CF \_ EMBEDSOURCE 剪貼簿格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-409">For the Shell to create a scrap file containing data, the application's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface must support the CF\_EMBEDSOURCE Clipboard format.</span></span> <span data-ttu-id="3ff38-410">若要建立包含連結的檔案， **IDataObject** 必須支援 CF \_ LINKSOURCE 格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-410">To create a file containing a link, **IDataObject** must support the CF\_LINKSOURCE format.</span></span>

<span data-ttu-id="3ff38-411">另外還有三個選擇性功能，可讓應用程式執行以支援片段檔案：</span><span class="sxs-lookup"><span data-stu-id="3ff38-411">There are also three optional features that an application can implement to support scrap files:</span></span>

-   <span data-ttu-id="3ff38-412">來回支援</span><span class="sxs-lookup"><span data-stu-id="3ff38-412">Round-trip support</span></span>
-   <span data-ttu-id="3ff38-413">快取的資料格式</span><span class="sxs-lookup"><span data-stu-id="3ff38-413">Cached data formats</span></span>
-   <span data-ttu-id="3ff38-414">延遲轉譯</span><span class="sxs-lookup"><span data-stu-id="3ff38-414">Delayed rendering</span></span>

### <a name="round-trip-support"></a><span data-ttu-id="3ff38-415">來回支援</span><span class="sxs-lookup"><span data-stu-id="3ff38-415">Round-trip Support</span></span>

<span data-ttu-id="3ff38-416">*來回行程* 牽涉到將資料物件傳送到另一個容器，然後再送回原始檔案。</span><span class="sxs-lookup"><span data-stu-id="3ff38-416">A *round trip* involves transferring a data object to another container and then back to the original document.</span></span> <span data-ttu-id="3ff38-417">例如，使用者可以從試算表將資料格群組傳送至桌面，並以資料建立片段檔案。</span><span class="sxs-lookup"><span data-stu-id="3ff38-417">For instance, a user could transfer a group of cells from a spreadsheet to the desktop, creating a scrap file with the data.</span></span> <span data-ttu-id="3ff38-418">如果使用者接著將碎片轉移回電子表格，則必須將資料整合到原始傳輸之前的檔。</span><span class="sxs-lookup"><span data-stu-id="3ff38-418">If the user then transfers the scrap back to the spreadsheet, the data needs to be integrated into the document as it was before the original transfer.</span></span>

<span data-ttu-id="3ff38-419">當 Shell 建立片段檔案時，它會將資料表示為內嵌物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-419">When the Shell creates the scrap file, it represents the data as an embedding object.</span></span> <span data-ttu-id="3ff38-420">當您將片段傳送至另一個容器時，它會以内嵌物件的形式傳送，即使是傳回原始檔案亦同。</span><span class="sxs-lookup"><span data-stu-id="3ff38-420">When the scrap is transferred to another container, it is transferred as an embedding object, even if it is being returned to the original document.</span></span> <span data-ttu-id="3ff38-421">您的應用程式會負責判斷片段中包含的資料格式，並視需要將資料放回其原生格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-421">Your application is responsible for determining the data format contained in the scrap and putting the data back into its native format if necessary.</span></span>

<span data-ttu-id="3ff38-422">若要建立内嵌物件的格式，請藉由取出物件的 CF OBJECTDESCRIPTOR 格式來判斷其 CLSID \_ 。</span><span class="sxs-lookup"><span data-stu-id="3ff38-422">To establish the format of the embedded object, determine its CLSID by retrieving the object's CF\_OBJECTDESCRIPTOR format.</span></span> <span data-ttu-id="3ff38-423">如果 CLSID 指出屬於應用程式的資料格式，則應該傳送原生資料，而不是呼叫 [**OleCreateFromData**](/windows/win32/api/ole2/nf-ole2-olecreatefromdata)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-423">If the CLSID indicates a data format that belongs to the application, it should transfer the native data instead of calling [**OleCreateFromData**](/windows/win32/api/ole2/nf-ole2-olecreatefromdata).</span></span>

### <a name="cached-data-formats"></a><span data-ttu-id="3ff38-424">快取的資料格式</span><span class="sxs-lookup"><span data-stu-id="3ff38-424">Cached Data Formats</span></span>

<span data-ttu-id="3ff38-425">當 Shell 建立碎片檔案時，它會檢查登錄中是否有可用的格式清單。</span><span class="sxs-lookup"><span data-stu-id="3ff38-425">When the Shell creates a scrap file, it checks the registry for the list of available formats.</span></span> <span data-ttu-id="3ff38-426">根據預設，有兩種可用的格式： CF \_ EMBEDSOURCE 和 cf \_ LINKSOURCE。</span><span class="sxs-lookup"><span data-stu-id="3ff38-426">By default, there are two formats available: CF\_EMBEDSOURCE and CF\_LINKSOURCE.</span></span> <span data-ttu-id="3ff38-427">不過，在許多情況下，應用程式可能需要使用不同格式的片段檔案：</span><span class="sxs-lookup"><span data-stu-id="3ff38-427">However, there are a number of scenarios where applications might need to have scrap files in different formats:</span></span>

-   <span data-ttu-id="3ff38-428">允許將片段傳送至非 OLE 容器（無法接受内嵌物件格式）。</span><span class="sxs-lookup"><span data-stu-id="3ff38-428">To allow scraps to be transferred to non-OLE containers, which cannot accepted embedded object formats.</span></span>
-   <span data-ttu-id="3ff38-429">允許應用程式套件與私用格式進行通訊。</span><span class="sxs-lookup"><span data-stu-id="3ff38-429">To allow suites of applications to communicate with a private format.</span></span>
-   <span data-ttu-id="3ff38-430">讓來回行程更容易處理。</span><span class="sxs-lookup"><span data-stu-id="3ff38-430">To make round trips easier to handle.</span></span>

<span data-ttu-id="3ff38-431">應用程式可以在登錄中快取格式，以將格式新增至片段。</span><span class="sxs-lookup"><span data-stu-id="3ff38-431">Applications can add formats to the scrap by caching them in the registry.</span></span> <span data-ttu-id="3ff38-432">有兩種類型的快取格式：</span><span class="sxs-lookup"><span data-stu-id="3ff38-432">There are two types of cached formats:</span></span>

-   <span data-ttu-id="3ff38-433">優先權快取格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-433">Priority cache formats.</span></span> <span data-ttu-id="3ff38-434">針對這些格式，資料會從資料物件完整複製到片段。</span><span class="sxs-lookup"><span data-stu-id="3ff38-434">For these formats, the data is copied in its entirety into the scrap from the data object.</span></span>
-   <span data-ttu-id="3ff38-435">延遲呈現格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-435">Delay-rendered formats.</span></span> <span data-ttu-id="3ff38-436">針對這些格式，資料物件不會複製到片段。</span><span class="sxs-lookup"><span data-stu-id="3ff38-436">For these formats, the data object is not copied to the scrap.</span></span> <span data-ttu-id="3ff38-437">相反地，轉譯會延遲，直到目標要求資料為止。</span><span class="sxs-lookup"><span data-stu-id="3ff38-437">Instead, rendering is delayed until a target requests the data.</span></span> <span data-ttu-id="3ff38-438">下一節會更詳細地討論延遲轉譯。</span><span class="sxs-lookup"><span data-stu-id="3ff38-438">Delay-rendering is discussed in more detail in the next section.</span></span>

<span data-ttu-id="3ff38-439">若要新增優先順序快取或延遲轉譯格式，請在資料來源的應用程式的 **CLSID** 機碼底下建立 **DataFormat** 子機碼。</span><span class="sxs-lookup"><span data-stu-id="3ff38-439">To add a priority cache or delay-rendered format, create a **DataFormat** subkey under the **CLSID** key of the application that is the source of the data.</span></span> <span data-ttu-id="3ff38-440">在該子機碼下，建立 **PriorityCacheFormats** 或 **DelayRenderFormats** 子機碼。</span><span class="sxs-lookup"><span data-stu-id="3ff38-440">Under that subkey, create a **PriorityCacheFormats** or **DelayRenderFormats** subkey.</span></span> <span data-ttu-id="3ff38-441">針對每個優先順序快取或延遲轉譯格式，建立編號子機碼，從零開始。</span><span class="sxs-lookup"><span data-stu-id="3ff38-441">For each priority cache or delay-rendered format, create a numbered subkey starting with zero.</span></span> <span data-ttu-id="3ff38-442">將此機碼的值設定為具有已註冊之格式名稱或 x 值的字串 \# ，其中 X 表示標準剪貼簿格式的格式號碼。</span><span class="sxs-lookup"><span data-stu-id="3ff38-442">Set the value of this key to either a string with the registered name of the format or a \#X value, where X represents the format number of a standard Clipboard format.</span></span>

<span data-ttu-id="3ff38-443">下列範例顯示兩個應用程式的快取格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-443">The following sample shows cached formats for two applications.</span></span> <span data-ttu-id="3ff38-444">MyProg1 應用程式將 rtf 格式設定為優先權快取格式，以及使用私用格式 "My Format" 作為延遲轉譯格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-444">The MyProg1 application has the rich-text format as a priority cache format, and a private format "My Format" as a delay-rendered format.</span></span> <span data-ttu-id="3ff38-445">MyProg2 應用程式的 CF \_ 點陣圖格式 (\# 8」 ) 為優先權快取格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-445">The MyProg2 application has the CF\_BITMAP format (\#8") as a priority cache format.</span></span>

```
HKEY_CLASSES_ROOT
   CLSID
      {GUID}
         (Default) = MyProg1
         DataFormats
            PriorityCacheFormats
               0
                  (Default) = Rich Text Format
            DelayRenderFormats
               0
                  (Default) = My Format
      {GUID}
         (Default) = MyProg2
         DataFormats
            PriorityCacheFormats
               0
                  (Default) = #8
```

<span data-ttu-id="3ff38-446">您可以藉由建立額外的編號子機碼來新增其他格式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-446">Additional formats can be added by creating additional numbered subkeys.</span></span>

### <a name="delayed-rendering"></a><span data-ttu-id="3ff38-447">延遲轉譯</span><span class="sxs-lookup"><span data-stu-id="3ff38-447">Delayed Rendering</span></span>

<span data-ttu-id="3ff38-448">延遲轉譯格式可讓應用程式建立碎片檔案，但會延遲資料轉譯的費用，直到目標要求為止。</span><span class="sxs-lookup"><span data-stu-id="3ff38-448">A delayed rendering format allows an application to create a scrap file but delay the expense of rendering the data until it is requested by a target.</span></span> <span data-ttu-id="3ff38-449">片段的 [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) 介面將會提供延遲的轉譯格式給目標，以及原生和快取的資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-449">The [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface of a scrap will offer the delayed rendering formats to the target along with native and cached data.</span></span> <span data-ttu-id="3ff38-450">如果目標要求延遲轉譯格式，則 Shell 會執行應用程式，並從使用中物件將資料提供給目標。</span><span class="sxs-lookup"><span data-stu-id="3ff38-450">If the target requests a delayed rendering format, the Shell will run the application and provide the data to the target from the active object.</span></span>

> [!Note]  
> <span data-ttu-id="3ff38-451">因為延遲轉譯的風險很高，所以應謹慎使用。</span><span class="sxs-lookup"><span data-stu-id="3ff38-451">Because delayed rendering is somewhat risky, it should be used with caution.</span></span> <span data-ttu-id="3ff38-452">如果伺服器無法使用，或未啟用 OLE 的應用程式，它將無法運作。</span><span class="sxs-lookup"><span data-stu-id="3ff38-452">It will not work if the server is not available, or on applications that are not OLE-enabled.</span></span>

 

## <a name="dragging-and-dropping-shell-objects-asynchronously"></a><span data-ttu-id="3ff38-453">非同步地拖放 Shell 物件</span><span class="sxs-lookup"><span data-stu-id="3ff38-453">Dragging and Dropping Shell Objects Asynchronously</span></span>

<span data-ttu-id="3ff38-454">**案例：** 使用者將大型資料區塊從來源傳輸至目標。</span><span class="sxs-lookup"><span data-stu-id="3ff38-454">**Scenario:** A user transfers a large block of data from source to target.</span></span> <span data-ttu-id="3ff38-455">為了避免在很長的時間內封鎖這兩個應用程式，目標會以非同步方式將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-455">To avoid blocking both applications for a significant amount of time, the target extracts the data asynchronously.</span></span>

<span data-ttu-id="3ff38-456">通常，拖放作業是一項同步作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-456">Normally, drag-and-drop is a synchronous operation.</span></span> <span data-ttu-id="3ff38-457">簡單地說︰</span><span class="sxs-lookup"><span data-stu-id="3ff38-457">In brief:</span></span>

1.  <span data-ttu-id="3ff38-458">卸載來源會呼叫 [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) 並封鎖其主要執行緒，直到函數傳回為止。</span><span class="sxs-lookup"><span data-stu-id="3ff38-458">The drop source calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) and blocks its primary thread until the function returns.</span></span> <span data-ttu-id="3ff38-459">封鎖主要執行緒通常會封鎖 UI 處理。</span><span class="sxs-lookup"><span data-stu-id="3ff38-459">Blocking the primary thread normally blocks UI processing.</span></span>
2.  <span data-ttu-id="3ff38-460">在呼叫目標的 [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) 方法之後，目標會將資料從其主要執行緒上的資料物件中解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-460">After the target's [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method is called, the target extracts the data from the data object on its primary thread.</span></span> <span data-ttu-id="3ff38-461">此程式通常會在解壓縮進程期間封鎖目標的 UI 處理。</span><span class="sxs-lookup"><span data-stu-id="3ff38-461">This procedure normally blocks the target's UI processing for the duration of the extraction process.</span></span>
3.  <span data-ttu-id="3ff38-462">資料解壓縮之後，目標會傳回 [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) 呼叫、系統會傳回 [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop)，而且這兩個執行緒都可以繼續。</span><span class="sxs-lookup"><span data-stu-id="3ff38-462">Once the data has been extracted, the target returns the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) call, the system returns [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop), and both threads can proceed.</span></span>

<span data-ttu-id="3ff38-463">簡單地說，同步資料傳輸可以封鎖這兩個應用程式的主要執行緒一段很長的時間。</span><span class="sxs-lookup"><span data-stu-id="3ff38-463">In short, synchronous data transfer can block the primary threads of both applications for a significant amount of time.</span></span> <span data-ttu-id="3ff38-464">特別是，這兩個執行緒必須等待，而目標則是將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-464">In particular, both threads must wait while the target extracts the data.</span></span> <span data-ttu-id="3ff38-465">針對少量的資料，將資料解壓縮所需的時間很小，且同步資料傳輸的運作方式很好。</span><span class="sxs-lookup"><span data-stu-id="3ff38-465">For small amounts of data, the time required to extract data is small and synchronous data transfer works quite well.</span></span> <span data-ttu-id="3ff38-466">不過，同步解壓縮大量資料可能會造成冗長的延遲，並干擾目標和來源的 UI。</span><span class="sxs-lookup"><span data-stu-id="3ff38-466">However, synchronously extracting large amounts of data can cause lengthy delays and interfere with the UI of both target and source.</span></span>

<span data-ttu-id="3ff38-467">[**Iasyncoperation<tresult>HTTP**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability)介面是選擇性的介面，可由資料物件來執行。</span><span class="sxs-lookup"><span data-stu-id="3ff38-467">The [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface is an optional interface that can be implemented by a data object.</span></span> <span data-ttu-id="3ff38-468">它讓放置目標能夠以非同步方式在背景執行緒上解壓縮資料物件中的資料。</span><span class="sxs-lookup"><span data-stu-id="3ff38-468">It gives the drop target the ability to extract data from the data object asynchronously on a background thread.</span></span> <span data-ttu-id="3ff38-469">一旦將資料解壓縮遞交給背景執行緒，這兩個應用程式的主要執行緒都可以自由地進行。</span><span class="sxs-lookup"><span data-stu-id="3ff38-469">Once data extraction is handed off to the background thread, the primary threads of both applications are free to proceed.</span></span>

### <a name="using-iasyncoperationidataobjectasynccapability"></a><span data-ttu-id="3ff38-470">使用 Iasyncoperation<tresult>HTTP/IDataObjectAsyncCapability</span><span class="sxs-lookup"><span data-stu-id="3ff38-470">Using IASyncOperation/IDataObjectAsyncCapability</span></span>

> [!Note]  
> <span data-ttu-id="3ff38-471">此介面最初名為 [**iasyncoperation<tresult>HTTP**](/previous-versions//bb776309(v=vs.85))，但稍後變更為 [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-471">The interface was originally named [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)), but this was later changed to [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span></span> <span data-ttu-id="3ff38-472">否則，這兩個介面相同。</span><span class="sxs-lookup"><span data-stu-id="3ff38-472">Otherwise, the two interfaces are identical.</span></span>

 

<span data-ttu-id="3ff38-473">[**Iasyncoperation<tresult>HTTP**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability)的目的是要讓卸載來源和卸載目標能進行協商，以進行非同步資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-473">The purpose of [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) is to allow the drop source and drop target to negotiate whether data can be extracted asynchronously.</span></span> <span data-ttu-id="3ff38-474">下列程式概述 drop source 如何使用介面：</span><span class="sxs-lookup"><span data-stu-id="3ff38-474">The following procedure outlines how the drop source uses the interface:</span></span>

1.  <span data-ttu-id="3ff38-475">建立公開 [**iasyncoperation<tresult>HTTP**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability)的資料物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-475">Create a data object that exposes [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span></span>
2.  <span data-ttu-id="3ff38-476">將 *fDoOpAsync* 設定為 **VARIANT \_ TRUE** 來呼叫 [**SetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode) ，表示支援非同步作業。</span><span class="sxs-lookup"><span data-stu-id="3ff38-476">Call [**SetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode) with *fDoOpAsync* set to **VARIANT\_TRUE** to indicate that an asynchronous operation is supported.</span></span>
3.  <span data-ttu-id="3ff38-477">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop)傳回之後，請呼叫 [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation)：</span><span class="sxs-lookup"><span data-stu-id="3ff38-477">After [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) returns, call [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation):</span></span>
    -   <span data-ttu-id="3ff38-478">如果 [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) 失敗或傳回 **VARIANT \_ FALSE**，則會進行一般同步資料傳輸，並完成資料解壓縮程式。</span><span class="sxs-lookup"><span data-stu-id="3ff38-478">If [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) fails or returns **VARIANT\_FALSE**, a normal synchronous data transfer has taken place and the data extraction process is finished.</span></span> <span data-ttu-id="3ff38-479">來源應該執行任何必要的清除作業，然後繼續進行。</span><span class="sxs-lookup"><span data-stu-id="3ff38-479">The source should do any cleanup that is required, and proceed.</span></span>
    -   <span data-ttu-id="3ff38-480">如果 [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) 傳回 **VARIANT \_ TRUE**，就會以非同步方式將資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-480">If [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) returns **VARIANT\_TRUE**, the data is being extracted asynchronously.</span></span> <span data-ttu-id="3ff38-481">清除作業應該由 [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation)處理。</span><span class="sxs-lookup"><span data-stu-id="3ff38-481">Cleanup operations should be handled by [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span></span>
4.  <span data-ttu-id="3ff38-482">釋放資料物件。</span><span class="sxs-lookup"><span data-stu-id="3ff38-482">Release the data object.</span></span>
5.  <span data-ttu-id="3ff38-483">非同步資料傳輸完成時，資料物件通常會透過私用介面通知來源。</span><span class="sxs-lookup"><span data-stu-id="3ff38-483">When the asynchronous data transfer is complete, the data object normally notifies the source through a private interface.</span></span>

<span data-ttu-id="3ff38-484">下列程式概述 drop target 如何使用 [**iasyncoperation<tresult>HTTP**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability)介面，以非同步方式將資料解壓縮：</span><span class="sxs-lookup"><span data-stu-id="3ff38-484">The following procedure outlines how the drop target uses the [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface to extract data asynchronously:</span></span>

1.  <span data-ttu-id="3ff38-485">當系統呼叫 [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop)時，請呼叫 [**IDataObject：： QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) ，並 [](/previous-versions//bb776309(v=vs.85)) / [](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) \_ \_ 從資料物件要求 (IID IDataObjectAsyncCapability/IID iasyncoperation<tresult>HTTP) 的 iasyncoperation<tresult>HTTP IDataObjectAsyncCapability 介面。</span><span class="sxs-lookup"><span data-stu-id="3ff38-485">When the system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop), call [**IDataObject::QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) and request an [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface (IID\_IAsyncOperation/IID\_IDataObjectAsyncCapability) from the data object.</span></span>
2.  <span data-ttu-id="3ff38-486">呼叫 [**GetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-486">Call [**GetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode).</span></span> <span data-ttu-id="3ff38-487">如果方法傳回 **VARIANT \_ TRUE**，則資料物件支援非同步資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-487">If the method returns **VARIANT\_TRUE**, the data object supports asynchronous data extraction.</span></span>
3.  <span data-ttu-id="3ff38-488">建立個別的執行緒來處理資料解壓縮和呼叫 [**StartOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-startoperation)。</span><span class="sxs-lookup"><span data-stu-id="3ff38-488">Create a separate thread to handle data extraction and call [**StartOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-startoperation).</span></span>
4.  <span data-ttu-id="3ff38-489">傳回 [**IDropTarget：:D rop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) 呼叫，就像一般資料傳輸作業一樣。</span><span class="sxs-lookup"><span data-stu-id="3ff38-489">Return the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) call, as you would for a normal data transfer operation.</span></span> <span data-ttu-id="3ff38-490">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) 將會傳回並解除封鎖放置來源。</span><span class="sxs-lookup"><span data-stu-id="3ff38-490">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) will return and unblock the drop source.</span></span> <span data-ttu-id="3ff38-491">請勿呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 來指出優化移動或刪除貼上作業的結果。</span><span class="sxs-lookup"><span data-stu-id="3ff38-491">Do not call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to indicate the outcome of an optimized move or delete-on-paste operation.</span></span> <span data-ttu-id="3ff38-492">等候作業完成。</span><span class="sxs-lookup"><span data-stu-id="3ff38-492">Wait until the operation is finished.</span></span>
5.  <span data-ttu-id="3ff38-493">將背景執行緒上的資料解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-493">Extract the data on the background thread.</span></span> <span data-ttu-id="3ff38-494">目標的主要執行緒已解除封鎖，並可自由繼續。</span><span class="sxs-lookup"><span data-stu-id="3ff38-494">The target's primary thread is unblocked and free to proceed.</span></span>
6.  <span data-ttu-id="3ff38-495">如果資料傳輸是優化的 [移動](#handling-optimized-move-operations) 或 [刪除貼上](#handling-delete-on-paste-operations) 作業，請呼叫 [**IDataObject：： SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) 來指出結果。</span><span class="sxs-lookup"><span data-stu-id="3ff38-495">If the data transfer was an [optimized move](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operation, call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to indicate the outcome.</span></span>
7.  <span data-ttu-id="3ff38-496">藉由呼叫 [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation)，通知資料物件已完成解壓縮。</span><span class="sxs-lookup"><span data-stu-id="3ff38-496">Notify the data object that extraction is finished by calling [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span></span>

 

 
