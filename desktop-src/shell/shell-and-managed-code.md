---
description: 內含式擴充功能會載入至任何觸發它們的進程。
title: 執行擴充功能的指引 In-Process
ms.topic: article
ms.date: 05/31/2018
ms.assetid: FE830DBF-3F18-453c-9A51-91E10559D0E8
api_name: ''
api_type: ''
api_location: ''
topic_type:
- kbArticle
ms.openlocfilehash: e4dc9fd0573f3f98f0ec1110079f95f56a8c42e1
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/08/2021
ms.locfileid: "103945357"
---
# <a name="guidance-for-implementing-in-process-extensions"></a><span data-ttu-id="9d22d-103">執行擴充功能的指引 In-Process</span><span class="sxs-lookup"><span data-stu-id="9d22d-103">Guidance for Implementing In-Process Extensions</span></span>

<span data-ttu-id="9d22d-104">內含式擴充功能會載入至任何觸發它們的進程。</span><span class="sxs-lookup"><span data-stu-id="9d22d-104">In-process extensions are loaded into any processes that trigger them.</span></span> <span data-ttu-id="9d22d-105">例如，Shell 命名空間延伸模組可以載入至任何進程，以直接或間接方式存取 Shell 命名空間。</span><span class="sxs-lookup"><span data-stu-id="9d22d-105">For example, a Shell namespace extension can be loaded into any process which accesses the Shell namespace either directly or indirectly.</span></span> <span data-ttu-id="9d22d-106">Shell 的命名空間是由許多 Shell 作業所使用，例如顯示一般檔案對話方塊、透過其相關聯的應用程式開機檔案，或取得用來表示檔案的圖示。</span><span class="sxs-lookup"><span data-stu-id="9d22d-106">The Shell namespace is used by many Shell operations, such as the display of a common file dialog, the launch of a document through its associated application, or the obtaining of the icon used to represent a file.</span></span> <span data-ttu-id="9d22d-107">因為同進程擴充功能可以載入至任意進程，所以必須小心，因為它們不會對主應用程式或其他內含式擴充造成負面影響。</span><span class="sxs-lookup"><span data-stu-id="9d22d-107">Because in-process extensions can be loaded into arbitrary processes, care must be taken that they do not negatively impact the host application or other in-process extensions.</span></span>

<span data-ttu-id="9d22d-108">其中一個特定的執行時間是 *common language runtime (CLR)*，也稱為 *managed 程式碼* 或 *.NET Framework*。</span><span class="sxs-lookup"><span data-stu-id="9d22d-108">One runtime of particular note is the *common language runtime (CLR)*, also known as *managed code* or the *.NET Framework*.</span></span> <span data-ttu-id="9d22d-109">**Microsoft 建議您不要將 managed 內含式擴充功能寫入 Windows 檔案總管或 Windows Internet Explorer，也不會將它們視為支援的案例。**</span><span class="sxs-lookup"><span data-stu-id="9d22d-109">**Microsoft recommends against writing managed in-process extensions to Windows Explorer or Windows Internet Explorer and does not consider them a supported scenario.**</span></span>

<span data-ttu-id="9d22d-110">本主題討論當您判斷 CLR 以外的任何執行時間是否適合用於同進程延伸模組時，所要考慮的因素。</span><span class="sxs-lookup"><span data-stu-id="9d22d-110">This topic discusses factors to consider when you determine whether any runtime other than the CLR is suitable for use by in-process extensions.</span></span> <span data-ttu-id="9d22d-111">其他執行時間的範例包括 JAVA、Visual Basic、JavaScript/ECMAScript、Delphi 和 C/c + + 執行時間程式庫。</span><span class="sxs-lookup"><span data-stu-id="9d22d-111">Examples of other runtimes include Java, Visual Basic, JavaScript/ECMAScript, Delphi, and the C/C++ runtime library.</span></span> <span data-ttu-id="9d22d-112">本主題也提供一些原因，也就是 managed 程式碼在同進程延伸中不受支援。</span><span class="sxs-lookup"><span data-stu-id="9d22d-112">This topic also provides some reasons that managed code is unsupported in in-process extensions.</span></span>

## <a name="version-conflicts"></a><span data-ttu-id="9d22d-113">版本衝突</span><span class="sxs-lookup"><span data-stu-id="9d22d-113">Version Conflicts</span></span>

<span data-ttu-id="9d22d-114">當執行時間不支援在單一進程中載入多個執行階段版本時，可能會發生版本衝突。</span><span class="sxs-lookup"><span data-stu-id="9d22d-114">A version conflict can arise through a runtime that does not support the loading of multiple runtime versions within a single process.</span></span> <span data-ttu-id="9d22d-115">4.0 版之前的 CLR 版本屬於這個類別。</span><span class="sxs-lookup"><span data-stu-id="9d22d-115">Versions of the CLR prior to version 4.0 fall into this category.</span></span> <span data-ttu-id="9d22d-116">如果載入某個執行時間版本時，無法載入該相同執行時間的其他版本，這可能會在主應用程式或其他內含式擴充功能使用衝突的版本時產生衝突。</span><span class="sxs-lookup"><span data-stu-id="9d22d-116">If the loading of one version of a runtime precludes the loading of other versions of that same runtime, this can create a conflict if the host application or another in-process extension uses a conflicting version.</span></span> <span data-ttu-id="9d22d-117">如果版本與另一個同進程延伸模組發生衝突，衝突可能很難重現，因為失敗需要正確的衝突擴充功能，而失敗模式則取決於載入衝突擴充功能的順序。</span><span class="sxs-lookup"><span data-stu-id="9d22d-117">In the case of a version conflict with another in-process extension, the conflict can be difficult to reproduce because the failure requires the right conflicting extensions and the failure mode depends on the order in which the conflicting extensions are loaded.</span></span>

<span data-ttu-id="9d22d-118">請考慮使用4.0 版之前的 CLR 版本所撰寫的同進程擴充功能。</span><span class="sxs-lookup"><span data-stu-id="9d22d-118">Consider an in-process extension written using a version of the CLR prior to version 4.0.</span></span> <span data-ttu-id="9d22d-119">電腦上使用 [ **開啟** 檔案] 對話方塊的每個應用程式，都可能會將對話的 managed 程式碼和其在應用程式中載入的「應用程式」相依性載入至應用程式的進程。</span><span class="sxs-lookup"><span data-stu-id="9d22d-119">Every application on the computer that uses a file **Open** dialog box could potentially have the dialog's managed code and its attendant CLR dependency loaded into the application's process.</span></span> <span data-ttu-id="9d22d-120">第一次將 CLR 的4.0 版載入至應用程式進程的應用程式或擴充功能，會限制該程式之後可以使用的 CLR 版本。</span><span class="sxs-lookup"><span data-stu-id="9d22d-120">The application or extension that is first to load a pre-4.0 version of the CLR into the application's process restricts which versions of the CLR can be used subsequently by that process.</span></span> <span data-ttu-id="9d22d-121">如果具有 **開啟** 對話方塊的 managed 應用程式是以衝突的 CLR 版本為基礎，則擴充功能可能無法正確執行，而且可能會導致應用程式失敗。</span><span class="sxs-lookup"><span data-stu-id="9d22d-121">If a managed application with an **Open** dialog box is built on a conflicting version of the CLR, then the extension could fail to run correctly and could cause failures in the application.</span></span> <span data-ttu-id="9d22d-122">相反地，如果延伸模組是在進程中載入的第一個，而且 managed 程式碼的衝突版本會在該 (可能是 managed 應用程式或執行中的應用程式在需要時載入 CLR) ，則作業會失敗。</span><span class="sxs-lookup"><span data-stu-id="9d22d-122">Conversely, if the extension is the first to load in a process and a conflicting version of managed code tries to launch after that (perhaps a managed application or a running application loads the CLR on demand), the operation fails.</span></span> <span data-ttu-id="9d22d-123">對使用者而言，應用程式的某些功能會隨機停止運作，或應用程式莫名其妙損毀。</span><span class="sxs-lookup"><span data-stu-id="9d22d-123">To the user, it appears that some features of the application randomly stop working, or the application mysteriously crashes.</span></span>

<span data-ttu-id="9d22d-124">請注意，等於或晚于4.0 版的 CLR 版本，通常不容易受到版本控制問題的影響，因為它們是設計成與彼此並存，並且具有大部分的 CLR 1.0 (的最高4.0 版，但不能與其他版本) 並存。</span><span class="sxs-lookup"><span data-stu-id="9d22d-124">Note that versions of the CLR equal to or later than version 4.0 are not generally susceptible to the versioning problem because they are designed to coexist with each other and with most pre-4.0 versions of the CLR (with the exception of version 1.0, which cannot coexist with other versions).</span></span> <span data-ttu-id="9d22d-125">不過，可能會發生版本衝突以外的問題，如本主題的其餘部分所述。</span><span class="sxs-lookup"><span data-stu-id="9d22d-125">However, issues other than version conflicts can arise as discussed in the remainder of this topic.</span></span>

## <a name="performance-issues"></a><span data-ttu-id="9d22d-126">效能問題</span><span class="sxs-lookup"><span data-stu-id="9d22d-126">Performance Issues</span></span>

<span data-ttu-id="9d22d-127">當執行時間將效能問題載入處理常式時，可能會對效能產生重大影響。</span><span class="sxs-lookup"><span data-stu-id="9d22d-127">Performance issues can arise with runtimes that impose a significant performance penalty when they are loaded into a process.</span></span> <span data-ttu-id="9d22d-128">效能下降的形式可能是記憶體使用量、CPU 使用量、經過時間，甚至是位址空間耗用量。</span><span class="sxs-lookup"><span data-stu-id="9d22d-128">The performance penalty can be in the form of memory usage, CPU usage, elapsed time, or even address space consumption.</span></span> <span data-ttu-id="9d22d-129">CLR、JavaScript/ECMAScript 和 JAVA 已知為高度影響執行時間。</span><span class="sxs-lookup"><span data-stu-id="9d22d-129">The CLR, JavaScript/ECMAScript, and Java are known to be high-impact runtimes.</span></span> <span data-ttu-id="9d22d-130">由於同進程擴充功能可以載入至許多進程，而且通常會在效能緊迫的時刻進行 (例如，當您準備要顯示使用者) 的功能表時，強烈影響的執行時間可能會對整體回應性造成負面影響。</span><span class="sxs-lookup"><span data-stu-id="9d22d-130">Since in-process extensions can be loaded into many processes, and are often done so at performance-sensitive moments (such as when preparing a menu to be displayed the user), high-impact runtimes can negatively impact overall responsiveness.</span></span>

<span data-ttu-id="9d22d-131">耗用大量資源的高影響執行時間可能會導致主機進程或另一個同進程延伸模組失敗。</span><span class="sxs-lookup"><span data-stu-id="9d22d-131">A high-impact runtime that consumes significant resources can cause a failure in the host process or another in-process extension.</span></span> <span data-ttu-id="9d22d-132">例如，對其堆積取用數百 mb 位址空間的高度影響執行時間，可能會導致主機應用程式無法載入大型資料集。</span><span class="sxs-lookup"><span data-stu-id="9d22d-132">For example, a high-impact runtime that consumes hundreds of megabytes of address space for its heap can result in the host application being unable to load a large dataset.</span></span> <span data-ttu-id="9d22d-133">此外，因為同進程擴充功能可以載入至多個進程，所以單一延伸模組中的高資源耗用量，可以快速地在整個系統中使用高資源耗用量。</span><span class="sxs-lookup"><span data-stu-id="9d22d-133">Furthermore, because in-process extensions can be loaded into multiple processes, high resource consumption in a single extension can quickly multiply into high resource consumption across the entire system.</span></span>

<span data-ttu-id="9d22d-134">如果執行時間仍處於載入狀態，或即使在使用該執行時間的延伸模組已卸載時仍繼續取用資源，則該執行時間不適合在擴充功能中使用。</span><span class="sxs-lookup"><span data-stu-id="9d22d-134">If a runtime remains loaded or otherwise continues to consume resources even when the extension that uses that runtime has unloaded, then that runtime is not suitable for use in an extension.</span></span>

## <a name="issues-specific-to-the-net-framework"></a><span data-ttu-id="9d22d-135">.NET Framework 的特定問題</span><span class="sxs-lookup"><span data-stu-id="9d22d-135">Issues Specific to the .NET Framework</span></span>

<span data-ttu-id="9d22d-136">下列各節將討論使用 managed 程式碼延伸模組時發現的問題範例。</span><span class="sxs-lookup"><span data-stu-id="9d22d-136">The following sections discuss examples of issues found with using managed code for extensions.</span></span> <span data-ttu-id="9d22d-137">它們並不是您可能會遇到的所有可能問題的完整清單。</span><span class="sxs-lookup"><span data-stu-id="9d22d-137">They are not a complete list of all possible issues that you might encounter.</span></span> <span data-ttu-id="9d22d-138">此處所討論的問題都是延伸模組中不支援 managed 程式碼的原因，以及當您評估其他執行時間的使用時，要考慮的重點。</span><span class="sxs-lookup"><span data-stu-id="9d22d-138">The issues discussed here are both reasons that managed code is not supported in extensions and points to consider when you evaluate the use of other runtimes.</span></span>

### <a name="re-entrancy"></a><span data-ttu-id="9d22d-139">重新進入</span><span class="sxs-lookup"><span data-stu-id="9d22d-139">Re-entrancy</span></span>

<span data-ttu-id="9d22d-140">當 CLR 封鎖單一執行緒的單元 (STA) 執行緒時（例如，由於監視器）。 Enter、WaitHandle. WaitOne 或爭用 [**lock**](https://msdn.microsoft.com/library/c5kehkcz(v=VS.71).aspx) 語句，CLR 在其標準設定中，會在等候時進入嵌套的訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="9d22d-140">When the CLR blocks a single-threaded apartment (STA) thread, for example, due to a Monitor.Enter, WaitHandle.WaitOne, or contended [**lock**](https://msdn.microsoft.com/library/c5kehkcz(v=VS.71).aspx) statement, the CLR, in its standard configuration, enters a nested message loop while it waits.</span></span> <span data-ttu-id="9d22d-141">有許多擴充方法都禁止處理訊息，而這種無法預期且未預期的重新進入，可能會造成異常行為，而難以重現和診斷。</span><span class="sxs-lookup"><span data-stu-id="9d22d-141">Many extension methods are prohibited from processing messages, and this unpredictable and unexpected reentrancy can result in anomalous behavior which is difficult to reproduce and diagnose.</span></span>

### <a name="the-multithreaded-apartment"></a><span data-ttu-id="9d22d-142">多執行緒單元</span><span class="sxs-lookup"><span data-stu-id="9d22d-142">The Multithreaded Apartment</span></span>

<span data-ttu-id="9d22d-143">CLR 會為元件物件模型 (COM) 物件建立執行時間可呼叫的 *包裝* 函式。</span><span class="sxs-lookup"><span data-stu-id="9d22d-143">The CLR creates *Runtime Callable Wrappers* for Component Object Model (COM) objects.</span></span> <span data-ttu-id="9d22d-144">這些相同的執行時間可呼叫包裝函式稍後會由 CLR 的完成項（屬於多執行緒單元 (MTA) 的一部分）終結。</span><span class="sxs-lookup"><span data-stu-id="9d22d-144">These same Runtime Callable Wrappers are destroyed later by the CLR's finalizer, which is part of the multithreaded apartment (MTA).</span></span> <span data-ttu-id="9d22d-145">將 proxy 從 STA 移至 MTA 需要封送處理，但不會封送處理擴充功能使用的所有介面。</span><span class="sxs-lookup"><span data-stu-id="9d22d-145">Moving the proxy from the STA to the MTA requires marshaling, but not all interfaces used by extensions can be marshalled.</span></span>

### <a name="non-deterministic-object-lifetimes"></a><span data-ttu-id="9d22d-146">不具決定性的物件存留期</span><span class="sxs-lookup"><span data-stu-id="9d22d-146">Non-Deterministic Object Lifetimes</span></span>

<span data-ttu-id="9d22d-147">CLR 比原生程式碼的物件存留期保證更弱。</span><span class="sxs-lookup"><span data-stu-id="9d22d-147">The CLR has weaker object lifetime guarantees than native code.</span></span> <span data-ttu-id="9d22d-148">許多延伸模組都有物件和介面的參考計數需求，而 CLR 所採用的垃圾收集模型無法滿足這些需求。</span><span class="sxs-lookup"><span data-stu-id="9d22d-148">Many extensions have reference count requirements on objects and interfaces, and the garbage-collection model employed by the CLR cannot fulfill these requirements.</span></span>

-   <span data-ttu-id="9d22d-149">如果 CLR 物件取得 COM 物件的參考，就不會釋放執行時間可呼叫包裝函式所持有的 COM 物件參考，直到執行時間可呼叫包裝函式進行垃圾收集為止。</span><span class="sxs-lookup"><span data-stu-id="9d22d-149">If a CLR object obtains a reference to a COM object, the COM object reference held by the Runtime Callable Wrapper is not released until the Runtime Callable Wrapper is garbage-collected.</span></span> <span data-ttu-id="9d22d-150">非決定性的發行行為可能會與某些介面合約發生衝突。</span><span class="sxs-lookup"><span data-stu-id="9d22d-150">Nondeterministic release behavior can conflict with some interface contracts.</span></span> <span data-ttu-id="9d22d-151">例如， [**IPersistPropertyBag：： Load**](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa768206(v=vs.85)) 方法要求當 **Load** 方法傳回時，物件不會保留屬性包的參考。</span><span class="sxs-lookup"><span data-stu-id="9d22d-151">For example, the [**IPersistPropertyBag::Load**](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa768206(v=vs.85)) method requires that no reference to the property bag be retained by the object when the **Load** method returns.</span></span>
-   <span data-ttu-id="9d22d-152">如果 CLR 物件參考傳回機器碼，則執行時間可呼叫包裝函式會在呼叫運行 [**時間可呼叫**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) 包裝函式的最後呼叫時，會讓出其 clr 物件的參考，但基礎 CLR 物件在進行垃圾收集之前不會完成。</span><span class="sxs-lookup"><span data-stu-id="9d22d-152">If a CLR object reference is returned to native code, the Runtime Callable Wrapper relinquishes its reference to the CLR object when the Runtime Callable Wrapper's final call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) is made, but the underlying CLR object is not finalized until it is garbage-collected.</span></span> <span data-ttu-id="9d22d-153">不具決定性的最終可能會與某些介面合約發生衝突。</span><span class="sxs-lookup"><span data-stu-id="9d22d-153">Nondeterministic finalization can conflict with some interface contracts.</span></span> <span data-ttu-id="9d22d-154">例如，縮圖處理常式必須在其參考計數降至零時立即釋出所有資源。</span><span class="sxs-lookup"><span data-stu-id="9d22d-154">For example, thumbnail handlers are required to release all resources immediately when their reference count drops to zero.</span></span>

## <a name="acceptable-uses-of-managed-code-and-other-runtimes"></a><span data-ttu-id="9d22d-155">受控碼和其他執行時間的可接受用法</span><span class="sxs-lookup"><span data-stu-id="9d22d-155">Acceptable Uses of Managed Code and Other Runtimes</span></span>

<span data-ttu-id="9d22d-156">使用 managed 程式碼和其他執行時間來執行跨進程擴充是可接受的。</span><span class="sxs-lookup"><span data-stu-id="9d22d-156">It is acceptable to use managed code and other runtimes to implement out-of-process extensions.</span></span> <span data-ttu-id="9d22d-157">跨進程 Shell 延伸模組的範例包括下列各項：</span><span class="sxs-lookup"><span data-stu-id="9d22d-157">Examples of out-of-process Shell extensions include the following:</span></span>

-   <span data-ttu-id="9d22d-158">預覽處理常式</span><span class="sxs-lookup"><span data-stu-id="9d22d-158">Preview handlers</span></span>
-   <span data-ttu-id="9d22d-159">命令列型動作，例如在 **shell** \\ *動詞* \\ **命令** 子機碼下註冊的動作。</span><span class="sxs-lookup"><span data-stu-id="9d22d-159">Command-line-based actions such as those registered under **shell**\\*verb*\\**command** subkeys.</span></span>
-   <span data-ttu-id="9d22d-160">在本機伺服器中執行的 COM 物件，適用于允許跨進程啟用的 Shell 擴充點。</span><span class="sxs-lookup"><span data-stu-id="9d22d-160">COM objects implemented in a local server, for Shell extension points that allow out-of-process activation.</span></span>

<span data-ttu-id="9d22d-161">有些擴充功能可以實作為同進程或跨進程的延伸模組。</span><span class="sxs-lookup"><span data-stu-id="9d22d-161">Some extensions can be implemented either as in-process or out-of-process extensions.</span></span> <span data-ttu-id="9d22d-162">如果這些擴充功能不符合這些內含式擴充功能的需求，您可以將這些擴充功能實作為跨進程擴充。</span><span class="sxs-lookup"><span data-stu-id="9d22d-162">You can implement these extensions as out-of-process extensions if they do not meet these requirements for in-process extensions.</span></span> <span data-ttu-id="9d22d-163">下列清單顯示可實作為同進程或跨進程擴充的延伸模組範例：</span><span class="sxs-lookup"><span data-stu-id="9d22d-163">The following list shows examples of extensions that can be implemented as either in-process or out-of-process extensions:</span></span>

-   <span data-ttu-id="9d22d-164">[**IExecuteCommand**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-iexecutecommand)與在 **shell**  \\ *動詞* \\ **命令** 子機碼下註冊的 DelegateExecute 專案相關聯。</span><span class="sxs-lookup"><span data-stu-id="9d22d-164">[**IExecuteCommand**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-iexecutecommand) associated with a **DelegateExecute** entry registered under a **shell**\\*verb*\\**command** subkey.</span></span>
-   <span data-ttu-id="9d22d-165">[**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget)與在 **shell** \\ *動詞* \\ **DropTarget** 子機碼下註冊的 CLSID 相關聯。</span><span class="sxs-lookup"><span data-stu-id="9d22d-165">[**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) associated with the CLSID registered under a **shell**\\*verb*\\**DropTarget** subkey.</span></span>
-   <span data-ttu-id="9d22d-166">[**IExplorerCommandState**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-iexplorercommandstate)與在 **shell** 動詞子機碼下註冊的 **CommandStateHandler** 專案相關聯 \\  。</span><span class="sxs-lookup"><span data-stu-id="9d22d-166">[**IExplorerCommandState**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-iexplorercommandstate) associated with a **CommandStateHandler** entry registered under a **shell**\\*verb* subkey.</span></span>

 

 
