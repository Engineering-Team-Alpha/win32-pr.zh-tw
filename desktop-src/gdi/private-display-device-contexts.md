---
description: 私用裝置內容可讓應用程式在每次應用程式必須在視窗中繪製時，避免每次都必須抓取並初始化顯示裝置內容。
ms.assetid: 8de5a14b-a8b3-42a5-81f3-bf3c357052cb
title: 私用顯示裝置內容
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 451dbd3c0a232610026740d0ea0fa817ea2034b8
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/07/2021
ms.locfileid: "104512852"
---
# <a name="private-display-device-contexts"></a><span data-ttu-id="ff96e-103">私用顯示裝置內容</span><span class="sxs-lookup"><span data-stu-id="ff96e-103">Private Display Device Contexts</span></span>

<span data-ttu-id="ff96e-104">*私用裝置內容* 可讓應用程式在每次應用程式必須在視窗中繪製時，避免每次都必須抓取並初始化顯示裝置內容。</span><span class="sxs-lookup"><span data-stu-id="ff96e-104">A *private device context* enables an application to avoid retrieving and initializing a display device context each time the application must draw in a window.</span></span> <span data-ttu-id="ff96e-105">私用裝置內容適用于需要對裝置內容的屬性值進行許多變更，以準備進行繪製的 windows。</span><span class="sxs-lookup"><span data-stu-id="ff96e-105">Private device contexts are useful for windows that require many changes to the values of the attributes of the device context to prepare it for drawing.</span></span> <span data-ttu-id="ff96e-106">私用裝置內容可減少準備裝置內容所需的時間，因而縮短在視窗中執行繪圖所需的時間。</span><span class="sxs-lookup"><span data-stu-id="ff96e-106">Private device contexts reduce the time required to prepare the device context and therefore the time needed to carry out drawing in the window.</span></span>

<span data-ttu-id="ff96e-107">應用程式會指示系統建立視窗的私用裝置內容，方法是 \_ 在視窗類別中指定 CS OWNDC 樣式。</span><span class="sxs-lookup"><span data-stu-id="ff96e-107">An application directs the system to create a private device context for a window by specifying the CS\_OWNDC style in the window class.</span></span> <span data-ttu-id="ff96e-108">系統會在每次建立屬於類別的新視窗時建立唯一的私用裝置內容。</span><span class="sxs-lookup"><span data-stu-id="ff96e-108">The system creates a unique private device context each time it creates a new window belonging to the class.</span></span> <span data-ttu-id="ff96e-109">一開始，私用裝置內容具有與一般裝置內容相同的屬性預設值，但應用程式可以隨時修改這些屬性。</span><span class="sxs-lookup"><span data-stu-id="ff96e-109">Initially, the private device context has the same default values for attributes as a common device context, but the application can modify these at any time.</span></span> <span data-ttu-id="ff96e-110">系統會保留視窗存留期內的裝置內容變更，或直到應用程式進行其他變更為止。</span><span class="sxs-lookup"><span data-stu-id="ff96e-110">The system preserves changes to the device context for the life of the window or until the application makes additional changes.</span></span>

<span data-ttu-id="ff96e-111">應用程式可以在建立視窗之後隨時使用 [**GetDC**](/windows/desktop/api/Winuser/nf-winuser-getdc) 函式，以取得私人裝置內容的控制碼。</span><span class="sxs-lookup"><span data-stu-id="ff96e-111">An application can retrieve a handle to the private device context by using the [**GetDC**](/windows/desktop/api/Winuser/nf-winuser-getdc) function any time after the window is created.</span></span> <span data-ttu-id="ff96e-112">應用程式必須只抓取一次控制碼。</span><span class="sxs-lookup"><span data-stu-id="ff96e-112">The application must retrieve the handle only once.</span></span> <span data-ttu-id="ff96e-113">之後，它可以保留並使用控制碼任意次數。</span><span class="sxs-lookup"><span data-stu-id="ff96e-113">Thereafter, it can keep and use the handle any number of times.</span></span> <span data-ttu-id="ff96e-114">因為私用裝置內容不是顯示裝置內容快取的一部分，所以應用程式不需要使用 [**ReleaseDC**](/windows/desktop/api/Winuser/nf-winuser-releasedc) 函式來釋放裝置內容。</span><span class="sxs-lookup"><span data-stu-id="ff96e-114">Because a private device context is not part of the display device context cache, an application need never release the device context by using the [**ReleaseDC**](/windows/desktop/api/Winuser/nf-winuser-releasedc) function.</span></span>

<span data-ttu-id="ff96e-115">系統會自動調整裝置內容，以反映視窗的變更，例如移動或調整大小。</span><span class="sxs-lookup"><span data-stu-id="ff96e-115">The system automatically adjusts the device context to reflect changes to the window, such as moving or sizing.</span></span> <span data-ttu-id="ff96e-116">這樣可確保所有重迭的視窗一律會正確地裁剪;也就是說，應用程式不需要採取任何動作來確保裁剪。</span><span class="sxs-lookup"><span data-stu-id="ff96e-116">This ensures that any overlapping windows are always properly clipped; that is, no action is required by the application to ensure clipping.</span></span> <span data-ttu-id="ff96e-117">不過，系統不會修改裝置內容以包含更新區域。</span><span class="sxs-lookup"><span data-stu-id="ff96e-117">However, the system does not revise the device context to include the update region.</span></span> <span data-ttu-id="ff96e-118">因此，在處理 [**WM \_ 油漆**](wm-paint.md) 訊息時，應用程式必須藉由呼叫 [**BeginPaint**](/windows/desktop/api/Winuser/nf-winuser-beginpaint) 或藉由抓取更新區域並與目前的裁剪區域交集，來併入更新區域。</span><span class="sxs-lookup"><span data-stu-id="ff96e-118">Therefore, when processing a [**WM\_PAINT**](wm-paint.md) message, the application must incorporate the update region either by calling [**BeginPaint**](/windows/desktop/api/Winuser/nf-winuser-beginpaint) or by retrieving the update region and intersecting it with the current clipping region.</span></span> <span data-ttu-id="ff96e-119">如果應用程式未呼叫 **BeginPaint**，則必須使用 [**ValidateRect**](/windows/desktop/api/Winuser/nf-winuser-validaterect) 或 [**ValidateRgn**](/windows/desktop/api/Winuser/nf-winuser-validatergn) 函數來明確驗證更新區域。</span><span class="sxs-lookup"><span data-stu-id="ff96e-119">If the application does not call **BeginPaint**, it must explicitly validate the update region by using the [**ValidateRect**](/windows/desktop/api/Winuser/nf-winuser-validaterect) or [**ValidateRgn**](/windows/desktop/api/Winuser/nf-winuser-validatergn) function.</span></span> <span data-ttu-id="ff96e-120">如果應用程式不會驗證更新區域，則視窗會收到一系列的一系列的 **WM \_ 油漆** 訊息。</span><span class="sxs-lookup"><span data-stu-id="ff96e-120">If the application does not validate the update region, the window receives an endless series of **WM\_PAINT** messages.</span></span>

<span data-ttu-id="ff96e-121">由於 [**BeginPaint**](/windows/desktop/api/Winuser/nf-winuser-beginpaint) 會在視窗顯示時隱藏插入號，因此呼叫 **BeginPaint** 的應用程式也應該呼叫 [**EndPaint**](/windows/desktop/api/Winuser/nf-winuser-endpaint) 函數來還原插入號。</span><span class="sxs-lookup"><span data-stu-id="ff96e-121">Because [**BeginPaint**](/windows/desktop/api/Winuser/nf-winuser-beginpaint) hides the caret if a window is showing it, an application that calls **BeginPaint** should also call the [**EndPaint**](/windows/desktop/api/Winuser/nf-winuser-endpaint) function to restore the caret.</span></span> <span data-ttu-id="ff96e-122">**EndPaint** 對私用裝置內容沒有任何其他效果。</span><span class="sxs-lookup"><span data-stu-id="ff96e-122">**EndPaint** has no other effect on a private device context.</span></span>

<span data-ttu-id="ff96e-123">雖然私用裝置內容很方便使用，但它在系統資源方面是記憶體密集的，需要儲存800或更多的位元組。</span><span class="sxs-lookup"><span data-stu-id="ff96e-123">Although a private device context is convenient to use, it is memory-intensive in terms of system resources, requiring 800 or more bytes to store.</span></span> <span data-ttu-id="ff96e-124">當效能考慮超過儲存體成本時，建議使用私用裝置內容。</span><span class="sxs-lookup"><span data-stu-id="ff96e-124">Private device contexts are recommended when performance considerations outweigh storage costs.</span></span>

<span data-ttu-id="ff96e-125">將 [**WM \_ ERASEBKGND**](../winmsg/wm-erasebkgnd.md) 訊息傳送至應用程式時，系統會包含私用裝置內容。</span><span class="sxs-lookup"><span data-stu-id="ff96e-125">The system includes the private device context when sending the [**WM\_ERASEBKGND**](../winmsg/wm-erasebkgnd.md) message to the application.</span></span> <span data-ttu-id="ff96e-126">當應用程式或系統處理這些訊息時，私用裝置內容的目前選取範圍（包括對應模式）會生效。</span><span class="sxs-lookup"><span data-stu-id="ff96e-126">The current selections of the private device context, including mapping mode, are in effect when the application or the system processes these messages.</span></span> <span data-ttu-id="ff96e-127">為了避免不適當的效果，系統會在清除背景時使用邏輯座標;例如，它會使用 [**GetClipBox**](/windows/desktop/api/Wingdi/nf-wingdi-getclipbox) 函式來取出要清除之區域的邏輯座標，並將這些座標傳遞給 [**FillRect**](/windows/desktop/api/Winuser/nf-winuser-fillrect) 函式。</span><span class="sxs-lookup"><span data-stu-id="ff96e-127">To avoid undesirable effects, the system uses logical coordinates when erasing the background; for example, it uses the [**GetClipBox**](/windows/desktop/api/Wingdi/nf-wingdi-getclipbox) function to retrieve the logical coordinates of the area to erase and passes these coordinates to the [**FillRect**](/windows/desktop/api/Winuser/nf-winuser-fillrect) function.</span></span> <span data-ttu-id="ff96e-128">處理這些訊息的應用程式可以使用類似的技術。</span><span class="sxs-lookup"><span data-stu-id="ff96e-128">Applications that process these messages can use similar techniques.</span></span>

<span data-ttu-id="ff96e-129">應用程式可以使用 [**GetDCEx**](/windows/desktop/api/Winuser/nf-winuser-getdcex) 函式來強制系統傳回具有私用裝置內容之視窗的一般裝置內容。</span><span class="sxs-lookup"><span data-stu-id="ff96e-129">An application can use the [**GetDCEx**](/windows/desktop/api/Winuser/nf-winuser-getdcex) function to force the system to return a common device context for the window that has a private device context.</span></span> <span data-ttu-id="ff96e-130">這有助於在不變更私用裝置內容的目前屬性值的情況下，對視窗執行快速觸控。</span><span class="sxs-lookup"><span data-stu-id="ff96e-130">This is useful for carrying out quick touch-ups to a window without changing the current values of the attributes of the private device context.</span></span>

 

 
