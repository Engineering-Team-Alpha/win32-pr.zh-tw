---
title: 在 DirectML 中繫結
description: 在 DirectML 中，系結指的是在初始化和執行機器學習運算子期間，要用於 GPU 的管線附加資源。
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: a04bf0bcc63fff810604e3db72fe507cc10040f5
ms.sourcegitcommit: db89157e3be911fdce2e543e99faa31fb2403bc8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2020
ms.locfileid: "104548398"
---
# <a name="binding-in-directml"></a><span data-ttu-id="33fde-103">在 DirectML 中繫結</span><span class="sxs-lookup"><span data-stu-id="33fde-103">Binding in DirectML</span></span>

<span data-ttu-id="33fde-104">在 DirectML 中 *，系* 結指的是在初始化和執行機器學習運算子期間，要用於 GPU 的管線附加資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-104">In DirectML, *binding* refers to the attachment of resources to the pipeline for the GPU to use during the initialization and execution of your machine learning operators.</span></span> <span data-ttu-id="33fde-105">例如，這些資源可以是輸入和輸出張量，以及操作員需要的任何暫存或持續性資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-105">These resources can be input and output tensors, for example, as well as any temporary or persistent resources that the operator needs.</span></span>

<span data-ttu-id="33fde-106">本主題將討論系結的概念和程式詳細資料。</span><span class="sxs-lookup"><span data-stu-id="33fde-106">This topic addresses the conceptual and procedural details of binding.</span></span> <span data-ttu-id="33fde-107">建議您也完整閱讀您所呼叫之 Api 的檔，包括參數和備註。</span><span class="sxs-lookup"><span data-stu-id="33fde-107">We recommend that you also fully read the documentation for the APIs that you call, including parameters and Remarks.</span></span>

## <a name="important-ideas-in-binding"></a><span data-ttu-id="33fde-108">系結中的重要概念</span><span class="sxs-lookup"><span data-stu-id="33fde-108">Important ideas in binding</span></span>

<span data-ttu-id="33fde-109">下列步驟清單包含系結相關工作的高階描述。</span><span class="sxs-lookup"><span data-stu-id="33fde-109">The list of steps below contain a high-level description of binding-related tasks.</span></span> <span data-ttu-id="33fde-110">每次執行[dispatchable](/windows/desktop/api/directml/nn-directml-idmldispatchable)時，您都必須遵循這些步驟， &mdash; dispatchable 是操作員初始化運算式或已編譯的運算子。</span><span class="sxs-lookup"><span data-stu-id="33fde-110">You need to follow these steps each time you execute a [dispatchable](/windows/desktop/api/directml/nn-directml-idmldispatchable)&mdash;a dispatchable is either an operator initializer or a compiled operator.</span></span> <span data-ttu-id="33fde-111">這些步驟會介紹 DirectML 系結所涉及的重要概念、結構和方法。</span><span class="sxs-lookup"><span data-stu-id="33fde-111">These steps introduce the important ideas, structures, and methods involved in DirectML binding.</span></span>

<span data-ttu-id="33fde-112">本主題的後續章節會更詳細地深入探討這些系結工作，並提供從 [最基本 DirectML 應用程式程式](dml-min-app.md) 代碼範例取得的說明程式碼片段。</span><span class="sxs-lookup"><span data-stu-id="33fde-112">Subsequent sections in this topic dig deeper and explain these binding tasks in more detail, with illustrative code snippets taken from the [minimal DirectML application](dml-min-app.md) code example.</span></span>

- <span data-ttu-id="33fde-113">在 dispatchable 上呼叫 [**IDMLDispatchable：： GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) ，以判斷它需要多少描述項，以及其暫存/持續性資源需求。</span><span class="sxs-lookup"><span data-stu-id="33fde-113">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) on the dispatchable to determine how many descriptors it needs, and also its temporary/persistent resource needs.</span></span>
- <span data-ttu-id="33fde-114">為描述項建立夠大的 Direct3D 12 描述元堆積，並將其系結至管線。</span><span class="sxs-lookup"><span data-stu-id="33fde-114">Create a Direct3D 12 descriptor heap large enough for the descriptors, and bind it to the pipeline.</span></span>
- <span data-ttu-id="33fde-115">呼叫 [**IDMLDevice：： CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) 來建立 DirectML 系結資料表，以代表系結至管線的資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-115">Call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create a DirectML binding table to represent the resources bound to the pipeline.</span></span> <span data-ttu-id="33fde-116">使用 [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) 結構來描述您的系結資料表，包括它在描述元堆積中指向之描述項的子集。</span><span class="sxs-lookup"><span data-stu-id="33fde-116">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the subset of the descriptors that it points to in the descriptor heap.</span></span>
- <span data-ttu-id="33fde-117">以 Direct3D 12 緩衝區資源的形式建立暫存/持續性資源，使用 [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) 和 [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) 結構來描述它們，然後將它們加入至系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-117">Create temporary/persistent resources as Direct3D 12 buffer resources, describe them with [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) and [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structures, and add them to the binding table.</span></span>
- <span data-ttu-id="33fde-118">如果 dispatchable 是已編譯的運算子，請建立 tensor 專案的緩衝區作為 Direct3D 12 緩衝區資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-118">If the dispatchable is a compiled operator, then create a buffer of tensor elements as a Direct3D 12 buffer resource.</span></span> <span data-ttu-id="33fde-119">填入/上傳它、使用 **DML_BUFFER_BINDING** 和 **DML_BINDING_DESC** 結構來描述它，然後將它加入至系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-119">Populate/upload it, describe it with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and add it to the binding table.</span></span>
- <span data-ttu-id="33fde-120">當您呼叫 [**IDMLCommandRecorder：： RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)時，將您的系結資料表當作參數傳遞。</span><span class="sxs-lookup"><span data-stu-id="33fde-120">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

## <a name="retrieve-the-binding-properties-of-a-dispatchable"></a><span data-ttu-id="33fde-121">取出 dispatchable 的系結屬性</span><span class="sxs-lookup"><span data-stu-id="33fde-121">Retrieve the binding properties of a dispatchable</span></span>

<span data-ttu-id="33fde-122">[**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties)結構描述 dispatchable (運算子初始化運算式或編譯的運算子) 的系結需求。</span><span class="sxs-lookup"><span data-stu-id="33fde-122">The [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) structure describes the binding needs of a dispatchable (operator initializer or compiled operator).</span></span> <span data-ttu-id="33fde-123">這些系結相關屬性包含您應系結至 dispatchable 的描述項數目，以及它所需的任何暫存和/或持續性資源的大小（以位元組為單位）。</span><span class="sxs-lookup"><span data-stu-id="33fde-123">These binding-related properties include the number of descriptors that you should bind to the dispatchable, as well as the size in bytes of any temporary and/or persistent resource that it needs.</span></span>

> [!NOTE]
> <span data-ttu-id="33fde-124">即使是相同類型的多個運算子，也請勿對具有相同系結需求的運算子進行假設。</span><span class="sxs-lookup"><span data-stu-id="33fde-124">Even for multiple operators of the same type, don't make assumptions about them having the same binding requirements.</span></span> <span data-ttu-id="33fde-125">查詢您所建立之每個初始化運算式和運算子的系結屬性。</span><span class="sxs-lookup"><span data-stu-id="33fde-125">Query the binding properties for every initializer and operator that you create.</span></span>

<span data-ttu-id="33fde-126">呼叫 [**IDMLDispatchable：： GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) 來取出 **DML_BINDING_PROPERTIES**。</span><span class="sxs-lookup"><span data-stu-id="33fde-126">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) to retrieve a **DML_BINDING_PROPERTIES**.</span></span>

```cppwinrt
winrt::com_ptr<::IDMLCompiledOperator> dmlCompiledOperator;
// Code to create and compile a DirectML operator goes here.

DML_BINDING_PROPERTIES executeDmlBindingProperties{
    dmlCompiledOperator->GetBindingProperties()
};

winrt::com_ptr<::IDMLOperatorInitializer> dmlOperatorInitializer;
// Code to create a DirectML operator initializer goes here.

DML_BINDING_PROPERTIES initializeDmlBindingProperties{
    dmlOperatorInitializer->GetBindingProperties()
};

UINT descriptorCount = ...
```

<span data-ttu-id="33fde-127">您在此處抓取的 `descriptorCount` 值會 (決定描述項堆積的大小下限，以及您在接下來的兩個步驟中所建立之系結資料表的) 大小下限。</span><span class="sxs-lookup"><span data-stu-id="33fde-127">The `descriptorCount` value that you retrieve here determines the (minimum) size of the descriptor heap and of the binding table that you create in the next two steps.</span></span>

<span data-ttu-id="33fde-128">**DML_BINDING_PROPERTIES** 也包含 `TemporaryResourceSize` 成員，這是暫存資源的大小下限（以位元組為單位），必須系結至這個 dispatchable 物件的系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-128">**DML_BINDING_PROPERTIES** also contains a `TemporaryResourceSize` member, which is the minimum size in bytes of the temporary resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="33fde-129">值為零表示不需要暫存資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-129">A value of zero means that a temporary resource is not required.</span></span>

<span data-ttu-id="33fde-130">以及 `PersistentResourceSize` 成員，這是持續性資源的最小大小（以位元組為單位），必須系結至這個 dispatchable 物件的系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-130">And a `PersistentResourceSize` member, which is the minimum size in bytes of the persistent resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="33fde-131">值為零表示不需要持續性資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-131">A value of zero means that a persistent resource is not required.</span></span> <span data-ttu-id="33fde-132">如果需要持續性資源，則必須在初始化編譯運算子期間提供持續性資源， (其系結為運算子初始化運算式的輸出) 和執行期間。</span><span class="sxs-lookup"><span data-stu-id="33fde-132">A persistent resource, if one is needed, must be supplied during initialization of a compiled operator (where it is bound as an output of the operator initializer) as well as during execution.</span></span> <span data-ttu-id="33fde-133">本主題稍後會有更多相關資訊。</span><span class="sxs-lookup"><span data-stu-id="33fde-133">There's more about this later in this topic.</span></span> <span data-ttu-id="33fde-134">只有編譯的運算子具有持續性資源，運算子初始化運算式一律會傳回這個成員的0值。</span><span class="sxs-lookup"><span data-stu-id="33fde-134">Only compiled operators have persistent resources—operator initializers always return a value of 0 for this member.</span></span>

<span data-ttu-id="33fde-135">如果您在呼叫 [**IDMLOperatorInitializer：： Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset)之前和之後呼叫運算子初始化運算式上的 **IDMLDispatchable：： GetBindingProperties** ，就不保證會將兩組系結屬性視為相同。</span><span class="sxs-lookup"><span data-stu-id="33fde-135">If you call **IDMLDispatchable::GetBindingProperties** on an operator initializer both before and after a call to [**IDMLOperatorInitializer::Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), then the two sets of binding properties retrieved are not guaranteed to be identical.</span></span>

## <a name="describe-create-and-bind-a-descriptor-heap"></a><span data-ttu-id="33fde-136">描述、建立和系結描述項堆積</span><span class="sxs-lookup"><span data-stu-id="33fde-136">Describe, create, and bind a descriptor heap</span></span>

<span data-ttu-id="33fde-137">就描述項而言，您的責任會以描述項堆積本身為開頭和結尾。</span><span class="sxs-lookup"><span data-stu-id="33fde-137">In terms of descriptors, your responsibility begins and ends with the descriptor heap itself.</span></span> <span data-ttu-id="33fde-138">DirectML 本身會負責建立及管理您所提供之堆積內的描述項。</span><span class="sxs-lookup"><span data-stu-id="33fde-138">DirectML itself takes care of creating and managing the descriptors inside of the heap that you provide.</span></span>

<span data-ttu-id="33fde-139">因此，請使用 [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) 結構來描述已夠大的堆積，以滿足 dispatchable 所需的描述項數目。</span><span class="sxs-lookup"><span data-stu-id="33fde-139">So, use a [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) structure to describe a heap large enough for the number of descriptors that the dispatchable needs.</span></span> <span data-ttu-id="33fde-140">然後使用 [**ID3D12Device：： CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap)來建立它。</span><span class="sxs-lookup"><span data-stu-id="33fde-140">Then create it with [**ID3D12Device::CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span></span> <span data-ttu-id="33fde-141">最後，呼叫 [**ID3D12GraphicsCommandList：： SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) ，將描述元堆積系結至管線。</span><span class="sxs-lookup"><span data-stu-id="33fde-141">And, lastly, call [**ID3D12GraphicsCommandList::SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) to bind your descriptor heap to the pipeline.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12DescriptorHeap> d3D12DescriptorHeap;

D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDescription{};
descriptorHeapDescription.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
descriptorHeapDescription.NumDescriptors = descriptorCount;
descriptorHeapDescription.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

winrt::check_hresult(
    d3D12Device->CreateDescriptorHeap(
        &descriptorHeapDescription,
        _uuidof(d3D12DescriptorHeap),
        d3D12DescriptorHeap.put_void()
    )
);

std::array<ID3D12DescriptorHeap*, 1> d3D12DescriptorHeaps{ d3D12DescriptorHeap.get() };
d3D12GraphicsCommandList->SetDescriptorHeaps(
    static_cast<UINT>(d3D12DescriptorHeaps.size()),
    d3D12DescriptorHeaps.data()
);
```

## <a name="describe-and-create-a-binding-table"></a><span data-ttu-id="33fde-142">描述並建立系結資料表</span><span class="sxs-lookup"><span data-stu-id="33fde-142">Describe and create a binding table</span></span>

<span data-ttu-id="33fde-143">DirectML 系結表代表您系結至管線以供 dispatchable 使用的資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-143">A DirectML binding table represents the resources that you bind to the pipeline for a dispatchable to use.</span></span> <span data-ttu-id="33fde-144">這些資源可以是輸入和輸出張量 (或針對操作員) 的其他參數，也可以是 dispatchable 可搭配使用的各種持續性和暫存資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-144">Those resources could be input and output tensors (or other parameters) for an operator, or they could be various persistent and temporary resources that a dispatchable works with.</span></span>

<span data-ttu-id="33fde-145">使用 [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) 結構來描述您的系結資料表，包括系結資料表將代表系結的 dispatchable，以及從您剛才建立的描述元堆積 (的描述項範圍，) 您希望系結資料表參考 (，以及 DirectML 可能寫入描述項) 。</span><span class="sxs-lookup"><span data-stu-id="33fde-145">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the dispatchable for which the binding table will represent the bindings, and the range of descriptors (from the descriptor heap that you just created) that you wish the binding table to refer to (and into which DirectML may write descriptors).</span></span> <span data-ttu-id="33fde-146">`descriptorCount`值 (我們在第一個步驟中取得的其中一個系結屬性，) 告訴我們 dispatchable 物件所需之系結資料表的最小大小。</span><span class="sxs-lookup"><span data-stu-id="33fde-146">The `descriptorCount` value (one of the binding properties that we retrieved in the first step) tells us what minimum size is, in descriptors, of the binding table required for the dispatchable object.</span></span> <span data-ttu-id="33fde-147">在這裡，我們會使用該值來指出從提供的 CPU 和 GPU 描述項控制碼的開頭，DirectML 可寫入至堆積的最大描述項數目上限。</span><span class="sxs-lookup"><span data-stu-id="33fde-147">Here, we use that value to indicate the maximum number of descriptors that DirectML is permitted to write into our heap, from the start of both the supplied CPU and GPU descriptor handles.</span></span>

<span data-ttu-id="33fde-148">然後呼叫 [**IDMLDevice：： CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) 來建立 DirectML 系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-148">Then call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create the DirectML binding table.</span></span> <span data-ttu-id="33fde-149">在稍後的步驟中，我們為 dispatchable 建立了更多資源之後，我們會將這些資源新增至系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-149">In later steps, after we've created further resources for the dispatchable, we'll add those resources to the binding table.</span></span>

<span data-ttu-id="33fde-150">您可以傳遞，表示空的系結表，而不是將 **DML_BINDING_TABLE_DESC** 傳遞給這個呼叫 `nullptr` 。</span><span class="sxs-lookup"><span data-stu-id="33fde-150">Instead of passing a **DML_BINDING_TABLE_DESC** to this call, you can pass `nullptr`, indicating an empty binding table.</span></span>

```cppwinrt
DML_BINDING_TABLE_DESC dmlBindingTableDesc{};
dmlBindingTableDesc.Dispatchable = dmlOperatorInitializer.get();
dmlBindingTableDesc.CPUDescriptorHandle = d3D12DescriptorHeap->GetCPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.GPUDescriptorHandle = d3D12DescriptorHeap->GetGPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.SizeInDescriptors = descriptorCount;

winrt::com_ptr<::IDMLBindingTable> dmlBindingTable;
winrt::check_hresult(
    dmlDevice->CreateBindingTable(
        &dmlBindingTableDesc,
        __uuidof(dmlBindingTable),
        dmlBindingTable.put_void()
    )
);
```

<span data-ttu-id="33fde-151">DirectML 將描述元寫入堆積的順序並未指定，因此您的應用程式必須小心不要覆寫系結資料表所包裝的描述項。</span><span class="sxs-lookup"><span data-stu-id="33fde-151">The order in which DirectML writes descriptors into the heap is unspecified, so your application must take care not to overwrite the descriptors wrapped by the binding table.</span></span> <span data-ttu-id="33fde-152">提供的 CPU 和 GPU 描述項控制碼可能來自不同的堆積，不過，您的應用程式會負責確保 CPU 描述項控制碼所參考的整個描述元範圍，在執行之前，會使用此系結表複製到 GPU 描述控制碼所參考的範圍。</span><span class="sxs-lookup"><span data-stu-id="33fde-152">The supplied CPU and GPU descriptor handles may come from different heaps, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span> <span data-ttu-id="33fde-153">提供控制碼的描述元堆積必須具有類型 **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**。</span><span class="sxs-lookup"><span data-stu-id="33fde-153">The descriptor heap from which the handles are supplied must have type **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span></span> <span data-ttu-id="33fde-154">此外，所參考的堆積 `GPUDescriptorHandle` 必須是著色器可見的描述元堆積。</span><span class="sxs-lookup"><span data-stu-id="33fde-154">Additionally, the heap referred to by the `GPUDescriptorHandle` must be a shader-visible descriptor heap.</span></span>

<span data-ttu-id="33fde-155">您可以重設系結資料表來移除您已新增至其中的任何資源，同時變更您在初始 **DML_BINDING_TABLE_DESC** (設定的任何屬性，以包裝新的描述項範圍，或針對不同的 dispatchable) 重複使用它。</span><span class="sxs-lookup"><span data-stu-id="33fde-155">You can reset a binding table to remove any resources that you've added to it, while at the same time changing any property that you set on its initial **DML_BINDING_TABLE_DESC** (to wrap a new range of descriptors, or to re-use it for a different dispatchable).</span></span> <span data-ttu-id="33fde-156">您只需對 description 結構進行變更，然後呼叫 [**IDMLBindingTable：： Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset)。</span><span class="sxs-lookup"><span data-stu-id="33fde-156">Just make the changes to the description structure, and call [**IDMLBindingTable::Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span></span>

```cppwinrt
dmlBindingTableDesc.Dispatchable = pIDMLCompiledOperator.get();

winrt::check_hresult(
    pIDMLBindingTable->Reset(
        &dmlBindingTableDesc
    )
);
```

## <a name="describe-and-bind-any-temporarypersistent-resources"></a><span data-ttu-id="33fde-157">描述及系結任何暫存/持續性資源</span><span class="sxs-lookup"><span data-stu-id="33fde-157">Describe and bind any temporary/persistent resources</span></span>

<span data-ttu-id="33fde-158">我們在抓取 dispatchable 的系結 [屬性](#retrieve-the-binding-properties-of-a-dispatchable)時，所填入的 **DML_BINDING_PROPERTIES** 結構包含 dispatchable 所需的任何暫存和/或持續性資源的大小（以位元組為單位）。</span><span class="sxs-lookup"><span data-stu-id="33fde-158">The **DML_BINDING_PROPERTIES** structure that we populated when we [retrieved the binding properties](#retrieve-the-binding-properties-of-a-dispatchable) of our dispatchable contains the size in bytes of any temporary and/or persistent resource that the dispatchable needs.</span></span> <span data-ttu-id="33fde-159">如果其中一種大小不是零，則請建立 Direct3D 12 緩衝區資源，並將它加入至系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-159">If either of these sizes is non-zero, then create a Direct3D 12 buffer resource and add it to the binding table.</span></span>

<span data-ttu-id="33fde-160">在下列程式碼範例中，我們會建立 `temporaryResourceSize` dispatchable 大小) 的暫存資源 (位元組。</span><span class="sxs-lookup"><span data-stu-id="33fde-160">In the code example below, we create a temporary resource (`temporaryResourceSize` bytes in size) for the dispatchable.</span></span> <span data-ttu-id="33fde-161">我們會說明要如何系結資源，然後再將該系結新增至系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-161">We describe how we wish to bind the resource, and then we add that binding to the binding table.</span></span>

<span data-ttu-id="33fde-162">因為我們要系結單一緩衝區資源，所以我們會使用 [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) 結構來描述系結。</span><span class="sxs-lookup"><span data-stu-id="33fde-162">Since we're binding a single buffer resource, we describe our binding with a [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) structure.</span></span> <span data-ttu-id="33fde-163">在該結構中，我們會指定 Direct3D 12 緩衝區資源 (資源必須有 [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)) 的維度，以及緩衝區中的位移和大小。</span><span class="sxs-lookup"><span data-stu-id="33fde-163">In that structure, we specify the Direct3D 12 buffer resource (the resource must have dimension [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)), as well as an offset-and-size into the buffer.</span></span> <span data-ttu-id="33fde-164">您也可以描述緩衝區陣列的系結 (而不是單一緩衝區) 的系結，而且該用途有 [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) 結構。</span><span class="sxs-lookup"><span data-stu-id="33fde-164">It's also possible to describe a binding for an array of buffers (rather than for a single buffer), and the [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) structure exists for that purpose.</span></span>

<span data-ttu-id="33fde-165">為了抽象化緩衝區系結與緩衝區陣列系結之間的差異，我們使用  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) 結構。</span><span class="sxs-lookup"><span data-stu-id="33fde-165">To abstract away the distinction between a buffer binding and a buffer array binding, we use the  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structure.</span></span> <span data-ttu-id="33fde-166">您可以將 `Type` **DML_BINDING_DESC** 的成員設定為 [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) 或 **DML_BINDING_TYPE_BUFFER_ARRAY**。</span><span class="sxs-lookup"><span data-stu-id="33fde-166">You can set the `Type` member of the **DML_BINDING_DESC** to either [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) or **DML_BINDING_TYPE_BUFFER_ARRAY**.</span></span> <span data-ttu-id="33fde-167">然後，您可以設定 `Desc` 成員指向 **DML_BUFFER_BINDING** 或 **DML_BUFFER_ARRAY_BINDING**，取決於 `Type` 。</span><span class="sxs-lookup"><span data-stu-id="33fde-167">And you can then set the `Desc` member to point to either a **DML_BUFFER_BINDING** or to a **DML_BUFFER_ARRAY_BINDING**, depending on `Type`.</span></span>

<span data-ttu-id="33fde-168">我們正在處理此範例中的暫存資源，因此我們會呼叫 [**IDMLBindingTable：： BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource)，將它新增至系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-168">We're dealing with the temporary resource in this example, so we add it to the binding table with a call to [**IDMLBindingTable::BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span></span>

```cppwinrt
D3D12_HEAP_PROPERTIES defaultHeapProperties{ CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT) };
winrt::com_ptr<::ID3D12Resource> temporaryBuffer;

D3D12_RESOURCE_DESC temporaryBufferDesc{ CD3DX12_RESOURCE_DESC::Buffer(temporaryResourceSize) };
winrt::check_hresult(
    d3D12Device->CreateCommittedResource(
        &defaultHeapProperties,
        D3D12_HEAP_FLAG_NONE,
        &temporaryBufferDesc,
        D3D12_RESOURCE_STATE_COMMON,
        nullptr,
        __uuidof(temporaryBuffer),
        temporaryBuffer.put_void()
    )
);

DML_BUFFER_BINDING bufferBinding{ temporaryBuffer.get(), 0, temporaryResourceSize };
DML_BINDING_DESC bindingDesc{ DML_BINDING_TYPE_BUFFER, &bufferBinding };
dmlBindingTable->BindTemporaryResource(&bindingDesc);
```

<span data-ttu-id="33fde-169">暫存資源 (如果需要的話) 是在執行運算子期間于內部使用的臨時記憶體，因此您不需要擔心其內容。</span><span class="sxs-lookup"><span data-stu-id="33fde-169">A temporary resource (if one is needed) is scratch memory that's used internally during the execution of the operator, so you don't need to be concerned with its contents.</span></span> <span data-ttu-id="33fde-170">您也必須在 GPU 上的 [**IDMLCommandRecorder：： RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) 呼叫完成之後，再繼續進行。</span><span class="sxs-lookup"><span data-stu-id="33fde-170">Nor do you need to keep it around after your call to [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) has completed on the GPU.</span></span> <span data-ttu-id="33fde-171">這表示您的應用程式可能會在已編譯運算子的分派之間釋放或覆寫暫存資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-171">This means that your application may release or overwrite the temporary resource in between dispatches of the compiled operator.</span></span> <span data-ttu-id="33fde-172">所提供要系結為暫存資源的緩衝區範圍，其起始位移必須與 [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md)一致。</span><span class="sxs-lookup"><span data-stu-id="33fde-172">The supplied buffer range to be bound as the temporary resource must have its start offset aligned to [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="33fde-173">緩衝區基礎的堆積型別必須是 **D3D12_HEAP_TYPE_DEFAULT**。</span><span class="sxs-lookup"><span data-stu-id="33fde-173">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

<span data-ttu-id="33fde-174">但是，如果 dispatchable 針對其較長時間持續的資源報告非零的大小，則程式會稍有不同。</span><span class="sxs-lookup"><span data-stu-id="33fde-174">If the dispatchable reports a non-zero size for its more long-lived persistent resource, though, then the procedure is a little different.</span></span> <span data-ttu-id="33fde-175">您應建立緩衝區，並依照上面所示的相同模式來描述系結。</span><span class="sxs-lookup"><span data-stu-id="33fde-175">You should create a buffer and describe a binding following the same pattern as shown above.</span></span> <span data-ttu-id="33fde-176">但是，您可以呼叫 [**IDMLBindingTable：： BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs)，將它加入操作員初始化運算式的系結表，因為這是運算子初始化運算式的作業，可將持續性資源初始化。</span><span class="sxs-lookup"><span data-stu-id="33fde-176">But add it to your operator initializer's binding table with a call to [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), because it's the operator initializer's job to initialize the persistent resource.</span></span> <span data-ttu-id="33fde-177">然後使用 [**IDMLBindingTable：： BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource)的呼叫，將它新增至已編譯運算子的系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-177">Then add it to your compiled operator's binding table with a call to [**IDMLBindingTable::BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span></span> <span data-ttu-id="33fde-178">請參閱 [最基本的 DirectML 應用程式程式](dml-min-app.md) 代碼範例，以查看此工作流程的實際運作情形。</span><span class="sxs-lookup"><span data-stu-id="33fde-178">See the [minimal DirectML application](dml-min-app.md) code example to see this workflow in action.</span></span> <span data-ttu-id="33fde-179">持續性資源的內容和存留期必須保存，只要經過編譯的運算子就能完成。</span><span class="sxs-lookup"><span data-stu-id="33fde-179">The persistent resource's contents and lifetime must persist as long as the compiled operator does.</span></span> <span data-ttu-id="33fde-180">亦即，如果操作員需要持續性資源，則您的應用程式必須在初始化期間提供它，然後再將其提供給運算子的所有未來執行，而不需要修改其內容。</span><span class="sxs-lookup"><span data-stu-id="33fde-180">That is, if an operator requires a persistent resource, then your application must supply it during initialization and subsequently also supply it to all future executes of the operator without modifying its contents.</span></span> <span data-ttu-id="33fde-181">DirectML 通常會使用持續性資源來儲存查閱資料表或其他長期存留的資料，這些資料會在初始化操作員時計算，並在該運算子的未來執行時重複使用。</span><span class="sxs-lookup"><span data-stu-id="33fde-181">The persistent resource is typically used by DirectML to store lookup tables or other long-lived data that is computed during initialization of an operator and reused on future executions of that operator.</span></span> <span data-ttu-id="33fde-182">要系結的所提供緩衝區範圍必須與 [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md)的起始位移相符。</span><span class="sxs-lookup"><span data-stu-id="33fde-182">The supplied buffer range to be bound as the persistent buffer must have its start offset aligned to [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="33fde-183">緩衝區基礎的堆積型別必須是 **D3D12_HEAP_TYPE_DEFAULT**。</span><span class="sxs-lookup"><span data-stu-id="33fde-183">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

## <a name="describe-and-bind-any-tensors"></a><span data-ttu-id="33fde-184">描述及系結任何張量</span><span class="sxs-lookup"><span data-stu-id="33fde-184">Describe and bind any tensors</span></span>

<span data-ttu-id="33fde-185">如果您要處理編譯的運算子 (而不是使用運算子初始化運算式) ，則您需要將輸入和輸出資源 (系結至運算子的系結資料表) 的張量和其他參數。</span><span class="sxs-lookup"><span data-stu-id="33fde-185">If you're dealing with a compiled operator (rather than with an operator initializer), then you need to bind input and output resources (for tensors and other parameters) to the operator's binding table.</span></span> <span data-ttu-id="33fde-186">系結數目必須完全符合運算子的輸入數目，包括選擇性的張量。</span><span class="sxs-lookup"><span data-stu-id="33fde-186">The number of bindings must exactly match the number of inputs of the operator, including optional tensors.</span></span> <span data-ttu-id="33fde-187">運算子所採用的特定輸入和輸出張量和其他參數，會記載于該運算子的主題 (例如 [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)) 。</span><span class="sxs-lookup"><span data-stu-id="33fde-187">The particular input and output tensors and other parameters that an operator takes are documented in the topic for that operator (for example, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span></span>

<span data-ttu-id="33fde-188">Tensor 資源是一個緩衝區，其中包含 tensor 的個別元素值。</span><span class="sxs-lookup"><span data-stu-id="33fde-188">A tensor resource is a buffer that contains the individual element values of the tensor.</span></span> <span data-ttu-id="33fde-189">您可以使用一般的 Direct3D 12 技巧，在 GPU 上傳和讀回這類緩衝區， ([上傳資源](/windows/desktop/direct3d12/uploading-resources) 並透過 [緩衝區) 讀回資料](/windows/desktop/direct3d12/readback-data-using-heaps) 。</span><span class="sxs-lookup"><span data-stu-id="33fde-189">You upload and read back such a buffer to/from the GPU using the regular Direct3D 12 techniques ([Upload resources](/windows/desktop/direct3d12/uploading-resources) and [Read back data via a buffer](/windows/desktop/direct3d12/readback-data-using-heaps)).</span></span> <span data-ttu-id="33fde-190">請參閱 [最基本的 DirectML 應用程式程式](dml-min-app.md) 代碼範例，以瞭解這些技術的實際運作方式。</span><span class="sxs-lookup"><span data-stu-id="33fde-190">See the [minimal DirectML application](dml-min-app.md) code example to see these techniques in action.</span></span>

<span data-ttu-id="33fde-191">最後，使用 **DML_BUFFER_BINDING** 和 **DML_BINDING_DESC** 結構來描述您的輸入和輸出資源系結，然後使用 [**IDMLBindingTable：： BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) 和 [**IDMLBindingTable：： BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs)的呼叫，將它們新增至已編譯運算子的系結資料表。</span><span class="sxs-lookup"><span data-stu-id="33fde-191">Lastly, describe your input and output resource bindings with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and then add them to the compiled operator's binding table with calls to [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span> <span data-ttu-id="33fde-192">當您呼叫 \**IDMLBindingTable：： Bind \** _ 方法時，DirectML 會將一個或多個描述元寫入至 CPU 描述項的範圍。</span><span class="sxs-lookup"><span data-stu-id="33fde-192">When you call an \**IDMLBindingTable::Bind\** _ method, DirectML writes one or more descriptors into the range of CPU descriptors.</span></span>

```cppwinrt
DML_BUFFER_BINDING inputBufferBinding{ inputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC inputBindingDesc{ DML_BINDING_TYPE_BUFFER, &inputBufferBinding };
dmlBindingTable->BindInputs(1, &inputBindingDesc);

DML_BUFFER_BINDING outputBufferBinding{ outputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC outputBindingDesc{ DML_BINDING_TYPE_BUFFER, &outputBufferBinding };
dmlBindingTable->BindOutputs(1, &outputBindingDesc);
```

<span data-ttu-id="33fde-193">建立 DirectML 運算子的其中一個步驟 (請參閱 [_ *IDMLDevice：： CreateOperator* \*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) 是宣告一或多個 [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc)結構，以描述該運算子所採用和傳回的 TENSOR 資料緩衝區。</span><span class="sxs-lookup"><span data-stu-id="33fde-193">One of the steps in creating a DirectML operator (see [_ *IDMLDevice::CreateOperator*\*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) is to declare one or more [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) structures to describe the tensor data buffers that the operator takes and returns.</span></span> <span data-ttu-id="33fde-194">您也可以選擇性地指定 [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) 旗標，以及 tensor 緩衝區的型別和大小。</span><span class="sxs-lookup"><span data-stu-id="33fde-194">As well as the tensor buffer's type and size, you can optionally specify the [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) flag.</span></span>

<span data-ttu-id="33fde-195">**DML_TENSOR_FLAG_OWNED_BY_DML** 表示 TENSOR 資料應該由 DirectML 擁有及管理。</span><span class="sxs-lookup"><span data-stu-id="33fde-195">**DML_TENSOR_FLAG_OWNED_BY_DML** indicates that the tensor data should be owned and managed by DirectML.</span></span> <span data-ttu-id="33fde-196">DirectML 會在運算子的初始化期間建立 tensor 資料的複本，並將它儲存在持續性資源中。</span><span class="sxs-lookup"><span data-stu-id="33fde-196">DirectML makes a copy of the tensor data during initialization of the operator, and stores it in the persistent resource.</span></span> <span data-ttu-id="33fde-197">這可讓 DirectML 將 tensor 資料的重新格式化為其他、更有效率的表單。</span><span class="sxs-lookup"><span data-stu-id="33fde-197">This allows DirectML to perform reformatting of the tensor data into other, more efficient forms.</span></span> <span data-ttu-id="33fde-198">設定此旗標可能會提高效能，但它通常只適用于張量 (運算子存留期不會變更的資料，例如權數張量) 。</span><span class="sxs-lookup"><span data-stu-id="33fde-198">Setting this flag may increase performance, but it's typically only useful for tensors whose data doesn't change for the lifetime of the operator (for example, weight tensors).</span></span> <span data-ttu-id="33fde-199">而且旗標只可用於輸入張量。</span><span class="sxs-lookup"><span data-stu-id="33fde-199">And the flag may only be used on input tensors.</span></span> <span data-ttu-id="33fde-200">在特定 tensor 描述上設定旗標時，對應的 tensor 必須系結至運算子初始化期間的系結表，而不是在執行期間執行 (這會導致錯誤) 。</span><span class="sxs-lookup"><span data-stu-id="33fde-200">When the flag is set on a particular tensor description, the corresponding tensor must be bound to the binding table during operator initialization, and not during execution (which will result in an error).</span></span> <span data-ttu-id="33fde-201">這與預設行為相反， (沒有 DML_TENSOR_FLAG_OWNED_BY_DML 旗標) 的行為，其中 TENSOR 預期會在執行期間系結，而不會在初始化期間進行系結。</span><span class="sxs-lookup"><span data-stu-id="33fde-201">That's the opposite of the default behavior (the behavior without the DML_TENSOR_FLAG_OWNED_BY_DML flag), where the tensor is expected to be bound during execution, and not during initialization.</span></span> <span data-ttu-id="33fde-202">當您將 tensor 資料提供給運算子初始化運算式時，系結上傳（而非預設堆積）是合法的，因為 DirectML 會建立資料的複本。</span><span class="sxs-lookup"><span data-stu-id="33fde-202">When you supply the tensor data to an operator initializer, it's legal to bind an UPLOAD rather than a DEFAULT heap, because DirectML makes a copy of the data.</span></span> <span data-ttu-id="33fde-203">在所有其他情況下，系結至 DirectML 的所有資源都必須是預設堆積資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-203">In all other cases, all resources bound to DirectML must be DEFAULT heap resources.</span></span>

<span data-ttu-id="33fde-204">如需詳細資訊，請參閱 [**IDMLBindingTable：： BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) 和 [**IDMLBindingTable：： BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs)。</span><span class="sxs-lookup"><span data-stu-id="33fde-204">For more info, see [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span>

## <a name="execute-the-dispatchable"></a><span data-ttu-id="33fde-205">執行 dispatchable</span><span class="sxs-lookup"><span data-stu-id="33fde-205">Execute the dispatchable</span></span>

<span data-ttu-id="33fde-206">當您呼叫 [**IDMLCommandRecorder：： RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)時，將您的系結資料表當作參數傳遞。</span><span class="sxs-lookup"><span data-stu-id="33fde-206">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

<span data-ttu-id="33fde-207">當您在呼叫 **IDMLCommandRecorder：： RecordDispatch** 期間使用系結資料表時，DirectML 會將對應的 GPU 描述元系結至管線。</span><span class="sxs-lookup"><span data-stu-id="33fde-207">When you use the binding table during a call to **IDMLCommandRecorder::RecordDispatch**, DirectML binds the corresponding GPU descriptors to the pipeline.</span></span> <span data-ttu-id="33fde-208">CPU 和 GPU 描述項控制碼不需要指向描述項堆積中的相同專案，不過您的應用程式會負責確保 CPU 描述項控制碼所參考的整個描述元範圍，在執行之前，會使用此系結表複製到 GPU 描述控制碼所參考的範圍。</span><span class="sxs-lookup"><span data-stu-id="33fde-208">The CPU and GPU descriptor handles aren't required to point to the same entries in a descriptor heap, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12GraphicsCommandList> d3D12GraphicsCommandList;
// Code to create a Direct3D 12 command list goes here.

winrt::com_ptr<::IDMLCommandRecorder> dmlCommandRecorder;
// Code to create a DirectML command recorder goes here.

dmlCommandRecorder->RecordDispatch(
    d3D12GraphicsCommandList.get(),
    dmlOperatorInitializer.get(),
    dmlBindingTable.get()
);
```

<span data-ttu-id="33fde-209">最後，關閉您的 Direct3D 12 命令清單，然後提交以供執行，就像任何其他命令清單一樣。</span><span class="sxs-lookup"><span data-stu-id="33fde-209">Finally, close your Direct3D 12 command list, and submit it for execution as you would any other command list.</span></span>

<span data-ttu-id="33fde-210">在 GPU 上執行 **RecordDispatch** 之前，您必須將所有的系結資源轉換為 **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** 狀態，或轉換成可隱含提升為 **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** 的狀態，例如 **D3D12_RESOURCE_STATE_COMMON**。</span><span class="sxs-lookup"><span data-stu-id="33fde-210">Prior to execution of **RecordDispatch** on the GPU, you must transition all bound resources to the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state, or to a state implicitly promotable to **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, such as **D3D12_RESOURCE_STATE_COMMON**.</span></span> <span data-ttu-id="33fde-211">此呼叫完成後，資源會維持 **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** 狀態。</span><span class="sxs-lookup"><span data-stu-id="33fde-211">After this call completes, the resources remain in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state.</span></span> <span data-ttu-id="33fde-212">唯一的例外是在執行運算子初始化運算式時所系結的上傳堆積，以及一或多個張量已設定 **DML_TENSOR_FLAG_OWNED_BY_DML** 旗標。</span><span class="sxs-lookup"><span data-stu-id="33fde-212">The only exception to this is for upload heaps bound when executing an operator initializer and while one or more tensors has the **DML_TENSOR_FLAG_OWNED_BY_DML** flag set.</span></span> <span data-ttu-id="33fde-213">在這種情況下，任何針對輸入系結的上傳堆積都必須處於 **D3D12_RESOURCE_STATE_GENERIC_READ** 狀態，而且會維持在該狀態中，如所有上傳堆積的要求。</span><span class="sxs-lookup"><span data-stu-id="33fde-213">In that case, any upload heaps bound for input must be in the **D3D12_RESOURCE_STATE_GENERIC_READ** state and will remain in that state, as required by all upload heaps.</span></span> <span data-ttu-id="33fde-214">如果在編譯運算子時未設定 **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** ，則在呼叫 **RecordDispatch** 之前，必須在系結資料表上設定所有系結，否則行為是未定義的。</span><span class="sxs-lookup"><span data-stu-id="33fde-214">If **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** was not set when compiling the operator, then all bindings must be set on the binding table before **RecordDispatch** is called, otherwise the behavior is undefined.</span></span> <span data-ttu-id="33fde-215">否則，如果操作員支援 [晚期繫結](#optionally-specify-late-bound-operator-bindings)，則可能會延遲資源的系結，直到將 Direct3D 12 命令清單提交到命令佇列以供執行為止。</span><span class="sxs-lookup"><span data-stu-id="33fde-215">Otherwise, if an operator supports [late binding](#optionally-specify-late-bound-operator-bindings), then binding of resources may be deferred until the Direct3D 12 command list is submitted to the command queue for execution.</span></span>

<span data-ttu-id="33fde-216">**RecordDispatch** 的作用就像是呼叫 [**ID3D12GraphicsCommandList：:D ispatch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch)。</span><span class="sxs-lookup"><span data-stu-id="33fde-216">**RecordDispatch** acts logically like a call to [**ID3D12GraphicsCommandList::Dispatch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span></span> <span data-ttu-id="33fde-217">因此，如果分派之間有資料相依性，則需要 (UAV) 阻礙的未排序存取權，以確保正確的順序。</span><span class="sxs-lookup"><span data-stu-id="33fde-217">As such, unordered access view (UAV) barriers are necessary to ensure correct ordering if there are data dependencies between dispatches.</span></span> <span data-ttu-id="33fde-218">這個方法不會在輸入或輸出資源上插入 UAV 障礙。</span><span class="sxs-lookup"><span data-stu-id="33fde-218">This method does not insert UAV barriers on input nor output resources.</span></span> <span data-ttu-id="33fde-219">您的應用程式必須確保在任何輸入上都執行正確的 UAV 障礙（如果其內容相依于上游分派），以及在任何輸出上有相依于這些輸出的下游分派時執行。</span><span class="sxs-lookup"><span data-stu-id="33fde-219">Your application must ensure that the correct UAV barriers are performed on any inputs if their contents depend on an upstream dispatch, and on any outputs if there are downstream dispatches that depend on those outputs.</span></span>

## <a name="lifetime-and-synchronization-of-descriptors-and-binding-table"></a><span data-ttu-id="33fde-220">描述元和系結資料表的存留期和同步處理</span><span class="sxs-lookup"><span data-stu-id="33fde-220">Lifetime and synchronization of descriptors and binding table</span></span>

<span data-ttu-id="33fde-221">DirectML 中系結的良好觀念是在幕後，DirectML 系結資料表本身是在您提供的描述元堆積內建立和管理未排序的存取權 (UAV 的) 描述項。</span><span class="sxs-lookup"><span data-stu-id="33fde-221">A good mental model of binding in DirectML is that behind the scenes the DirectML binding table itself is creating and managing unordered access view (UAV) descriptors inside the descriptor heap that you provide.</span></span> <span data-ttu-id="33fde-222">因此，所有常用的 Direct3D 12 規則都適用于同步處理該堆積的存取權，以及其描述項。</span><span class="sxs-lookup"><span data-stu-id="33fde-222">So, all of the usual Direct3D 12 rules apply around synchronizing access to that heap and to its descriptors.</span></span> <span data-ttu-id="33fde-223">您的應用程式必須負責在使用系結資料表的 CPU 和 GPU 工作之間執行正確的同步處理。</span><span class="sxs-lookup"><span data-stu-id="33fde-223">It's your application's responsibility to perform correct synchronization between the CPU and GPU work that uses a binding table.</span></span>

<span data-ttu-id="33fde-224">在先前的框架 (使用描述元時，系結資料表無法覆寫描述項，例如) 。</span><span class="sxs-lookup"><span data-stu-id="33fde-224">A binding table can't overwrite a descriptor while the descriptor is in use (by a prior frame, for example).</span></span> <span data-ttu-id="33fde-225">因此，如果您想要重複使用已系結的描述元堆積 (例如，藉由在指向它的系結表上再次呼叫 Bind \*，或是以手動方式覆寫描述元堆積) ，您應該等候目前使用描述元堆積的 dispatchable 完成 GPU 上的執行。</span><span class="sxs-lookup"><span data-stu-id="33fde-225">So, if you want to reuse an already-bound descriptor heap (for example, by calling Bind\* again on a binding table that points to it, or by overwriting the descriptor heap manually), then you should wait for the dispatchable that's currently using the descriptor heap to finish executing on the GPU.</span></span> <span data-ttu-id="33fde-226">系結資料表不會在其所寫入的描述元堆積上維護強式參考，因此您不得釋放支援著色器可見的描述元堆積，直到使用該系結資料表的所有工作都已在 GPU 上完成執行為止。</span><span class="sxs-lookup"><span data-stu-id="33fde-226">A binding table doesn't maintain a strong reference on the descriptor heap that it writes into, so you mustn't release the backing shader-visible descriptor heap until all work using that binding table has completed execution on the GPU.</span></span>

<span data-ttu-id="33fde-227">另一方面，雖然系結資料表會指定和管理描述元堆積，但資料表本身本身並不 *包含* 任何記憶體。</span><span class="sxs-lookup"><span data-stu-id="33fde-227">On the other hand, while a binding table does specify and manage a descriptor heap, the table doesn't itself *contain* any of that memory.</span></span> <span data-ttu-id="33fde-228">因此，您可以在呼叫 [**IDMLCommandRecorder：： RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) 之後，隨時釋放或重設系結資料表 (您不需要等待該呼叫在 GPU 上完成，只要基礎描述項仍維持有效的) 。</span><span class="sxs-lookup"><span data-stu-id="33fde-228">So, you may release or reset a binding table any time after you've called [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) with it (you don't need to wait for that call to complete on the GPU, so long as the underlying descriptors remain valid).</span></span>

<span data-ttu-id="33fde-229">系結資料表不會在任何系結的資源上保留強式參考 &mdash; ，您的應用程式必須確保在 GPU 仍在使用時，不會刪除資源。</span><span class="sxs-lookup"><span data-stu-id="33fde-229">The binding table doesn't keep strong references on any resources bound using it&mdash;your application must ensure that resources are not deleted while still in use by the GPU.</span></span> <span data-ttu-id="33fde-230">此外，系結資料表不具備安全線程， &mdash; 您的應用程式不能同時從不同的執行緒呼叫系結資料表上的方法，而不需要同步處理。</span><span class="sxs-lookup"><span data-stu-id="33fde-230">Also, a binding table isn't thread safe&mdash;your application must not call methods on a binding table simultaneously from different threads without synchronization.</span></span>

<span data-ttu-id="33fde-231">而且，請考慮在任何情況下，只有當您變更要系結的資源時，才需要重新系結。</span><span class="sxs-lookup"><span data-stu-id="33fde-231">And consider that in any case rebinding is necessary only when you change which resources are bound.</span></span> <span data-ttu-id="33fde-232">如果您不需要變更系結的資源，則可以在啟動時系結一次，並在每次呼叫 **RecordDispatch** 時傳遞相同的系結表。</span><span class="sxs-lookup"><span data-stu-id="33fde-232">If you don't need to change the bound resources, then you can bind once at startup, and pass the same binding table each time you call **RecordDispatch**.</span></span>

<span data-ttu-id="33fde-233">針對交錯的機器學習和轉譯工作負載，只需確定每個框架的系結資料表都指向未在 GPU 上使用的描述元堆積範圍。</span><span class="sxs-lookup"><span data-stu-id="33fde-233">For interleaving machine learning and rendering workloads, just ensure that each frame's binding tables points to ranges of the descriptor heap that are not already in use on the GPU.</span></span>

## <a name="optionally-specify-late-bound-operator-bindings"></a><span data-ttu-id="33fde-234">選擇性地指定晚期繫結運算子系結</span><span class="sxs-lookup"><span data-stu-id="33fde-234">Optionally specify late-bound operator bindings</span></span>

<span data-ttu-id="33fde-235">如果您要處理編譯的運算子 (而不是使用運算子初始化運算式) ，您可以選擇指定運算子的晚期繫結。</span><span class="sxs-lookup"><span data-stu-id="33fde-235">If you're dealing with a compiled operator (rather than with an operator initializer), then you have the option to specify late binding for the operator.</span></span> <span data-ttu-id="33fde-236">如果沒有晚期繫結，您必須先設定系結資料表上的所有系結，再將運算子記錄到命令清單中。</span><span class="sxs-lookup"><span data-stu-id="33fde-236">Without late binding, you must set all bindings on the binding table before you record an operator into a command list.</span></span> <span data-ttu-id="33fde-237">使用晚期繫結時，您可以在已記錄到命令佇列中的運算子上，設定 (或變更) 系結，然後再提交至命令佇列。</span><span class="sxs-lookup"><span data-stu-id="33fde-237">With late binding, you can set (or change) bindings on operators that you've already recorded into a command list, before it has been submitted to the command queue.</span></span>

<span data-ttu-id="33fde-238">若要指定晚期繫結，請使用 DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE 的引數來呼叫 [**IDMLDevice：： CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) `flags` 。 [](/windows/desktop/api/directml/ne-directml-dml_execution_flags)</span><span class="sxs-lookup"><span data-stu-id="33fde-238">To specify late binding, call [**IDMLDevice::CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) with a `flags` argument of [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span></span>