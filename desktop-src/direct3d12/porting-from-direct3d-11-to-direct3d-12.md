---
title: 從 Direct3D 11 移植到 Direct3D 12
description: 本節提供從自訂 Direct3D 11 圖形引擎移植到 Direct3D 12 的一些指引。
ms.assetid: 9EB4AC6B-AFDD-4673-8EB3-54272C151784
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 14b5bc6784d6f96c3c1599a601a57bf68b0d612d
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548438"
---
# <a name="porting-from-direct3d-11-to-direct3d-12"></a><span data-ttu-id="23fd4-103">從 Direct3D 11 移植到 Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="23fd4-103">Porting from Direct3D 11 to Direct3D 12</span></span>

<span data-ttu-id="23fd4-104">本節提供從自訂 Direct3D 11 圖形引擎移植到 Direct3D 12 的一些指引。</span><span class="sxs-lookup"><span data-stu-id="23fd4-104">This section provides some guidance on porting from a custom Direct3D 11 graphics engine to Direct3D 12.</span></span>

-   [<span data-ttu-id="23fd4-105">裝置建立</span><span class="sxs-lookup"><span data-stu-id="23fd4-105">Device creation</span></span>](#device-creation)
-   [<span data-ttu-id="23fd4-106">認可的資源</span><span class="sxs-lookup"><span data-stu-id="23fd4-106">Committed resources</span></span>](#committed-resources)
-   [<span data-ttu-id="23fd4-107">保留的資源</span><span class="sxs-lookup"><span data-stu-id="23fd4-107">Reserved resources</span></span>](#reserved-resources)
-   [<span data-ttu-id="23fd4-108">上傳資料</span><span class="sxs-lookup"><span data-stu-id="23fd4-108">Uploading data</span></span>](#uploading-data)
-   [<span data-ttu-id="23fd4-109">著色器和著色器物件</span><span class="sxs-lookup"><span data-stu-id="23fd4-109">Shaders and shader objects</span></span>](#shaders-and-shader-objects)
-   [<span data-ttu-id="23fd4-110">將工作提交至 GPU</span><span class="sxs-lookup"><span data-stu-id="23fd4-110">Submitting work to the GPU</span></span>](#submitting-work-to-the-gpu)
-   [<span data-ttu-id="23fd4-111">CPU/GPU 同步處理</span><span class="sxs-lookup"><span data-stu-id="23fd4-111">CPU/GPU Synchronization</span></span>](#cpugpu-synchronization)
-   [<span data-ttu-id="23fd4-112">資源系結</span><span class="sxs-lookup"><span data-stu-id="23fd4-112">Resource Binding</span></span>](#resource-binding)
-   [<span data-ttu-id="23fd4-113">資源狀態</span><span class="sxs-lookup"><span data-stu-id="23fd4-113">Resource state</span></span>](#resource-state)
-   [<span data-ttu-id="23fd4-114">Swapchains</span><span class="sxs-lookup"><span data-stu-id="23fd4-114">Swapchains</span></span>](#swapchains)
-   [<span data-ttu-id="23fd4-115">修正函式轉譯</span><span class="sxs-lookup"><span data-stu-id="23fd4-115">Fixed function rendering</span></span>](#fixed-function-rendering)
-   [<span data-ttu-id="23fd4-116">機率和結束</span><span class="sxs-lookup"><span data-stu-id="23fd4-116">Odds and ends</span></span>](#odds-and-ends)
-   [<span data-ttu-id="23fd4-117">相關主題</span><span class="sxs-lookup"><span data-stu-id="23fd4-117">Related topics</span></span>](#related-topics)

## <a name="device-creation"></a><span data-ttu-id="23fd4-118">裝置建立</span><span class="sxs-lookup"><span data-stu-id="23fd4-118">Device creation</span></span>

<span data-ttu-id="23fd4-119">Direct3D 11 和 Direct3D 12 都共用會裝置建立模式。</span><span class="sxs-lookup"><span data-stu-id="23fd4-119">Both Direct3D 11 and Direct3D 12 share a simliar device creation pattern.</span></span> <span data-ttu-id="23fd4-120">現有的 Direct3D 12 驅動程式全都 **D3D_FEATURE_LEVEL_11_0** 或更好，因此您可以忽略較舊的功能層級和相關聯的 lmitations。</span><span class="sxs-lookup"><span data-stu-id="23fd4-120">Existing Direct3D 12 drivers are all **D3D_FEATURE_LEVEL_11_0** or better, so you can ignore the older feature levels and associated lmitations.</span></span>

<span data-ttu-id="23fd4-121">也請記住，使用 Direct3D 12 時，您應該使用 DXGI 介面明確地列舉裝置資訊。</span><span class="sxs-lookup"><span data-stu-id="23fd4-121">Also keep in mind that with Direct3D 12, you should explicitly enumerate device information using DXGI interfaces.</span></span> <span data-ttu-id="23fd4-122">在 Direct3D 11 中，您可以從 Direct3D 裝置 *串連回* DXGI 裝置，但不支援 direct3d 12。</span><span class="sxs-lookup"><span data-stu-id="23fd4-122">In Direct3D 11, you could *chain back* to the DXGI device from the Direct3D device, and this is not supported for Direct3D 12.</span></span>

<span data-ttu-id="23fd4-123">您可以藉由提供從 **IDXGIFcatory4：： EnumWarpAdapter** 取得的明確介面卡，來建立 Direct3D 12 上的變形 software 裝置。</span><span class="sxs-lookup"><span data-stu-id="23fd4-123">Creating a WARP software device on Direct3D 12 is done by providing an explicit adapter obtained from **IDXGIFcatory4::EnumWarpAdapter**.</span></span> <span data-ttu-id="23fd4-124">Direct3D 12 的變形裝置只適用于已啟用 [ **圖形工具** ] 選用功能的系統。</span><span class="sxs-lookup"><span data-stu-id="23fd4-124">The WARP device for Direct3D 12 is available only on systems with the **Graphics Tools** optional feature enabled.</span></span>

> [!NOTE]
> <span data-ttu-id="23fd4-125">沒有對等的 **D3D11CreateDeviceAndSwapChain**。</span><span class="sxs-lookup"><span data-stu-id="23fd4-125">There is no equivalent to **D3D11CreateDeviceAndSwapChain**.</span></span> <span data-ttu-id="23fd4-126">即使使用 Direct3D 11，我們也不鼓勵使用此函式，因為通常最好是在不同的步驟中建立裝置和 swapchain。</span><span class="sxs-lookup"><span data-stu-id="23fd4-126">Even with Direct3D 11, we discourage the use of this function as it's often better to create the device and swapchain in distinct steps.</span></span>

## <a name="committed-resources"></a><span data-ttu-id="23fd4-127">認可的資源</span><span class="sxs-lookup"><span data-stu-id="23fd4-127">Committed resources</span></span>

<span data-ttu-id="23fd4-128">使用 Direct3D 11 中的下列介面所建立的物件，會轉譯為 Direct3D 12 中所謂的「認可的資源」。</span><span class="sxs-lookup"><span data-stu-id="23fd4-128">Objects created with the following interfaces in Direct3D 11, translate to what are called "committed resources" in Direct3D 12.</span></span> <span data-ttu-id="23fd4-129">認可的資源是具有虛擬位址空間和相關聯之實體頁面的資源。</span><span class="sxs-lookup"><span data-stu-id="23fd4-129">A committed resource is a resource which has both virtual address space and physical pages associated with it.</span></span> <span data-ttu-id="23fd4-130">這是以 Direct3D 12 為基礎之 Microsoft Windows Device Driver 2 (WDD2) 記憶體模型的概念。</span><span class="sxs-lookup"><span data-stu-id="23fd4-130">This is a concept of the Microsoft Windows Device Driver 2 (WDD2) Memory Model, on which Direct3D 12 is based.</span></span>

<span data-ttu-id="23fd4-131">Direct3D 11 資源：</span><span class="sxs-lookup"><span data-stu-id="23fd4-131">Direct3D 11 resources:</span></span>

-   [<span data-ttu-id="23fd4-132">**ID3D11Resource**</span><span class="sxs-lookup"><span data-stu-id="23fd4-132">**ID3D11Resource**</span></span>](/windows/win32/api/d3d11/nn-d3d11-id3d11resource)
-   <span data-ttu-id="23fd4-133">[**ID3D11Buffer**](/windows/win32/api/d3d11/nn-d3d11-id3d11buffer)和 [ **ID3D11Device：： CreateBuffer**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createbuffer)</span><span class="sxs-lookup"><span data-stu-id="23fd4-133">[**ID3D11Buffer**](/windows/win32/api/d3d11/nn-d3d11-id3d11buffer) and [**ID3D11Device::CreateBuffer**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createbuffer)</span></span>
-   <span data-ttu-id="23fd4-134">[**ID3D11Texture1D**](/windows/win32/api/d3d11/nn-d3d11-id3d11texture1d)和 [ **ID3D11Device： CreateTexture1D**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createtexture1d)</span><span class="sxs-lookup"><span data-stu-id="23fd4-134">[**ID3D11Texture1D**](/windows/win32/api/d3d11/nn-d3d11-id3d11texture1d) and [**ID3D11Device:CreateTexture1D**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createtexture1d)</span></span>
-   <span data-ttu-id="23fd4-135">[**ID3D11Texture2D**](/windows/win32/api/d3d11/nn-d3d11-id3d11texture2d)和 [ **ID3D11Device：： CreateTexture2D**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createtexture2d)</span><span class="sxs-lookup"><span data-stu-id="23fd4-135">[**ID3D11Texture2D**](/windows/win32/api/d3d11/nn-d3d11-id3d11texture2d) and [**ID3D11Device::CreateTexture2D**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createtexture2d)</span></span>
-   <span data-ttu-id="23fd4-136">[**ID3D11Texture3D**](/windows/win32/api/d3d11/nn-d3d11-id3d11texture3d)和 [ **ID3D11Device：： CreateTexture3D**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createtexture3d)</span><span class="sxs-lookup"><span data-stu-id="23fd4-136">[**ID3D11Texture3D**](/windows/win32/api/d3d11/nn-d3d11-id3d11texture3d) and [**ID3D11Device::CreateTexture3D**](/windows/win32/api/d3d11/nf-d3d11-id3d11device-createtexture3d)</span></span>

<span data-ttu-id="23fd4-137">在 Direct3D 12 中，這些全都以 [**ID3D12Resource**](/windows/win32/api/d3d12/nn-d3d12-id3d12resource) 和 [**ID3D12Device：： CreateCommittedResource**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource)表示。</span><span class="sxs-lookup"><span data-stu-id="23fd4-137">In Direct3D 12 these are all represented by [**ID3D12Resource**](/windows/win32/api/d3d12/nn-d3d12-id3d12resource) and [**ID3D12Device::CreateCommittedResource**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource).</span></span>

## <a name="reserved-resources"></a><span data-ttu-id="23fd4-138">保留的資源</span><span class="sxs-lookup"><span data-stu-id="23fd4-138">Reserved resources</span></span>

<span data-ttu-id="23fd4-139">保留的資源是只配置虛擬位址空間的資源，在呼叫 [**ID3D12Device：： CreateHeap**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createheap)之前，不會配置實體記憶體。</span><span class="sxs-lookup"><span data-stu-id="23fd4-139">Reserved resources are resources where only virtual address space has been allocated, physical memory is not allocated until there is a call to [**ID3D12Device::CreateHeap**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createheap).</span></span> <span data-ttu-id="23fd4-140">這基本上與 Direct3D 11 中的磚資源概念相同。</span><span class="sxs-lookup"><span data-stu-id="23fd4-140">This is essentially the same concept as tiled resources in Direct3D 11.</span></span>

<span data-ttu-id="23fd4-141">旗標 ([**D3D11 \_ 資源 \_ 其他 \_ 旗**](/windows/win32/api/d3d11/ne-d3d11-d3d11_resource_misc_flag) 標) 在 Direct3D 11 中用來設定並排的資源，然後將它們對應到實體記憶體。</span><span class="sxs-lookup"><span data-stu-id="23fd4-141">The flags ([**D3D11\_RESOURCE\_MISC\_FLAG**](/windows/win32/api/d3d11/ne-d3d11-d3d11_resource_misc_flag)) used in Direct3D 11 to set up tiled resources, then map them to physical memory.</span></span>

-   <span data-ttu-id="23fd4-142">D3D11 \_ 資源 \_ 其他 \_ 磚</span><span class="sxs-lookup"><span data-stu-id="23fd4-142">D3D11\_RESOURCE\_MISC\_TILED</span></span>
-   <span data-ttu-id="23fd4-143">D3D11 \_ 資源 \_ 其他 \_ 磚 \_ 集區</span><span class="sxs-lookup"><span data-stu-id="23fd4-143">D3D11\_RESOURCE\_MISC\_TILE\_POOL</span></span>

## <a name="uploading-data"></a><span data-ttu-id="23fd4-144">上傳資料</span><span class="sxs-lookup"><span data-stu-id="23fd4-144">Uploading data</span></span>

<span data-ttu-id="23fd4-145">在 Direct3D 11 中，單一時間軸的外觀 (在序列之後進行呼叫，例如使用 [**D3D11 \_ SUBRESOURCE \_ 資料**](/windows/win32/api/d3d11/ns-d3d11-d3d11_subresource_data)初始化的資料，然後呼叫 [**>id3d11devicecoNtext：： UpdateSubresource**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-updatesubresource)，然後呼叫 [**>id3d11devicecoNtext：： Map**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-map)) 。</span><span class="sxs-lookup"><span data-stu-id="23fd4-145">In Direct3D 11 there is the appearance of a single timeline (calls following a sequence, such as data initialized with [**D3D11\_SUBRESOURCE\_DATA**](/windows/win32/api/d3d11/ns-d3d11-d3d11_subresource_data), then a call is made to [**ID3D11DeviceContext::UpdateSubresource**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-updatesubresource), and then a call to [**ID3D11DeviceContext::Map**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-map)).</span></span> <span data-ttu-id="23fd4-146">對 Direct3D 11 開發人員而言，資料建立的複本數目並不明顯。</span><span class="sxs-lookup"><span data-stu-id="23fd4-146">The number of copies created of the data is not obvious to a Direct3D 11 developer.</span></span>

<span data-ttu-id="23fd4-147">在 Direct3D 12 中有兩個時間軸，GPU 時間軸 (透過呼叫 [**CopyTextureRegion**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion)來設定，並從可對應記憶體) 和 CPU 時間軸進行 [**CopyBufferRegion**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copybufferregion) ， (由呼叫來 [**對應**](/windows/win32/api/d3d12/nf-d3d12-id3d12resource-map)) 。</span><span class="sxs-lookup"><span data-stu-id="23fd4-147">In Direct3D 12 there are two timelines, the GPU timeline (set up by calls to [**CopyTextureRegion**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion), and [**CopyBufferRegion**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copybufferregion) from mappable memory) and the CPU timeline (determined by calls to [**Map**](/windows/win32/api/d3d12/nf-d3d12-id3d12resource-map)).</span></span> <span data-ttu-id="23fd4-148">Helper 函式 (在 d3dx12 .h 檔案中提供，) 稱為使用共用時間軸的 [**Updatesubresources**](updatesubresources1.md) 。</span><span class="sxs-lookup"><span data-stu-id="23fd4-148">Helper functions are provided (in the d3dx12.h file) called [**Updatesubresources**](updatesubresources1.md) that use a shared timeline.</span></span> <span data-ttu-id="23fd4-149">此 helper 函式有數種變化，一個使用 [**ID3D12Device：： GetCopyableFootprints**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcopyablefootprints)，另一個使用堆積配置機制，另一個則使用堆疊配置機制。</span><span class="sxs-lookup"><span data-stu-id="23fd4-149">There are several variations of this helper function, one that uses [**ID3D12Device::GetCopyableFootprints**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-getcopyablefootprints), another that uses a heap-allocating mechanism, and another that uses a stack-allocating mechanism.</span></span> <span data-ttu-id="23fd4-150">這些 helper 函式會透過記憶體的中繼臨時區域，將資源複製到 GPU 和 CPU。</span><span class="sxs-lookup"><span data-stu-id="23fd4-150">These helper functions copy resources to both the GPU and CPU, via an intermediate staging area of memory.</span></span>

<span data-ttu-id="23fd4-151">一般來說，GPU 和 CPU 都有自己的資源複本，並系結至自己的時間軸。</span><span class="sxs-lookup"><span data-stu-id="23fd4-151">Typically the GPU and CPU each have their own copy of a resource tied to their own timeline.</span></span> <span data-ttu-id="23fd4-152">共用的時間軸方法同樣會維護兩份複本。</span><span class="sxs-lookup"><span data-stu-id="23fd4-152">The shared timeline approach similarly maintains two copies.</span></span>

## <a name="shaders-and-shader-objects"></a><span data-ttu-id="23fd4-153">著色器和著色器物件</span><span class="sxs-lookup"><span data-stu-id="23fd4-153">Shaders and shader objects</span></span>

<span data-ttu-id="23fd4-154">在 Direct3D 11 中，有許多著色器和狀態物件的建立，並使用 [**ID3D11Device**](/windows/win32/api/d3d11/nn-d3d11-id3d11device) 建立方法和 [**>id3d11devicecoNtext**](/windows/win32/api/d3d11/nn-d3d11-id3d11devicecontext) set 方法來設定這些物件的狀態。</span><span class="sxs-lookup"><span data-stu-id="23fd4-154">In Direct3D 11 there is a lot of creation of shader and state objects, and setting the state of those objects, using the [**ID3D11Device**](/windows/win32/api/d3d11/nn-d3d11-id3d11device) creation methods and the [**ID3D11DeviceContext**](/windows/win32/api/d3d11/nn-d3d11-id3d11devicecontext) set methods.</span></span> <span data-ttu-id="23fd4-155">通常會對這些方法進行大量呼叫，然後由驅動程式在繪製時間合併，以設定正確的管線狀態。</span><span class="sxs-lookup"><span data-stu-id="23fd4-155">Typically a large number of calls are made to these methods, which are then combined at draw time by the driver to set the correct pipeline state.</span></span>

<span data-ttu-id="23fd4-156">在 Direct3D 12 中，管線狀態的這項設定已合併為單一物件 (計算引擎的 [**CreateComputePipelineState**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcomputepipelinestate) ，而圖形引擎的 CreateGraphicsPipelineState 則是圖形) 引擎的 [](/windows/win32/api/d3d12/nf-d3d12-id3d12device-creategraphicspipelinestate) ，接著會在使用 [**SetPipelineState**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setpipelinestate)的呼叫之前附加至命令清單。</span><span class="sxs-lookup"><span data-stu-id="23fd4-156">In Direct3D 12 this setting of pipeline state has been combined into a single object ([**CreateComputePipelineState**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcomputepipelinestate) for a compute engine, and [**CreateGraphicsPipelineState**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-creategraphicspipelinestate) for a graphics engine), which is then attached to a command list before the draw call with a call to [**SetPipelineState**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setpipelinestate).</span></span>

<span data-ttu-id="23fd4-157">在 Direct3D 11 中，這些呼叫會取代所有個別的呼叫，以設定著色器、輸入配置、blend 狀態、轉譯器狀態、深度樣板狀態等等。</span><span class="sxs-lookup"><span data-stu-id="23fd4-157">These calls replace all the individual calls to set shaders, input layout, blend state, rasterizer state, depth stencil state, and so on, in Direct3D 11</span></span>

- <span data-ttu-id="23fd4-158">裝置11方法： ``CreateInputLayout`` 、 ``CreateXShader`` 、 ``CreateDepthStencilState`` 、andD ``CreateRasterizerState`` 。</span><span class="sxs-lookup"><span data-stu-id="23fd4-158">Device 11 methods: ``CreateInputLayout``, ``CreateXShader``, ``CreateDepthStencilState``, andD ``CreateRasterizerState``.</span></span>
- <span data-ttu-id="23fd4-159">裝置內容11方法：  ``IASetInputLayout`` 、 ``xxSetShader`` 、 ``OMSetBlendState`` 、 ``OMSetDepthStencilState`` 和 ``RSSetState`` 。</span><span class="sxs-lookup"><span data-stu-id="23fd4-159">Device Context 11 methods:  ``IASetInputLayout``, ``xxSetShader``, ``OMSetBlendState``, ``OMSetDepthStencilState``, and ``RSSetState``.</span></span>

<span data-ttu-id="23fd4-160">雖然 Direct3D 12 可以支援較舊的編譯著色器 blob，但是著色器應該使用著色器模型5.1 搭配 FXC.EXE/D3DCompile Api，或使用著色器模型6（使用 DXIL DXC 編譯器）來建立。</span><span class="sxs-lookup"><span data-stu-id="23fd4-160">While Direct3D 12 can support older compiled shader blobs, shaders should be built using either Shader Model 5.1 with the FXC/D3DCompile APIs, or using Shader Model 6 using the DXIL DXC compiler.</span></span> <span data-ttu-id="23fd4-161">您應使用 [**CheckFeatureSupport**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) 和 **D3D12_FEATURE_SHADER_MODEL** 來驗證著色器模型6支援。</span><span class="sxs-lookup"><span data-stu-id="23fd4-161">You should validate Shader Model 6 support with [**CheckFeatureSupport**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) and **D3D12_FEATURE_SHADER_MODEL**.</span></span>

## <a name="submitting-work-to-the-gpu"></a><span data-ttu-id="23fd4-162">將工作提交至 GPU</span><span class="sxs-lookup"><span data-stu-id="23fd4-162">Submitting work to the GPU</span></span>

<span data-ttu-id="23fd4-163">在 Direct3D 11 中，實際上不會控制提交工作的方式，而是由驅動程式來處理，但透過 [**>id3d11devicecoNtext：： Flush**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-flush) 和 [**IDXGISwapChain1：:P resent1**](/windows/win32/api/dxgi1_2/nf-dxgi1_2-idxgiswapchain1-present1) 呼叫來啟用某些控制項。</span><span class="sxs-lookup"><span data-stu-id="23fd4-163">in Direct3D 11 there is little control over actually how work is submitted, it is largely handled by the driver, though some control is enabled through the [**ID3D11DeviceContext::Flush**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-flush) and [**IDXGISwapChain1::Present1**](/windows/win32/api/dxgi1_2/nf-dxgi1_2-idxgiswapchain1-present1) calls.</span></span>

<span data-ttu-id="23fd4-164">在 Direct3D 12 中，工作提交非常明確，而且是由應用程式所控制。</span><span class="sxs-lookup"><span data-stu-id="23fd4-164">In Direct3D 12 work submission is very explicit and controlled by the app.</span></span> <span data-ttu-id="23fd4-165">提交工作的主要結構是用來記錄所有應用程式命令 (的 [**ID3D12GraphicsCommandList**](/windows/win32/api/d3d12/nn-d3d12-id3d12graphicscommandlist)，在概念上與 ID3D11 延後的內容) 很類似。</span><span class="sxs-lookup"><span data-stu-id="23fd4-165">The primary construct for submitting work is the [**ID3D12GraphicsCommandList**](/windows/win32/api/d3d12/nn-d3d12-id3d12graphicscommandlist), which is used to record all the apps commands (and is quite similar in concept to the ID3D11 deferred context).</span></span> <span data-ttu-id="23fd4-166">命令清單的備份存放區是由 [**ID3D12CommandAllocator**](/windows/win32/api/d3d12/nn-d3d12-id3d12commandallocator)所提供，可讓應用程式藉由實際公開 Direct3D 12 驅動程式即將用來儲存命令清單的記憶體，來管理命令清單的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="23fd4-166">Backing store for a command list is provided by the [**ID3D12CommandAllocator**](/windows/win32/api/d3d12/nn-d3d12-id3d12commandallocator), which enables the app to manage the memory utilization of the command list by actually exposing the memory that the Direct3D 12 driver is going to use to store the command list.</span></span>

<span data-ttu-id="23fd4-167">最後， [**ID3D12CommandQueue**](/windows/win32/api/d3d12/nn-d3d12-id3d12commandqueue) 是先進先出佇列，可儲存命令清單的正確順序，以提交給 GPU。</span><span class="sxs-lookup"><span data-stu-id="23fd4-167">Finally the [**ID3D12CommandQueue**](/windows/win32/api/d3d12/nn-d3d12-id3d12commandqueue) is a first-in first-out queue, that stores the correct order of the command lists for submission to the GPU.</span></span> <span data-ttu-id="23fd4-168">只有當某個命令清單在 GPU 上已完成執行時，驅動程式才會提交佇列中的下一個命令清單。</span><span class="sxs-lookup"><span data-stu-id="23fd4-168">Only when one command list has completed execution on the GPU, will the next command list from the queue be submitted by the driver.</span></span>

<span data-ttu-id="23fd4-169">在 Direct3D 11 中，命令佇列沒有明確的概念。</span><span class="sxs-lookup"><span data-stu-id="23fd4-169">In Direct3D 11 there is no explicit concept of a command queue.</span></span> <span data-ttu-id="23fd4-170">在 Direct3D 12 的一般設定中，目前的框架目前開啟的 **D3D12_COMMAND_LIST_TYPE_DIRECT** 命令清單，可視為與 Direct3D 11 立即內容類別似。</span><span class="sxs-lookup"><span data-stu-id="23fd4-170">In the common setup for Direct3D 12, the currently open **D3D12_COMMAND_LIST_TYPE_DIRECT** command list for the current frame can be considered analogous to the Direct3D 11 immediate context.</span></span> <span data-ttu-id="23fd4-171">這提供許多相同的功能。</span><span class="sxs-lookup"><span data-stu-id="23fd4-171">This provides many of the same functions.</span></span>


| <span data-ttu-id="23fd4-172">D3D11DeviceCoNtext</span><span class="sxs-lookup"><span data-stu-id="23fd4-172">D3D11DeviceContext</span></span>                  | <span data-ttu-id="23fd4-173">ID3D12GraphicsCommand 清單</span><span class="sxs-lookup"><span data-stu-id="23fd4-173">ID3D12GraphicsCommand List</span></span>     |
|-------------------------------------|--------------------------------|
| <span data-ttu-id="23fd4-174">ClearDepthStencilView</span><span class="sxs-lookup"><span data-stu-id="23fd4-174">ClearDepthStencilView</span></span>               | <span data-ttu-id="23fd4-175">ClearDepthStencilView</span><span class="sxs-lookup"><span data-stu-id="23fd4-175">ClearDepthStencilView</span></span>          |
| <span data-ttu-id="23fd4-176">ClearRenderTargetView</span><span class="sxs-lookup"><span data-stu-id="23fd4-176">ClearRenderTargetView</span></span>               | <span data-ttu-id="23fd4-177">ClearRenderTargetView</span><span class="sxs-lookup"><span data-stu-id="23fd4-177">ClearRenderTargetView</span></span>          |
| <span data-ttu-id="23fd4-178">ClearUnorderedAccess\*</span><span class="sxs-lookup"><span data-stu-id="23fd4-178">ClearUnorderedAccess\*</span></span>               | <span data-ttu-id="23fd4-179">ClearUnorderedAccess\*</span><span class="sxs-lookup"><span data-stu-id="23fd4-179">ClearUnorderedAccess\*</span></span>          |
| <span data-ttu-id="23fd4-180">Draw、DrawInstanced</span><span class="sxs-lookup"><span data-stu-id="23fd4-180">Draw, DrawInstanced</span></span>                 | <span data-ttu-id="23fd4-181">DrawInstanced</span><span class="sxs-lookup"><span data-stu-id="23fd4-181">DrawInstanced</span></span>                  |
| <span data-ttu-id="23fd4-182">DrawIndexed、DrawIndexedInstanced</span><span class="sxs-lookup"><span data-stu-id="23fd4-182">DrawIndexed, DrawIndexedInstanced</span></span>   | <span data-ttu-id="23fd4-183">DrawIndexedInstanced</span><span class="sxs-lookup"><span data-stu-id="23fd4-183">DrawIndexedInstanced</span></span>           |
| <span data-ttu-id="23fd4-184">分派</span><span class="sxs-lookup"><span data-stu-id="23fd4-184">Dispatch</span></span>                            | <span data-ttu-id="23fd4-185">分派</span><span class="sxs-lookup"><span data-stu-id="23fd4-185">Dispatch</span></span>                       |
| <span data-ttu-id="23fd4-186">IASetInputLayout、xxSetShader 等。</span><span class="sxs-lookup"><span data-stu-id="23fd4-186">IASetInputLayout, xxSetShader, etc.</span></span> | <span data-ttu-id="23fd4-187">SetPipelineState</span><span class="sxs-lookup"><span data-stu-id="23fd4-187">SetPipelineState</span></span>               |
| <span data-ttu-id="23fd4-188">OMSetBlendState</span><span class="sxs-lookup"><span data-stu-id="23fd4-188">OMSetBlendState</span></span>                     | <span data-ttu-id="23fd4-189">OMSetBlendFactor</span><span class="sxs-lookup"><span data-stu-id="23fd4-189">OMSetBlendFactor</span></span>               |
| <span data-ttu-id="23fd4-190">OMSetDepthStencilState</span><span class="sxs-lookup"><span data-stu-id="23fd4-190">OMSetDepthStencilState</span></span>              | <span data-ttu-id="23fd4-191">OMSetStencilRef</span><span class="sxs-lookup"><span data-stu-id="23fd4-191">OMSetStencilRef</span></span>                |
| <span data-ttu-id="23fd4-192">OMSetRenderTargets</span><span class="sxs-lookup"><span data-stu-id="23fd4-192">OMSetRenderTargets</span></span>                  | <span data-ttu-id="23fd4-193">OMSetRenderTargets</span><span class="sxs-lookup"><span data-stu-id="23fd4-193">OMSetRenderTargets</span></span>             |
| <span data-ttu-id="23fd4-194">RSSetViewports</span><span class="sxs-lookup"><span data-stu-id="23fd4-194">RSSetViewports</span></span>                      | <span data-ttu-id="23fd4-195">RSSetViewports</span><span class="sxs-lookup"><span data-stu-id="23fd4-195">RSSetViewports</span></span>                 |
| <span data-ttu-id="23fd4-196">RSSetScissorRects</span><span class="sxs-lookup"><span data-stu-id="23fd4-196">RSSetScissorRects</span></span>                   | <span data-ttu-id="23fd4-197">RSSetScissorRects</span><span class="sxs-lookup"><span data-stu-id="23fd4-197">RSSetScissorRects</span></span>              |
| <span data-ttu-id="23fd4-198">IASetPrimitiveTopology</span><span class="sxs-lookup"><span data-stu-id="23fd4-198">IASetPrimitiveTopology</span></span>              | <span data-ttu-id="23fd4-199">IASetPrimitiveTopology</span><span class="sxs-lookup"><span data-stu-id="23fd4-199">IASetPrimitiveTopology</span></span>         |
| <span data-ttu-id="23fd4-200">IASetVertexBuffers</span><span class="sxs-lookup"><span data-stu-id="23fd4-200">IASetVertexBuffers</span></span>                  | <span data-ttu-id="23fd4-201">IASetVertexBuffers</span><span class="sxs-lookup"><span data-stu-id="23fd4-201">IASetVertexBuffers</span></span>             |
| <span data-ttu-id="23fd4-202">IASetIndexBuffer</span><span class="sxs-lookup"><span data-stu-id="23fd4-202">IASetIndexBuffer</span></span>                    | <span data-ttu-id="23fd4-203">IASetIndexBuffer</span><span class="sxs-lookup"><span data-stu-id="23fd4-203">IASetIndexBuffer</span></span>               |
| <span data-ttu-id="23fd4-204">ResolveSubresource</span><span class="sxs-lookup"><span data-stu-id="23fd4-204">ResolveSubresource</span></span>                  | <span data-ttu-id="23fd4-205">ResolveSubresource</span><span class="sxs-lookup"><span data-stu-id="23fd4-205">ResolveSubresource</span></span>             |
| <span data-ttu-id="23fd4-206">CopySubresourceRegion</span><span class="sxs-lookup"><span data-stu-id="23fd4-206">CopySubresourceRegion</span></span>               | <span data-ttu-id="23fd4-207">CopyBufferRegion</span><span class="sxs-lookup"><span data-stu-id="23fd4-207">CopyBufferRegion</span></span>               |
| <span data-ttu-id="23fd4-208">UpdateSubresource</span><span class="sxs-lookup"><span data-stu-id="23fd4-208">UpdateSubresource</span></span>                   | <span data-ttu-id="23fd4-209">CopyTextureRegion</span><span class="sxs-lookup"><span data-stu-id="23fd4-209">CopyTextureRegion</span></span>              |
| <span data-ttu-id="23fd4-210">CopyResource</span><span class="sxs-lookup"><span data-stu-id="23fd4-210">CopyResource</span></span>                        | <span data-ttu-id="23fd4-211">CopyResource</span><span class="sxs-lookup"><span data-stu-id="23fd4-211">CopyResource</span></span>                   |

> [!NOTE]
> <span data-ttu-id="23fd4-212">使用 **D3D12_COMMAND_LIST_TYPE_BUNDLE** 所建立的命令清單會會至延遲的內容。</span><span class="sxs-lookup"><span data-stu-id="23fd4-212">A command list created with **D3D12_COMMAND_LIST_TYPE_BUNDLE** is simliar to a deferred context.</span></span> <span data-ttu-id="23fd4-213">Direct3D 12 也支援 abiilty，以同時存取 *立即內容* 的一些功能，以透過 **D3D12_COMMAND_LIST_TYPE_COPY** 和 **D3D12_COMMAND_LIST_TYPE_COMPUTE** 命令清單類型來呈現。</span><span class="sxs-lookup"><span data-stu-id="23fd4-213">Direct3D 12 also supports the abiilty to access some features of an *immediate context* simultaneous to rendering via **D3D12_COMMAND_LIST_TYPE_COPY** and **D3D12_COMMAND_LIST_TYPE_COMPUTE** command list types.</span></span>

## <a name="cpugpu-synchronization"></a><span data-ttu-id="23fd4-214">CPU/GPU 同步處理</span><span class="sxs-lookup"><span data-stu-id="23fd4-214">CPU/GPU Synchronization</span></span>

<span data-ttu-id="23fd4-215">在 Direct3D 11 中，CPU/GPU 同步處理大多是自動的，而且應用程式不需要維護實體記憶體的狀態。</span><span class="sxs-lookup"><span data-stu-id="23fd4-215">In Direct3D 11 CPU/GPU synchronization was largely automatic, and there was no need for the app to maintain the status of physical memory.</span></span>

<span data-ttu-id="23fd4-216">在 Direct3D 12 中，應用程式必須明確地管理兩個時間軸 (CPU 和 GPU) 。</span><span class="sxs-lookup"><span data-stu-id="23fd4-216">in Direct3D 12 the app must manage the two timelines (CPU and GPU) explicitly.</span></span> <span data-ttu-id="23fd4-217">這需要由應用程式維護資訊、GPU 需要哪些資源，以及有多長的時間。</span><span class="sxs-lookup"><span data-stu-id="23fd4-217">This requires that information needs to be maintained, by the app, on what resources are required by the GPU, and for how long.</span></span> <span data-ttu-id="23fd4-218">這也表示應用程式必須負責確保資源 (認可資源、堆積、命令配置器等資源的內容，例如) 不會變更，直到 GPU 完成使用為止。</span><span class="sxs-lookup"><span data-stu-id="23fd4-218">This also means that the app is responsible for ensuring the contents of resources (committed resources, heaps, command allocators, for example) do not change until the GPU has finished using them.</span></span>

<span data-ttu-id="23fd4-219">用於同步處理時間軸的主要物件是 [**ID3D12Fence**](/windows/win32/api/d3d12/nn-d3d12-id3d12fence) 物件。</span><span class="sxs-lookup"><span data-stu-id="23fd4-219">The main object for synchronizing the timelines is the [**ID3D12Fence**](/windows/win32/api/d3d12/nn-d3d12-id3d12fence) object.</span></span> <span data-ttu-id="23fd4-220">Failry 的作業很簡單，可讓 GPU 在完成工作時發出信號。</span><span class="sxs-lookup"><span data-stu-id="23fd4-220">The operation of fences is failry simple, they enable the GPU to signal when it has completed a task.</span></span> <span data-ttu-id="23fd4-221">GPU 和 CPU 都可以是信號，也可以等候圍牆。</span><span class="sxs-lookup"><span data-stu-id="23fd4-221">The GPU and CPU can both signal, and can both wait on fences.</span></span>

<span data-ttu-id="23fd4-222">這種方法通常是在提交命令清單以執行時，GPU 會在完成 (完成讀取資料) 時傳輸，讓 CPU 可以重複使用或終結資源。</span><span class="sxs-lookup"><span data-stu-id="23fd4-222">Typically the approach is that when submitting a command list for execution, a fence signal is transmitted by the GPU on completion (when it has finished reading the data), enabling the CPU to reuse or destroy the resources.</span></span>

<span data-ttu-id="23fd4-223">在 Direct3D 11 中， [**>id3d11devicecoNtext：： map**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-map) 旗標 D3D11 \_ Map \_ WRITE \_ 捨棄基本上會將每個資源視為無限的記憶體供應，應用程式可以寫入 (稱為「重新命名」 ) 的進程。</span><span class="sxs-lookup"><span data-stu-id="23fd4-223">In Direct3D 11 the [**ID3D11DeviceContext::Map**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-map) flag D3D11\_MAP\_WRITE\_DISCARD essentially treated each resource as an endless supply of memory the app could write to (a process known as "renaming").</span></span> <span data-ttu-id="23fd4-224">在 Direct3D 12 中，此程式是明確的：需要配置額外的記憶體，而且應該使用「配置」來同步處理作業。</span><span class="sxs-lookup"><span data-stu-id="23fd4-224">In Direct3D 12 again the process is explicit: additional memory needs to be allocated, and fences should be used to sync the operations.</span></span> <span data-ttu-id="23fd4-225">通道緩衝區 (由大型緩衝區組成) 這可能是很好的方法，請參閱以 [隔離為基礎的資源管理](fence-based-resource-management.md)中的信號緩衝區案例。</span><span class="sxs-lookup"><span data-stu-id="23fd4-225">Ring buffers (consisting of large buffers) might be a good technique for this, refer to the ring buffer scenario in [Fence-Based Resource Management](fence-based-resource-management.md).</span></span>

![使用信號緩衝區](images/ring-buffer-1.png)

## <a name="resource-binding"></a><span data-ttu-id="23fd4-227">資源系結</span><span class="sxs-lookup"><span data-stu-id="23fd4-227">Resource Binding</span></span>

<span data-ttu-id="23fd4-228">Direct3D 11 中的 Views (著色器資源檢視、轉譯目標視圖等) ，在 Direct3D 12 中，主要是以描述項的概念取代。</span><span class="sxs-lookup"><span data-stu-id="23fd4-228">Views in Direct3D 11 (shader resource views, render target views, and so on), have largely been replaced in Direct3D 12 with the concept of a descriptor.</span></span> <span data-ttu-id="23fd4-229">建立方法仍然存在於 Direct3D 12 (例如 [**CreateShaderResourceView**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createshaderresourceview) 和 [**CreateRenderTargetView**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrendertargetview)) ，在建立描述元堆積之後呼叫，以將資料寫入堆積。</span><span class="sxs-lookup"><span data-stu-id="23fd4-229">The creation methods still exist in Direct3D 12 (such as [**CreateShaderResourceView**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createshaderresourceview) and [**CreateRenderTargetView**](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createrendertargetview)), which are called after the descriptor heap has been created, to write the data into the heap.</span></span> <span data-ttu-id="23fd4-230">Direct3D 12 中的系結現在是由根簽章中所述的描述項控制碼處理，並使用 [**SetGraphicsRootDescriptorTable**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable) 或 [**SetComputeRootDescriptorTable**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable) 方法來提交。</span><span class="sxs-lookup"><span data-stu-id="23fd4-230">Binding in Direct3D 12 is now handled by descriptor handles described in a root signature, and submitted using the [**SetGraphicsRootDescriptorTable**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable) or [**SetComputeRootDescriptorTable**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable) methods.</span></span>

<span data-ttu-id="23fd4-231">根簽章會詳細說明根簽章位置編號和描述中繼資料表之間的對應，其中描述項資料表可包含指向頂點著色器、圖元著色器和其他著色器的資源參考，例如常數緩衝區、著色器資源檢視器和取樣器。</span><span class="sxs-lookup"><span data-stu-id="23fd4-231">Root signatures details mappings between the root signature slot number and descriptor tables, where the descriptor table can contain references to resources available to vertex shaders, pixel shaders, and the other shaders, such as constant buffers, shader resource views and samplers.</span></span> <span data-ttu-id="23fd4-232">這種彈性會中斷 HLSL 登錄空間與 Direct3D 12 中的 API 系結空間之間的連線，與 Direct3D 11 不同，後者之間會有一對一的對應。</span><span class="sxs-lookup"><span data-stu-id="23fd4-232">This flexibility disconnects the HLSL register space from the API binding space in Direct3D 12, unlike Direct3D 11 where there is a one to one mapping between these.</span></span>

<span data-ttu-id="23fd4-233">此系統的其中一個含意是，應用程式會負責重新命名描述中繼資料表，讓開發人員瞭解變更每個繪製呼叫的單一描述項的效能成本。</span><span class="sxs-lookup"><span data-stu-id="23fd4-233">One of the implications of this system is that the app is responsible for renaming descriptor tables, which enables developers to understand the performance cost of changing even a single descriptor per draw call.</span></span>

<span data-ttu-id="23fd4-234">Direct3D 12 的新功能是，應用程式可以控制哪些描述元在哪些著色器階段之間共用。</span><span class="sxs-lookup"><span data-stu-id="23fd4-234">A new feature of Direct3D 12 is that an app can control which descriptors are shared between which shader stages.</span></span> <span data-ttu-id="23fd4-235">在 Direct3D 11 資源（例如 UAVs）中，所有著色器階段都會共用這些資源。</span><span class="sxs-lookup"><span data-stu-id="23fd4-235">In Direct3D 11 resources such as UAVs are shared between all shader stages.</span></span> <span data-ttu-id="23fd4-236">藉由啟用針對某些著色器階段停用的描述項，已停用的描述項所使用的暫存器可供針對特定著色器階段啟用的描述項使用。</span><span class="sxs-lookup"><span data-stu-id="23fd4-236">By enabling descriptors to be disabled for certain shader stages, the registers used by descriptors that have been disabled are available to be used by descriptors which are enabled for a particular shader stage.</span></span>

<span data-ttu-id="23fd4-237">下表顯示範例根簽章。</span><span class="sxs-lookup"><span data-stu-id="23fd4-237">The following table shows an example root signature.</span></span>



| <span data-ttu-id="23fd4-238">根參數位置</span><span class="sxs-lookup"><span data-stu-id="23fd4-238">Root Parameter Slot</span></span> | <span data-ttu-id="23fd4-239">描述項資料表專案</span><span class="sxs-lookup"><span data-stu-id="23fd4-239">Descriptor Table Entry</span></span>         |
|---------------------|--------------------------------|
| <span data-ttu-id="23fd4-240">0</span><span class="sxs-lookup"><span data-stu-id="23fd4-240">0</span></span>                   | <span data-ttu-id="23fd4-241">VS 描述項範圍 b0-b13</span><span class="sxs-lookup"><span data-stu-id="23fd4-241">VS Descriptor Range b0-b13</span></span>     |
| <span data-ttu-id="23fd4-242">1</span><span class="sxs-lookup"><span data-stu-id="23fd4-242">1</span></span>                   | <span data-ttu-id="23fd4-243">VS 描述項範圍 t0-t127</span><span class="sxs-lookup"><span data-stu-id="23fd4-243">VS Descriptor Range t0-t127</span></span>    |
| <span data-ttu-id="23fd4-244">2</span><span class="sxs-lookup"><span data-stu-id="23fd4-244">2</span></span>                   | <span data-ttu-id="23fd4-245">VS 描述項範圍 s0-s16</span><span class="sxs-lookup"><span data-stu-id="23fd4-245">VS Descriptor Range s0-s16</span></span>     |
| <span data-ttu-id="23fd4-246">3</span><span class="sxs-lookup"><span data-stu-id="23fd4-246">3</span></span>                   | <span data-ttu-id="23fd4-247">PS 描述項範圍 b0-b13</span><span class="sxs-lookup"><span data-stu-id="23fd4-247">PS Descriptor Range b0-b13</span></span>     |
| <span data-ttu-id="23fd4-248">...</span><span class="sxs-lookup"><span data-stu-id="23fd4-248">...</span></span>                 |                                |
| <span data-ttu-id="23fd4-249">14</span><span class="sxs-lookup"><span data-stu-id="23fd4-249">14</span></span>                  | <span data-ttu-id="23fd4-250">DS 描述項範圍 s0-16</span><span class="sxs-lookup"><span data-stu-id="23fd4-250">DS Descriptor Range s0-16</span></span>      |
| <span data-ttu-id="23fd4-251">15</span><span class="sxs-lookup"><span data-stu-id="23fd4-251">15</span></span>                  | <span data-ttu-id="23fd4-252">共用描述項範圍 u0-u63</span><span class="sxs-lookup"><span data-stu-id="23fd4-252">Shared Descriptor Range u0-u63</span></span> |



 

## <a name="resource-state"></a><span data-ttu-id="23fd4-253">資源狀態</span><span class="sxs-lookup"><span data-stu-id="23fd4-253">Resource state</span></span>

<span data-ttu-id="23fd4-254">在 Direct3D 11 中，應用程式不會維護資源狀態，而是由驅動程式維護。</span><span class="sxs-lookup"><span data-stu-id="23fd4-254">In Direct3D 11 resource state is not maintained by the app, but by the driver.</span></span>

<span data-ttu-id="23fd4-255">在 Direct3D 12 中，維護資源狀態會成為應用程式的責任，以便在記錄命令清單時啟用完整平行處理原則：應用程式必須處理命令清單的錄製時間軸 (可以平行) ，以及必須是連續的執行時間軸。</span><span class="sxs-lookup"><span data-stu-id="23fd4-255">In Direct3D 12 maintaining resource state becomes the responsibility of the app, to enable full parallelism in the recording of command lists: the app must handle the recording timelines for command lists (which can be done in parallel), and the execution timelines which must be sequential.</span></span>

<span data-ttu-id="23fd4-256">資源狀態轉換是由 [**ResourceBarrier**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier) 方法處理。</span><span class="sxs-lookup"><span data-stu-id="23fd4-256">A resource state transition is handled by the [**ResourceBarrier**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier) method.</span></span> <span data-ttu-id="23fd4-257">主要應用程式必須在資源使用量變更時通知驅動程式。</span><span class="sxs-lookup"><span data-stu-id="23fd4-257">Primarily the app must inform the driver when resource usage is changing.</span></span> <span data-ttu-id="23fd4-258">例如，如果資源當做轉譯目標使用，然後在下一次繪製呼叫中當做頂點著色器的輸入使用，則在處理頂點著色器之前，可能需要短暫的 GPU 作業，才能完成轉譯目標操作。</span><span class="sxs-lookup"><span data-stu-id="23fd4-258">For example if a resource is being used as a render target, and then it is to be used as input to a vertex shader on the next draw call, then this might require a short stall in GPU operation to complete the render target operation before handling the vertex shader.</span></span>

<span data-ttu-id="23fd4-259">此系統可進行精細的同步處理 (GPU 會停止圖形管線) ，以及快取排清以及可能的一些記憶體配置變更 (例如，將目標視圖轉譯為深度樣板視圖解壓縮) 。</span><span class="sxs-lookup"><span data-stu-id="23fd4-259">This system enables fine grain synchronization (the GPU stalls) of the graphics pipeline, as well as cache flushes and possibly some memory layout changes (such as render target view to depth stencil view decompression).</span></span>

<span data-ttu-id="23fd4-260">這就是所謂的轉換屏障。</span><span class="sxs-lookup"><span data-stu-id="23fd4-260">This is known as a transition barrier.</span></span> <span data-ttu-id="23fd4-261">在 Direct3D 11 中有其他阻礙， [**ID3D11DeviceCoNtext2：： TiledResourceBarrier**](/windows/win32/api/d3d11_2/nf-d3d11_2-id3d11devicecontext2-tiledresourcebarrier) 啟用了兩個不同的並排資源所使用的相同實體記憶體。</span><span class="sxs-lookup"><span data-stu-id="23fd4-261">There are other kinds of barriers, in Direct3D 11 the [**ID3D11DeviceContext2::TiledResourceBarrier**](/windows/win32/api/d3d11_2/nf-d3d11_2-id3d11devicecontext2-tiledresourcebarrier) enabled the same physical memory to be used by two different tiled resources.</span></span> <span data-ttu-id="23fd4-262">在 Direct3D 12 中，這稱為「別名屏障」。</span><span class="sxs-lookup"><span data-stu-id="23fd4-262">In Direct3D 12 this is referred to as an "aliasing barrier".</span></span> <span data-ttu-id="23fd4-263">您可以在 Direct3D 12 中，針對已並排和放置的資源使用別名。</span><span class="sxs-lookup"><span data-stu-id="23fd4-263">Aliasing barriers can be used for both tiled and placed resources in Direct3D 12.</span></span> <span data-ttu-id="23fd4-264">此外，還有 UAV 關卡。</span><span class="sxs-lookup"><span data-stu-id="23fd4-264">Additionally there is the UAV barrier.</span></span> <span data-ttu-id="23fd4-265">在 Direct3D 11 中，所有 UAV 分派和繪製作業都必須進行序列化，即使這些作業可以進行管線處理或平行處理也是一樣。</span><span class="sxs-lookup"><span data-stu-id="23fd4-265">In Direct3D 11 all UAV dispatch and draw operations are required to be serialized, even though these operations can be pipelined or work in parallel.</span></span> <span data-ttu-id="23fd4-266">針對 Direct3D 12，這項限制會透過新增 UAV 關卡來移除。</span><span class="sxs-lookup"><span data-stu-id="23fd4-266">For Direct3D 12 this restriction is removed by the addition of a UAV barrier.</span></span> <span data-ttu-id="23fd4-267">UAV 關卡可確保 UAV 作業是連續的，因此，如果第二個作業需要第一個完成，則會強制第二個作業因新增關卡而等候。</span><span class="sxs-lookup"><span data-stu-id="23fd4-267">A UAV barrier ensures that UAV operations are sequential, so if a second operation requires that the first complete, the second will be forced to wait by the addition of the barrier.</span></span> <span data-ttu-id="23fd4-268">UAVs 的預設作業只是要儘快進行作業。</span><span class="sxs-lookup"><span data-stu-id="23fd4-268">The default operation for UAVs is simply that the operations will proceed as quickly as possible.</span></span>

<span data-ttu-id="23fd4-269">如果可以平行處理工作負載，顯然會提高效能。</span><span class="sxs-lookup"><span data-stu-id="23fd4-269">Clearly there are performance gains if a workload can be parallelized.</span></span>

## <a name="swapchains"></a><span data-ttu-id="23fd4-270">Swapchains</span><span class="sxs-lookup"><span data-stu-id="23fd4-270">Swapchains</span></span>

<span data-ttu-id="23fd4-271">DXGI 交換鏈是 Direct3D 11 和12中交換鏈的基礎。</span><span class="sxs-lookup"><span data-stu-id="23fd4-271">The DXGI swap chain is the basis for swap chains in both Direct3D 11 and 12.</span></span> <span data-ttu-id="23fd4-272">在 Direct3D 11 中有一些微的差異，這三種交換鏈類型為連續、捨棄和翻轉 \_ 順序。</span><span class="sxs-lookup"><span data-stu-id="23fd4-272">There are some minor differences, in Direct3D 11 the three types of swap chain are SEQUENTIAL, DISCARD, and FLIP\_SEQUENTIAL.</span></span> <span data-ttu-id="23fd4-273">針對 Direct3D 12，只有兩種類型：反轉 \_ 順序和翻轉 \_ 捨棄。</span><span class="sxs-lookup"><span data-stu-id="23fd4-273">For Direct3D 12 there are just two types: FLIP\_SEQUENTIAL and FLIP\_DISCARD.</span></span> <span data-ttu-id="23fd4-274">如先前所述，您應該透過 **IDXGIFactory4** 或更新版本明確地建立 swapchain，並對任何介面卡列舉使用相同的介面。</span><span class="sxs-lookup"><span data-stu-id="23fd4-274">As noted above, you should be explicitly creating your swapchain via **IDXGIFactory4**, or later, and using the same interface for any adapter enumeration.</span></span>

<span data-ttu-id="23fd4-275">在 Direct3D 11 中，有自動背景緩衝區輪替：後置緩衝區0只需要一個呈現目標視圖。</span><span class="sxs-lookup"><span data-stu-id="23fd4-275">In Direct3D 11 there is automatic backbuffer rotation: only one render target view is needed for back buffer 0.</span></span> <span data-ttu-id="23fd4-276">在 Direct3D 12 中，緩衝區輪替是明確的，每個後置緩衝區都必須有一個呈現目標視圖。</span><span class="sxs-lookup"><span data-stu-id="23fd4-276">In Direct3D 12 buffer rotation is explicit, there needs to be a render target view for each back buffer.</span></span> <span data-ttu-id="23fd4-277">您可以使用 [**IDXGISwapChain3：： GetCurrentBackBufferIndex**](/windows/win32/api/dxgi1_4/nf-dxgi1_4-idxgiswapchain3-getcurrentbackbufferindex) 方法來選取要轉譯至哪一個。</span><span class="sxs-lookup"><span data-stu-id="23fd4-277">Use the [**IDXGISwapChain3::GetCurrentBackBufferIndex**](/windows/win32/api/dxgi1_4/nf-dxgi1_4-idxgiswapchain3-getcurrentbackbufferindex) method to select which one to render to.</span></span> <span data-ttu-id="23fd4-278">同樣地，這種額外的彈性也能提高平行化。</span><span class="sxs-lookup"><span data-stu-id="23fd4-278">Again this additional flexibility enables greater parallelization.</span></span>

> [!NOTE]
> <span data-ttu-id="23fd4-279">雖然有許多方式可以設定您的應用程式，但應用程式的每個交換鏈緩衝區通常都有一個 **ID3D12CommandAllocator** 。</span><span class="sxs-lookup"><span data-stu-id="23fd4-279">While there are numerous ways to set up your application, generally applications have one **ID3D12CommandAllocator** per swap-chain buffer.</span></span> <span data-ttu-id="23fd4-280">這可讓應用程式在 GPU 轉譯之前，繼續為下一個框架建立一組命令。</span><span class="sxs-lookup"><span data-stu-id="23fd4-280">This allows the application to proceed to building up a set of commands for the next frame while the GPU renders the previous.</span></span>

## <a name="fixed-function-rendering"></a><span data-ttu-id="23fd4-281">修正函式轉譯</span><span class="sxs-lookup"><span data-stu-id="23fd4-281">Fixed function rendering</span></span>

<span data-ttu-id="23fd4-282">在 Direct3D 11 中，有幾種方法可簡化各種較高層級的作業，例如 [**GenerateMips**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-generatemips) (建立完整的 mip 鏈) 和 [**DrawAuto**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-drawauto) (使用串流輸出做為著色器輸入，而不需要從應用程式) 進一步輸入。</span><span class="sxs-lookup"><span data-stu-id="23fd4-282">In Direct3D 11 there were a few methods that simplified various higher level operations, such as [**GenerateMips**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-generatemips) (creating full mip chains) and [**DrawAuto**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-drawauto) (using stream output as shader input without further input from the app).</span></span> <span data-ttu-id="23fd4-283">在 Direct3D 12 中不提供這些方法，應用程式必須藉由建立著色器來執行這些作業，以處理這些作業。</span><span class="sxs-lookup"><span data-stu-id="23fd4-283">These methods are not available in Direct3D 12, the app needs to handle these operations by creating shaders to perform them.</span></span>

## <a name="odds-and-ends"></a><span data-ttu-id="23fd4-284">機率和結束</span><span class="sxs-lookup"><span data-stu-id="23fd4-284">Odds and ends</span></span>

<span data-ttu-id="23fd4-285">下表顯示 Direct3D 11 和12之間有許多類似的功能，但不完全相同。</span><span class="sxs-lookup"><span data-stu-id="23fd4-285">The following table shows a number of features that are similar between Direct3D 11 and 12, but are not identical.</span></span>



| <span data-ttu-id="23fd4-286">Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="23fd4-286">Direct3D 11</span></span>                                                                            | <span data-ttu-id="23fd4-287">Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="23fd4-287">Direct3D 12</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                              |
|----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="23fd4-288">**ID3D11Query**</span><span class="sxs-lookup"><span data-stu-id="23fd4-288">**ID3D11Query**</span></span>](/windows/win32/api/d3d11/nn-d3d11-id3d11query)                                              | <span data-ttu-id="23fd4-289">[**ID3D12QueryHeap**](/windows/win32/api/d3d12/nn-d3d12-id3d12queryheap) 允許將查詢群組在一起，以降低成本。</span><span class="sxs-lookup"><span data-stu-id="23fd4-289">[**ID3D12QueryHeap**](/windows/win32/api/d3d12/nn-d3d12-id3d12queryheap) allows queries to be grouped together, reducing the cost.</span></span>                                                                                                                                                                                                                                                                                                                                     |
| [<span data-ttu-id="23fd4-290">**ID3D11Predicate**</span><span class="sxs-lookup"><span data-stu-id="23fd4-290">**ID3D11Predicate**</span></span>](/windows/win32/api/d3d11/nn-d3d11-id3d11predicate)                                      | <span data-ttu-id="23fd4-291">Predication 現在藉由在完全透明的緩衝區中提供資料來啟用。</span><span class="sxs-lookup"><span data-stu-id="23fd4-291">Predication is now enabled by having data in a fully transparent buffer.</span></span> <span data-ttu-id="23fd4-292">Direct3D 11 [**ID3D11Predicate**](/windows/win32/api/d3d11/nn-d3d11-id3d11predicate) 物件是由 [**ID3D12Resource：： Map**](/windows/win32/api/d3d12/nf-d3d12-id3d12resource-map)所取代，它必須遵循 [**ResolveQueryData**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvequerydata) 的呼叫，以及使用隔離來等候資料準備就緒的 GPU 同步作業。</span><span class="sxs-lookup"><span data-stu-id="23fd4-292">The Direct3D 11 [**ID3D11Predicate**](/windows/win32/api/d3d11/nn-d3d11-id3d11predicate) object is replaced by [**ID3D12Resource::Map**](/windows/win32/api/d3d12/nf-d3d12-id3d12resource-map), which must follow a call to [**ResolveQueryData**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvequerydata) and a GPU sync operation using a fence to wait for the data to be ready.</span></span> <span data-ttu-id="23fd4-293">請參閱 [Predication](predication.md)。</span><span class="sxs-lookup"><span data-stu-id="23fd4-293">Refer to [Predication](predication.md).</span></span> |
| <span data-ttu-id="23fd4-294">UAV/SO hidden 計數器</span><span class="sxs-lookup"><span data-stu-id="23fd4-294">UAV/SO hidden counter</span></span>                                                                  | <span data-ttu-id="23fd4-295">應用程式會負責配置和管理 UAV 計數器。</span><span class="sxs-lookup"><span data-stu-id="23fd4-295">The app is responsible for allocation and management of SO/UAV counters.</span></span> <span data-ttu-id="23fd4-296">請參閱 [Stream 輸出計數器](stream-output-counters.md) 和 [UAV 計數器](uav-counters.md)。</span><span class="sxs-lookup"><span data-stu-id="23fd4-296">Refer to [Stream Output Counters](stream-output-counters.md) and [UAV Counters](uav-counters.md).</span></span>                                                                                                                                                                                                                                                             |
| <span data-ttu-id="23fd4-297">資源動態 MinLOD (minium 現任層級的詳細資料) </span><span class="sxs-lookup"><span data-stu-id="23fd4-297">Resource dynamic MinLOD (minium level of detail)</span></span>                                       | <span data-ttu-id="23fd4-298">這已經移至 SRV 描述項靜態 MinLOD。</span><span class="sxs-lookup"><span data-stu-id="23fd4-298">This has been moved to the SRV descriptor static MinLOD.</span></span>                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="23fd4-299">繪製 \* 間接/[**DispatchIndirect**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-dispatchindirect)</span><span class="sxs-lookup"><span data-stu-id="23fd4-299">Draw\*Indirect/[**DispatchIndirect**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-dispatchindirect)</span></span> | <span data-ttu-id="23fd4-300">繪圖間接方法全都合併到一個 [**ExecuteIndirect**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-executeindirect) 方法中。</span><span class="sxs-lookup"><span data-stu-id="23fd4-300">Drawing indirect methods are all merged into the one [**ExecuteIndirect**](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-executeindirect) method.</span></span>                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="23fd4-301">DepthStencil 格式是交錯的</span><span class="sxs-lookup"><span data-stu-id="23fd4-301">DepthStencil formats are interleaved</span></span>                                                   | <span data-ttu-id="23fd4-302">DepthStencil 格式為平面。</span><span class="sxs-lookup"><span data-stu-id="23fd4-302">DepthStencil formats are planar.</span></span> <span data-ttu-id="23fd4-303">例如，24位深度的格式，將會以24/8/24/8 格式儲存8位的樣板 .。。在 Direct3D 11 中，但 24/24/24 .。。後面接著 8/8/8 .。。在 Direct3D 12 中。</span><span class="sxs-lookup"><span data-stu-id="23fd4-303">For example a format of 24 bits of depth, 8 bits of stencil would be stored in the format 24/8/24/8... etc in Direct3D 11, but as 24/24/24... followed by 8/8/8... in Direct3D 12.</span></span> <span data-ttu-id="23fd4-304">請注意，每個平面在 D3D12 中都是自己的 subresource (請參閱 [子資源](subresources.md)) 。</span><span class="sxs-lookup"><span data-stu-id="23fd4-304">Note that each plane is its own subresource in D3D12 (refer to [Subresources](subresources.md)).</span></span>                                                                                                                    |
| [<span data-ttu-id="23fd4-305">**ResizeTilePool**</span><span class="sxs-lookup"><span data-stu-id="23fd4-305">**ResizeTilePool**</span></span>](/windows/win32/api/d3d11_2/nf-d3d11_2-id3d11devicecontext2-resizetilepool)                   | <span data-ttu-id="23fd4-306">保留的資源可以對應至多個堆積。</span><span class="sxs-lookup"><span data-stu-id="23fd4-306">Reserved resources can be mapped to multiple heaps.</span></span> <span data-ttu-id="23fd4-307">當磚集區在 D3D11 中已成長時，可以改為在 D3D12 中配置額外的堆積。</span><span class="sxs-lookup"><span data-stu-id="23fd4-307">When a tile pool would have been grown in D3D11, an additional heap can be allocated in D3D12 instead.</span></span>                                                                                                                                                                                                                                                                               |



 

## <a name="related-topics"></a><span data-ttu-id="23fd4-308">相關主題</span><span class="sxs-lookup"><span data-stu-id="23fd4-308">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="23fd4-309">DirectX advanced learning 影片教學課程： DirectX 11 至 DirectX 12 移植指南</span><span class="sxs-lookup"><span data-stu-id="23fd4-309">DirectX advanced learning video tutorials : DirectX 11 to DirectX 12 porting guide</span></span>](https://www.youtube.com/watch?v=BV64mdOCgZo)
</dt> <dt>

[<span data-ttu-id="23fd4-310">瞭解 Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="23fd4-310">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
</dt> <dt>

[<span data-ttu-id="23fd4-311">使用 Direct3D 11、Direct3D 10 和 Direct2D</span><span class="sxs-lookup"><span data-stu-id="23fd4-311">Working with Direct3D 11, Direct3D 10 and Direct2D</span></span>](direct3d-12-interop.md)
</dt> </dl>