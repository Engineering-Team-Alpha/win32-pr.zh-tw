---
title: Direct3D 11 on 12
description: D3D11On12 是一種機制，開發人員可以使用 D3D11 介面和物件來驅動 D3D12 API。
ms.assetid: 8412D8BB-B6DD-471E-AAB2-A81121FB0FFA
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 62816ea0d7d7969cd56e0a9f525b2c412c8da182
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548355"
---
# <a name="direct3d-11-on-12"></a><span data-ttu-id="857c5-103">Direct3D 11 on 12</span><span class="sxs-lookup"><span data-stu-id="857c5-103">Direct3D 11 on 12</span></span>

<span data-ttu-id="857c5-104">D3D11On12 是一種機制，開發人員可以使用 D3D11 介面和物件來驅動 D3D12 API。</span><span class="sxs-lookup"><span data-stu-id="857c5-104">D3D11On12 is a mechanism by which developers can use D3D11 interfaces and objects to drive the D3D12 API.</span></span> <span data-ttu-id="857c5-105">D3D11on12 可讓使用 D3D11 撰寫的元件 (例如，D2D 文字和 UI) 與以 D3D12 API 為目標的元件一起運作。</span><span class="sxs-lookup"><span data-stu-id="857c5-105">D3D11on12 enables components written using D3D11 (for example, D2D text and UI) to work together with components written targeting the D3D12 API.</span></span> <span data-ttu-id="857c5-106">D3D11on12 也可讓應用程式從 D3D11 增量移植至 D3D12，方法是讓應用程式的某些部分繼續以較簡單的目標為目標，同時讓其他人以 D3D12 為效能，同時一律具有完整且正確的呈現。</span><span class="sxs-lookup"><span data-stu-id="857c5-106">D3D11on12 also enables incremental porting of an application from D3D11 to D3D12, by enabling portions of the app to continue targeting D3D11 for simplicity while others target D3D12 for performance, while always having complete and correct rendering.</span></span> <span data-ttu-id="857c5-107">D3D11On12 可讓您更輕鬆地使用 interop 技術來共用資源，並在兩個 Api 之間同步處理工作。</span><span class="sxs-lookup"><span data-stu-id="857c5-107">D3D11On12 makes it simpler than using interop techniques to share resources and synchronize work between the two APIs.</span></span>

-   [<span data-ttu-id="857c5-108">正在初始化 D3D11On12</span><span class="sxs-lookup"><span data-stu-id="857c5-108">Initializing D3D11On12</span></span>](#initializing-d3d11on12)
-   [<span data-ttu-id="857c5-109">使用方式範例</span><span class="sxs-lookup"><span data-stu-id="857c5-109">Example Usage</span></span>](#example-usage)
-   [<span data-ttu-id="857c5-110">背景</span><span class="sxs-lookup"><span data-stu-id="857c5-110">Background</span></span>](#background)
-   [<span data-ttu-id="857c5-111">清除</span><span class="sxs-lookup"><span data-stu-id="857c5-111">Cleaning up</span></span>](#cleaning-up)
-   [<span data-ttu-id="857c5-112">限制</span><span class="sxs-lookup"><span data-stu-id="857c5-112">Limitations</span></span>](#limitations)
-   [<span data-ttu-id="857c5-113">API</span><span class="sxs-lookup"><span data-stu-id="857c5-113">APIs</span></span>](#apis)
-   [<span data-ttu-id="857c5-114">相關主題</span><span class="sxs-lookup"><span data-stu-id="857c5-114">Related topics</span></span>](#related-topics)

## <a name="initializing-d3d11on12"></a><span data-ttu-id="857c5-115">正在初始化 D3D11On12</span><span class="sxs-lookup"><span data-stu-id="857c5-115">Initializing D3D11On12</span></span>

<span data-ttu-id="857c5-116">若要開始使用 D3D11On12，第一個步驟是建立 D3D12 裝置和命令佇列。</span><span class="sxs-lookup"><span data-stu-id="857c5-116">To begin using D3D11On12, the first step is to create a D3D12 device and command queue.</span></span> <span data-ttu-id="857c5-117">這些物件會以輸入的形式提供給初始化方法 [**D3D11On12CreateDevice**](/windows/desktop/api/d3d11on12/nf-d3d11on12-d3d11on12createdevice)。</span><span class="sxs-lookup"><span data-stu-id="857c5-117">These objects are provided as input to the initialization method [**D3D11On12CreateDevice**](/windows/desktop/api/d3d11on12/nf-d3d11on12-d3d11on12createdevice).</span></span> <span data-ttu-id="857c5-118">您可以將此方法視為使用虛構驅動程式類型 D3D \_ 驅動程式 \_ 類型11ON12 來建立 D3D11 裝置 \_ ，其中 D3D11 驅動程式負責建立物件，並將命令清單提交至 D3D12 API。</span><span class="sxs-lookup"><span data-stu-id="857c5-118">You can think of this method as creating a D3D11 device with the imaginary driver type D3D\_DRIVER\_TYPE\_11ON12, where the D3D11 driver is responsible for creating objects and submitting command lists to the D3D12 API.</span></span>

<span data-ttu-id="857c5-119">當您有 D3D11 裝置和立即內容之後，您就可以 `QueryInterface` 關閉 [**ID3D11On12Device**](/windows/desktop/api/d3d11on12/nn-d3d11on12-id3d11on12device) 介面的裝置。</span><span class="sxs-lookup"><span data-stu-id="857c5-119">After you have a D3D11 device and immediate context, you can `QueryInterface` off of the device for the [**ID3D11On12Device**](/windows/desktop/api/d3d11on12/nn-d3d11on12-id3d11on12device) interface.</span></span> <span data-ttu-id="857c5-120">這是用來在 D3D11 和 D3D12 之間進行 interop 的主要介面。</span><span class="sxs-lookup"><span data-stu-id="857c5-120">This is the primary interface that is used for interop between D3D11 and D3D12.</span></span> <span data-ttu-id="857c5-121">若要讓 D3D11 裝置內容和 D3D12 命令清單在相同的資源上運作，您必須使用 [**CreateWrappedResource**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-createwrappedresource) API 來建立「包裝的資源」。</span><span class="sxs-lookup"><span data-stu-id="857c5-121">In order to have both the D3D11 device context and the D3D12 command lists operate on the same resources, it is necessary to create “wrapped resources” using the [**CreateWrappedResource**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-createwrappedresource) API.</span></span> <span data-ttu-id="857c5-122">這個方法會「升級」 D3D12 資源，以便在 D3D11 中理解。</span><span class="sxs-lookup"><span data-stu-id="857c5-122">This method “promotes” a D3D12 resource to be understandable in D3D11.</span></span> <span data-ttu-id="857c5-123">已包裝的資源會以「已取得」狀態開始，這是由 [**AcquireWrappedResources**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-acquirewrappedresources) 和 [**ReleaseWrappedResources**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-releasewrappedresources) 方法操作的屬性。</span><span class="sxs-lookup"><span data-stu-id="857c5-123">A wrapped resource starts out in the “acquired” state, a property which is manipulated by the [**AcquireWrappedResources**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-acquirewrappedresources) and [**ReleaseWrappedResources**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-releasewrappedresources) methods.</span></span>

## <a name="example-usage"></a><span data-ttu-id="857c5-124">使用方式範例</span><span class="sxs-lookup"><span data-stu-id="857c5-124">Example Usage</span></span>

<span data-ttu-id="857c5-125">D3D11On12 的一般用法是使用 D2D，在 D3D12 背景緩衝區的上方呈現文字或影像。</span><span class="sxs-lookup"><span data-stu-id="857c5-125">Typical usage of D3D11On12 would be to use D2D to render text or images on top of a D3D12 back buffer.</span></span> <span data-ttu-id="857c5-126">如需範例程式碼，請參閱 D3D11On12 範例。</span><span class="sxs-lookup"><span data-stu-id="857c5-126">See the D3D11On12 sample for example code.</span></span> <span data-ttu-id="857c5-127">以下是執行此動作所需採取步驟的粗略概述：</span><span class="sxs-lookup"><span data-stu-id="857c5-127">Here is a rough outline of the steps to take to do so:</span></span>

-   <span data-ttu-id="857c5-128">使用 [**ID3D12CommandQueue**](/windows/desktop/api/d3d12/nn-d3d12-id3d12commandqueue)作為輸入) ，建立 D3D12 裝置 ([**D3D12CREATEDEVICE**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice)) 和 D3D12 交換鏈 ([**CreateSwapChain**](/windows/desktop/api/dxgi/nf-dxgi-idxgifactory-createswapchain) 。</span><span class="sxs-lookup"><span data-stu-id="857c5-128">Create a D3D12 device ([**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice)) and a D3D12 swap chain ([**CreateSwapChain**](/windows/desktop/api/dxgi/nf-dxgi-idxgifactory-createswapchain) with an [**ID3D12CommandQueue**](/windows/desktop/api/d3d12/nn-d3d12-id3d12commandqueue) as an input).</span></span>
-   <span data-ttu-id="857c5-129">使用 D3D12 裝置和與輸入相同的命令佇列來建立 D3D11On12 裝置。</span><span class="sxs-lookup"><span data-stu-id="857c5-129">Create a D3D11On12 device using the D3D12 device and the same command queue as input.</span></span>
-   <span data-ttu-id="857c5-130">取出交換鏈回緩衝區，並為每個緩衝區建立 D3D11 包裝的資源。</span><span class="sxs-lookup"><span data-stu-id="857c5-130">Retrieve the swap chain back buffers, and create D3D11 wrapped resources for each of them.</span></span> <span data-ttu-id="857c5-131">使用的輸入狀態應該是 D3D12 使用它的最後一種方式 (例如，轉譯 \_ 目標) 和輸出狀態應該是 D3D12 在 D3D11 (完成後使用它的方式，例如存在) 。</span><span class="sxs-lookup"><span data-stu-id="857c5-131">The input state used should be the last way that D3D12 used it (e.g. RENDER\_TARGET) and the output state should be the way that D3D12 will use it after D3D11 has finished (e.g. PRESENT).</span></span>
-   <span data-ttu-id="857c5-132">初始化 D2D，並將 D3D11 包裝的資源提供給 D2D，以準備進行轉譯。</span><span class="sxs-lookup"><span data-stu-id="857c5-132">Initialize D2D, and provide the D3D11 wrapped resources to D2D to prepare for rendering.</span></span>

<span data-ttu-id="857c5-133">然後，在每個畫面上，執行下列動作：</span><span class="sxs-lookup"><span data-stu-id="857c5-133">Then, on each frame, do the following:</span></span>

-   <span data-ttu-id="857c5-134">使用 D3D12 命令清單轉譯成目前的交換鏈回緩衝區，然後執行它。</span><span class="sxs-lookup"><span data-stu-id="857c5-134">Render into the current swap chain back buffer using a D3D12 command list, and execute it.</span></span>
-   <span data-ttu-id="857c5-135">取得目前的背景緩衝區包裝資源 ([**AcquireWrappedResources**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-acquirewrappedresources)) 。</span><span class="sxs-lookup"><span data-stu-id="857c5-135">Acquire the current back buffer’s wrapped resource ([**AcquireWrappedResources**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-acquirewrappedresources)).</span></span>
-   <span data-ttu-id="857c5-136">發出 D2D 轉譯命令。</span><span class="sxs-lookup"><span data-stu-id="857c5-136">Issue D2D rendering commands.</span></span>
-   <span data-ttu-id="857c5-137"> ([**ReleaseWrappedResources**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-releasewrappedresources)) 釋放包裝的資源。</span><span class="sxs-lookup"><span data-stu-id="857c5-137">Release the wrapped resource ([**ReleaseWrappedResources**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-releasewrappedresources)).</span></span>
-   <span data-ttu-id="857c5-138">清除 D3D11 立即內容。</span><span class="sxs-lookup"><span data-stu-id="857c5-138">Flush the D3D11 immediate context.</span></span>
-   <span data-ttu-id="857c5-139">提供 ([**IDXGISwapChain1：:P resent1**](/windows/desktop/api/dxgi1_2/nf-dxgi1_2-idxgiswapchain1-present1)) 。</span><span class="sxs-lookup"><span data-stu-id="857c5-139">Present ([**IDXGISwapChain1::Present1**](/windows/desktop/api/dxgi1_2/nf-dxgi1_2-idxgiswapchain1-present1)).</span></span>

## <a name="background"></a><span data-ttu-id="857c5-140">背景</span><span class="sxs-lookup"><span data-stu-id="857c5-140">Background</span></span>

<span data-ttu-id="857c5-141">D3D11On12 有系統地運作。</span><span class="sxs-lookup"><span data-stu-id="857c5-141">D3D11On12 works systematically.</span></span> <span data-ttu-id="857c5-142">每個 D3D11 API 呼叫都會經歷一般的執行時間驗證，並將其傳送至驅動程式。</span><span class="sxs-lookup"><span data-stu-id="857c5-142">Each D3D11 API call goes through the typical runtime validation and makes its way to the driver.</span></span> <span data-ttu-id="857c5-143">在驅動層，特殊的11on12 驅動程式會將狀態和問題轉譯作業記錄到 D3D12 命令清單。</span><span class="sxs-lookup"><span data-stu-id="857c5-143">At the driver layer, the special 11on12 driver records state and issues render operations to D3D12 command lists.</span></span> <span data-ttu-id="857c5-144">這些命令清單會視需要提交 (例如，查詢 `GetData` 或資源 `Map` 可能需要將命令排清) 或由排清要求。</span><span class="sxs-lookup"><span data-stu-id="857c5-144">These command lists are submitted as necessary (for example, a query `GetData` or resource `Map` might require commands to be flushed) or as requested by Flush.</span></span> <span data-ttu-id="857c5-145">建立 D3D11 物件通常會導致建立對應的 D3D12 物件。</span><span class="sxs-lookup"><span data-stu-id="857c5-145">Creating a D3D11 object typically results in the corresponding D3D12 object being created.</span></span> <span data-ttu-id="857c5-146">D3D12 不支援 D3D11 中的某些固定函式轉譯作業（例如 `GenerateMips` 或） `DrawAuto` ，因此 D3D11On12 會使用著色器和其他資源來模擬它們。</span><span class="sxs-lookup"><span data-stu-id="857c5-146">Some fixed function render operations in D3D11 such as `GenerateMips` or `DrawAuto` are not supported in D3D12, and so D3D11On12 emulates them using shaders and additional resources.</span></span>

<span data-ttu-id="857c5-147">針對 interop，請務必瞭解 D3D11On12 如何與應用程式建立並提供的 D3D12 物件互動。</span><span class="sxs-lookup"><span data-stu-id="857c5-147">For interop, it’s important to understand how D3D11On12 interacts with the D3D12 objects that the app has created and provided.</span></span> <span data-ttu-id="857c5-148">為了確保工作會以正確的順序進行，必須先清除 D3D11 立即內容，才能將其他 D3D12 工作提交至該佇列。</span><span class="sxs-lookup"><span data-stu-id="857c5-148">In order to ensure that work happens in the correct order, the D3D11 immediate context must be flushed before additional D3D12 work can be submitted to that queue.</span></span> <span data-ttu-id="857c5-149">也請務必確保提供給 D3D11On12 的佇列必須隨時 drainable。</span><span class="sxs-lookup"><span data-stu-id="857c5-149">It’s also important to ensure that the queue given to D3D11On12 must be drainable at all times.</span></span> <span data-ttu-id="857c5-150">這表示最後必須滿足佇列上的任何等候，即使 D3D11 轉譯執行緒無限期封鎖也是如此。</span><span class="sxs-lookup"><span data-stu-id="857c5-150">That means that any waits on the queue must eventually be satisfied, even if the D3D11 render thread blocks indefinitely.</span></span> <span data-ttu-id="857c5-151">在 D3D11On12 插入排清或等候時，請務必小心，因為未來版本可能會變更。</span><span class="sxs-lookup"><span data-stu-id="857c5-151">Be wary not to take a dependency on when D3D11On12 inserts flushes or waits, as this may change with future releases.</span></span> <span data-ttu-id="857c5-152">此外，D3D11On12 會自行追蹤和操作資源狀態。</span><span class="sxs-lookup"><span data-stu-id="857c5-152">Additionally, D3D11On12 tracks and manipulates resource states on its own.</span></span> <span data-ttu-id="857c5-153">確保狀態轉換一致性的唯一方法，是利用取得/發行 Api 來操作狀態追蹤，以符合應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="857c5-153">The only way to ensure coherency of state transitions is to make use of the acquire/release APIs to manipulate the state tracking to match the app’s needs.</span></span>

## <a name="cleaning-up"></a><span data-ttu-id="857c5-154">清除</span><span class="sxs-lookup"><span data-stu-id="857c5-154">Cleaning up</span></span>

<span data-ttu-id="857c5-155">若要釋放 D3D11On12 包裝的資源，必須依照下列順序進行兩件事：</span><span class="sxs-lookup"><span data-stu-id="857c5-155">In order to release a D3D11On12 wrapped resource, two things need to happen in this order:</span></span>

-   <span data-ttu-id="857c5-156">所有對資源的參考（包括資源的任何視圖）都必須釋放。</span><span class="sxs-lookup"><span data-stu-id="857c5-156">All references to the resource, including any views of the resource, need to be released.</span></span>
-   <span data-ttu-id="857c5-157">必須進行延遲的銷毀處理。</span><span class="sxs-lookup"><span data-stu-id="857c5-157">Deferred destruction processing must take place.</span></span> <span data-ttu-id="857c5-158">確保發生此情況的最簡單方式是叫用立即內容 `Flush` API。</span><span class="sxs-lookup"><span data-stu-id="857c5-158">The simplest way to ensure this happens is to invoke the immediate context `Flush` API.</span></span>

<span data-ttu-id="857c5-159">這兩個步驟都完成之後，應該釋出包裝資源所採取的任何參考，D3D12 資源就會成為 D3D12 元件的獨佔擁有者。</span><span class="sxs-lookup"><span data-stu-id="857c5-159">After both of those steps are completed, any references taken by the wrapped resource should be released, and the D3D12 resource becomes exclusively owned by the D3D12 component.</span></span> <span data-ttu-id="857c5-160">請注意，D3D12 仍然需要在完全釋出資源之前等候 GPU 完成，因此在執行上述兩個步驟之前，請務必先保留資源的參考，除非您已確認 GPU 不再使用該資源。</span><span class="sxs-lookup"><span data-stu-id="857c5-160">Be aware that D3D12 still requires waiting for GPU completion before completely releasing a resource, so be sure to hold a reference on the resource before doing the two steps above, unless you’ve already confirmed that the GPU is no longer using the resource.</span></span>

<span data-ttu-id="857c5-161">D3D11On12 所建立的所有其他資源或物件，會在 GPU 完成使用時（使用 D3D11's 延遲的銷毀機制），于適當的時間清除。</span><span class="sxs-lookup"><span data-stu-id="857c5-161">All other resources or objects created by D3D11On12 will be cleaned up at the appropriate time, when the GPU has finished using them, using D3D11’s deferred destruction mechanism.</span></span> <span data-ttu-id="857c5-162">但是，如果您在 GPU 仍在執行時嘗試釋放 D3D11On12 裝置本身，則可能會封鎖終結，直到 GPU 完成為止。</span><span class="sxs-lookup"><span data-stu-id="857c5-162">However if you attempt to release the D3D11On12 device itself while the GPU is still executing, the destruction may block until the GPU completes.</span></span>

## <a name="limitations"></a><span data-ttu-id="857c5-163">限制</span><span class="sxs-lookup"><span data-stu-id="857c5-163">Limitations</span></span>

<span data-ttu-id="857c5-164">D3D11On12 層會實作為 D3D11 API 的一小部分，但除了可能會導致轉譯) 不正確的之外，還有一些已知的間隙 (。</span><span class="sxs-lookup"><span data-stu-id="857c5-164">The D3D11On12 layer implements a very large subset of the D3D11 API, but there are some known gaps (in addition to bugs in the implementation that can cause incorrect rendering).</span></span>

<span data-ttu-id="857c5-165">從 Windows 10 版本 1809 (10.0;組建 17763) ，只要 D3D11On12 在支援著色器模型6.0 或更新版本的驅動程式上執行，就可以執行使用介面的著色器。</span><span class="sxs-lookup"><span data-stu-id="857c5-165">As of Windows 10, version 1809 (10.0; Build 17763), as long as D3D11On12 is running on a driver that supports Shader Model 6.0 or later, then it can run shaders that use interfaces.</span></span> <span data-ttu-id="857c5-166">在舊版的 Windows 中，著色器介面功能不會在 D3D11On12 中執行，而且嘗試使用此功能將會造成錯誤和偵錯工具訊息。</span><span class="sxs-lookup"><span data-stu-id="857c5-166">In earlier versions of Windows, the shader interfaces feature is not implemented in D3D11On12, and attempting to use the feature will cause errors and debug messages.</span></span>

<span data-ttu-id="857c5-167">從 Windows 10 版本 1803 (10.0;組建 17134) ，D3D11On12 裝置上支援交換鏈。</span><span class="sxs-lookup"><span data-stu-id="857c5-167">As of Windows 10, version 1803 (10.0; Build 17134), swap chains are supported on D3D11On12 devices.</span></span> <span data-ttu-id="857c5-168">在舊版的 Windows 中，則不是。</span><span class="sxs-lookup"><span data-stu-id="857c5-168">In earlier versions of Windows, they are not.</span></span>

<span data-ttu-id="857c5-169">D3D11On12 尚未針對效能優化。</span><span class="sxs-lookup"><span data-stu-id="857c5-169">D3D11On12 has not been optimized for performance.</span></span> <span data-ttu-id="857c5-170">相較于標準 D3D11 驅動程式、最少量的 GPU 額外負荷，以及已知的記憶體額外負荷，可能會有適中的 CPU 負擔。</span><span class="sxs-lookup"><span data-stu-id="857c5-170">There will likely be moderate CPU overhead compared to a standard D3D11 driver, minimal GPU overhead, and there is known to be significant memory overhead.</span></span> <span data-ttu-id="857c5-171">因此，不建議將 D3D11On12 用於複雜的3D 場景，而是改為使用簡單的場景或2D 轉譯。</span><span class="sxs-lookup"><span data-stu-id="857c5-171">Therefore it is not recommended to use D3D11On12 for complicated 3D scenes, and it is instead recommended for simple scenes, or 2D rendering.</span></span>

## <a name="apis"></a><span data-ttu-id="857c5-172">API</span><span class="sxs-lookup"><span data-stu-id="857c5-172">APIs</span></span>

<span data-ttu-id="857c5-173">組成11on12 層的 Api 說明于 [11On12 參考](direct3d-11on12-reference.md)中。</span><span class="sxs-lookup"><span data-stu-id="857c5-173">APIs that make up the 11on12 layer are described in [11on12 Reference](direct3d-11on12-reference.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="857c5-174">相關主題</span><span class="sxs-lookup"><span data-stu-id="857c5-174">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="857c5-175">使用 D3D11on12 逐步解說的 D2D</span><span class="sxs-lookup"><span data-stu-id="857c5-175">D2D using D3D11on12 walk-through</span></span>](d2d-using-d3d11on12.md)
</dt> <dt>

[<span data-ttu-id="857c5-176">瞭解 Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="857c5-176">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
</dt> <dt>

[<span data-ttu-id="857c5-177">使用 Direct3D 11、Direct3D 10 和 Direct2D</span><span class="sxs-lookup"><span data-stu-id="857c5-177">Working with Direct3D 11, Direct3D 10 and Direct2D</span></span>](direct3d-12-interop.md)
</dt> </dl>

 

 