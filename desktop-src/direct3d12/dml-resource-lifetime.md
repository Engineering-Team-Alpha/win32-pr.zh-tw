---
title: 資源存留期和同步處理
description: 為了避免未定義的行為，您的 DirectML 應用程式必須正確地管理 CPU 與 GPU 之間的物件存留期和同步處理。
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: 6e8ab30c5c87c135ef3bdac0c1bc2a3d64040787
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104031"
---
# <a name="resource-lifetime-and-synchronization"></a><span data-ttu-id="9c583-103">資源存留期和同步處理</span><span class="sxs-lookup"><span data-stu-id="9c583-103">Resource lifetime and synchronization</span></span>

<span data-ttu-id="9c583-104">如同 Direct3D 12，您的 DirectML 應用程式必須 (，才能避免未定義的行為) 正確地管理 CPU 與 GPU 之間的物件存留期和同步處理。</span><span class="sxs-lookup"><span data-stu-id="9c583-104">Just as with Direct3D 12, your DirectML application must (in order to avoid undefined behavior) correctly manage object lifetimes and synchronization between the CPU and the GPU.</span></span> <span data-ttu-id="9c583-105">DirectML 會遵循與 Direct3D 12 相同的資源存留期模型。</span><span class="sxs-lookup"><span data-stu-id="9c583-105">DirectML follows an identical resource lifetime model to that of Direct3D 12.</span></span>

- <span data-ttu-id="9c583-106">使用強式參考計數的 DirectML 會維護兩個 CPU 物件之間的存留期相依性。</span><span class="sxs-lookup"><span data-stu-id="9c583-106">Lifetime dependencies between two CPU objects are maintained by DirectML using strong reference counts.</span></span> <span data-ttu-id="9c583-107">您的應用程式不會手動管理 CPU 存留期相依性。</span><span class="sxs-lookup"><span data-stu-id="9c583-107">Your application needn't manually manage CPU lifetime dependencies.</span></span> <span data-ttu-id="9c583-108">例如，每個子裝置都會保存其父裝置的強式參考。</span><span class="sxs-lookup"><span data-stu-id="9c583-108">For example, every device child holds a strong reference to its parent device.</span></span>
- <span data-ttu-id="9c583-109">GPU 物件或跨 CPU 和 GPU 的相依性之間的存留期相依性 &mdash; &mdash; 不會自動受到管理。</span><span class="sxs-lookup"><span data-stu-id="9c583-109">Lifetime dependencies between GPU objects&mdash;or dependencies that span across CPU and GPU&mdash;aren't automatically managed.</span></span> <span data-ttu-id="9c583-110">您的應用程式必須負責確保 GPU 資源至少存留到所有使用該資源的工作在 GPU 上執行完畢。</span><span class="sxs-lookup"><span data-stu-id="9c583-110">It's your application's responsibility to ensure that GPU resources live at least until all work using that resource has completed execution on the GPU.</span></span>

## <a name="directml-devices"></a><span data-ttu-id="9c583-111">DirectML 裝置</span><span class="sxs-lookup"><span data-stu-id="9c583-111">DirectML devices</span></span>

<span data-ttu-id="9c583-112">DirectML 裝置是安全線程的無狀態 factory 物件。</span><span class="sxs-lookup"><span data-stu-id="9c583-112">The DirectML device is a thread-safe stateless factory object.</span></span> <span data-ttu-id="9c583-113">每個子裝置 (查看 [**IDMLDeviceChild**](/windows/desktop/api/directml/nn-directml-idmldevicechild)) 保存其父 DirectML 裝置的強式參考 (查看 [**IDMLDevice**](/windows/desktop/api/directml/nn-directml-idmldevice)) 。</span><span class="sxs-lookup"><span data-stu-id="9c583-113">Every device child (see [**IDMLDeviceChild**](/windows/desktop/api/directml/nn-directml-idmldevicechild)) holds a strong reference to its parent DirectML device (see [**IDMLDevice**](/windows/desktop/api/directml/nn-directml-idmldevice)).</span></span> <span data-ttu-id="9c583-114">這表示您一律可以從任何裝置子介面取出父裝置介面。</span><span class="sxs-lookup"><span data-stu-id="9c583-114">That means that you can always retrieve the parent device interface from any device child interface.</span></span>

<span data-ttu-id="9c583-115">接著，DirectML 裝置會保存用來建立它之 Direct3D 12 裝置的強式參考 (請參閱 [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device)和衍生介面) 。</span><span class="sxs-lookup"><span data-stu-id="9c583-115">A DirectML device in turn holds a strong reference to the Direct3D 12 device that was used to create it (see [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device), and derived interfaces).</span></span>

<span data-ttu-id="9c583-116">因為 DirectML 裝置是無狀態的，所以它是隱含執行緒安全的。</span><span class="sxs-lookup"><span data-stu-id="9c583-116">Because the DirectML device is stateless, it's implicitly thread-safe.</span></span> <span data-ttu-id="9c583-117">您可以同時從多個執行緒呼叫 DirectML 裝置上的方法，而不需要外部同步處理。</span><span class="sxs-lookup"><span data-stu-id="9c583-117">You may call methods on the DirectML device from multiple threads simultaneously without the need for external synchronization.</span></span>

<span data-ttu-id="9c583-118">不過，與 Direct3D 12 裝置不同的是，DirectML 裝置不是單一物件。</span><span class="sxs-lookup"><span data-stu-id="9c583-118">However, unlike the Direct3D 12 device, the DirectML device is not a singleton object.</span></span> <span data-ttu-id="9c583-119">您可以視需要任意建立多個 DirectML 裝置。</span><span class="sxs-lookup"><span data-stu-id="9c583-119">You're free to create as many DirectML devices as you wish.</span></span> <span data-ttu-id="9c583-120">不過，您不能混搭屬於不同裝置的裝置子系。</span><span class="sxs-lookup"><span data-stu-id="9c583-120">However, you may not mix and match device children that belong to different devices.</span></span> <span data-ttu-id="9c583-121">例如， [**IDMLBindingTable**](/windows/desktop/api/directml/nn-directml-idmlbindingtable) 和 [**IDMLCompiledOperator**](/windows/desktop/api/directml/nn-directml-idmlcompiledoperator) 是兩種裝置子系 (這兩個介面都是直接或間接衍生自 **IDMLDeviceChild**) 。</span><span class="sxs-lookup"><span data-stu-id="9c583-121">For example, [**IDMLBindingTable**](/windows/desktop/api/directml/nn-directml-idmlbindingtable) and [**IDMLCompiledOperator**](/windows/desktop/api/directml/nn-directml-idmlcompiledoperator) are two kinds of device children (both interfaces derive directly or indirectly from **IDMLDeviceChild**).</span></span> <span data-ttu-id="9c583-122">當運算子和系結資料表屬於不同的 DirectML 裝置實例時，您可能不會使用系結表 (**IDMLBindingTable**) 系結 (**IDMLCompiledOperator**) 。</span><span class="sxs-lookup"><span data-stu-id="9c583-122">And you may not use a binding table (**IDMLBindingTable**) to bind for an operator (**IDMLCompiledOperator**) if the operator and the binding table belong to different DirectML device instances.</span></span>

<span data-ttu-id="9c583-123">由於 DirectML 裝置不是單一裝置，因此裝置移除會以每個裝置為基礎，而不是整個進程的事件，因為它適用于 Direct3D 12 裝置。</span><span class="sxs-lookup"><span data-stu-id="9c583-123">Because the DirectML device is not a singleton, device removal occurs on a per-device basis, rather than being a process-wide event as it is for a Direct3D 12 device.</span></span> <span data-ttu-id="9c583-124">如需詳細資訊，請參閱 [在 DirectML 中處理錯誤和移除裝置](dml-errors.md)。</span><span class="sxs-lookup"><span data-stu-id="9c583-124">For more information, see [Handling errors and device removal in DirectML](dml-errors.md).</span></span>

## <a name="lifetime-requirements-of-gpu-resources"></a><span data-ttu-id="9c583-125">GPU 資源的存留期需求</span><span class="sxs-lookup"><span data-stu-id="9c583-125">Lifetime requirements of GPU resources</span></span>

<span data-ttu-id="9c583-126">和 Direct3D 12 一樣，DirectML 不會自動在 CPU 與 GPU 之間進行同步處理。此外，它也不會在 GPU 使用資源時，自動將資源保持在運作狀態。</span><span class="sxs-lookup"><span data-stu-id="9c583-126">Like Direct3D 12, DirectML doesn't automatically synchronize between the CPU and GPU; nor does it automatically keep resources alive while they're in use by the GPU.</span></span> <span data-ttu-id="9c583-127">相反地，這些是您應用程式的責任。</span><span class="sxs-lookup"><span data-stu-id="9c583-127">Instead, these are responsibilities of your application.</span></span>

<span data-ttu-id="9c583-128">執行包含 DirectML 分派的命令清單時，您的應用程式必須確保 GPU 資源保持運作，直到使用這些資源的所有工作都已在 GPU 上執行完畢為止。</span><span class="sxs-lookup"><span data-stu-id="9c583-128">When executing a command list that contains DirectML dispatches, your application must ensure that GPU resources are kept alive until all work using those resources has completed execution on the GPU.</span></span>

<span data-ttu-id="9c583-129">若為 DirectML 運算子的 [**IDMLCommandRecorder：： RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) ，其中包含下列物件。</span><span class="sxs-lookup"><span data-stu-id="9c583-129">In the case of [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) for a DirectML operator, that includes the following objects.</span></span>

- <span data-ttu-id="9c583-130"> (或 [**IDMLOperatorInitializer**](/windows/desktop/api/directml/nn-directml-idmloperatorinitializer)執行的 [**IDMLCompiledOperator**](/windows/desktop/api/directml/nn-directml-idmlcompiledoperator)會改為執行) 的運算子初始化。</span><span class="sxs-lookup"><span data-stu-id="9c583-130">The [**IDMLCompiledOperator**](/windows/desktop/api/directml/nn-directml-idmlcompiledoperator) being executed (or [**IDMLOperatorInitializer**](/windows/desktop/api/directml/nn-directml-idmloperatorinitializer) instead, if performing operator initialization).</span></span>
- <span data-ttu-id="9c583-131">**IDMLCompiledOperator** 支援用來系結運算子的系結資料表。</span><span class="sxs-lookup"><span data-stu-id="9c583-131">The **IDMLCompiledOperator** backing the binding table being used to bind the operator.</span></span>
- <span data-ttu-id="9c583-132">系結為運算子之輸入/輸出的 [**ID3D12Resource**](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) 物件。</span><span class="sxs-lookup"><span data-stu-id="9c583-132">The [**ID3D12Resource**](/windows/desktop/api/d3d12/nn-d3d12-id3d12resource) objects bound as the inputs/outputs of the operator.</span></span>
- <span data-ttu-id="9c583-133">系結為持續性和暫存資源的 **ID3D12Resource** 物件（如果適用）。</span><span class="sxs-lookup"><span data-stu-id="9c583-133">The **ID3D12Resource** objects bound as persistent and temporary resources, if applicable.</span></span>
- <span data-ttu-id="9c583-134">支援命令清單本身的 [**ID3D12CommandAllocator**](/windows/desktop/api/d3d12/nn-d3d12-id3d12commandallocator) 。</span><span class="sxs-lookup"><span data-stu-id="9c583-134">The [**ID3D12CommandAllocator**](/windows/desktop/api/d3d12/nn-d3d12-id3d12commandallocator) backing the command list itself.</span></span>

<span data-ttu-id="9c583-135">並非所有 DirectML 介面都代表 GPU 資源。</span><span class="sxs-lookup"><span data-stu-id="9c583-135">Not all DirectML interfaces represent GPU resources.</span></span> <span data-ttu-id="9c583-136">例如，系結資料表 *不* 需要保持運作，直到使用它的所有分派都已在 GPU 上完成執行為止。</span><span class="sxs-lookup"><span data-stu-id="9c583-136">For example, a binding table does *not* need to be kept alive until all dispatches using it have completed execution on the GPU.</span></span> <span data-ttu-id="9c583-137">這是因為系結資料表本身不會擁有任何 GPU 資源。</span><span class="sxs-lookup"><span data-stu-id="9c583-137">That's because the binding table itself doesn't own any GPU resources.</span></span> <span data-ttu-id="9c583-138">相反地，描述項堆積會執行。</span><span class="sxs-lookup"><span data-stu-id="9c583-138">Rather, the descriptor heap does.</span></span> <span data-ttu-id="9c583-139">因此，基礎 *描述元堆積* 是必須保持運作，直到執行完成為止，而不是系結資料表本身的物件。</span><span class="sxs-lookup"><span data-stu-id="9c583-139">Therefore, the underlying *descriptor heap* is the object that must be kept alive until execution completes, and not the binding table itself.</span></span>

<span data-ttu-id="9c583-140">Direct3D 12 中有類似的概念。</span><span class="sxs-lookup"><span data-stu-id="9c583-140">A similar concept exists in Direct3D 12.</span></span> <span data-ttu-id="9c583-141">*命令配置* 器必須保持運作，直到所有使用它的執行都已在 GPU 上完成為止;因為它擁有 GPU 記憶體。</span><span class="sxs-lookup"><span data-stu-id="9c583-141">A command *allocator* must be kept alive until all executions using it have completed on the GPU; since it owns GPU memory.</span></span> <span data-ttu-id="9c583-142">但是，命令 *清單* 不會擁有 GPU 記憶體，因此可以在提交執行時立即重設或釋放。</span><span class="sxs-lookup"><span data-stu-id="9c583-142">But, a command *list* doesn't own GPU memory, so it can therefore be reset or released as soon as it's been submitted for execution.</span></span>

<span data-ttu-id="9c583-143">在 DirectML 中，編譯的運算子 ([**IDMLCompiledOperator**](/windows/desktop/api/directml/nn-directml-idmlcompiledoperator)) 和運算子初始化運算式 ([**IDMLOperatorInitializer**](/windows/desktop/api/directml/nn-directml-idmloperatorinitializer)) 直接的 gpu 資源，因此必須保持運作，直到使用它們的所有分派都已在 GPU 上完成執行為止。</span><span class="sxs-lookup"><span data-stu-id="9c583-143">In DirectML, compiled operators ([**IDMLCompiledOperator**](/windows/desktop/api/directml/nn-directml-idmlcompiledoperator)) and operator initializers ([**IDMLOperatorInitializer**](/windows/desktop/api/directml/nn-directml-idmloperatorinitializer)) both own GPU resources directly, so they must be kept alive until all dispatches using them have completed execution on the GPU.</span></span> <span data-ttu-id="9c583-144">此外，使用 (命令配置器、描述元堆積、緩衝區) 的任何 Direct3D 12 資源，都必須以同樣的方式，讓應用程式保持運作。</span><span class="sxs-lookup"><span data-stu-id="9c583-144">In addition, any Direct3D 12 resource being used (command allocators, descriptor heaps, buffers, as examples) must similarly be kept alive by your application.</span></span>

<span data-ttu-id="9c583-145">如果您在 GPU 仍在使用時，提前釋出物件，結果會是未定義的行為，這可能會導致裝置移除或其他錯誤。</span><span class="sxs-lookup"><span data-stu-id="9c583-145">If you prematurely release an object while it's still in use by the GPU, the result is undefined behavior, which has the potential to cause device removal or other errors.</span></span>

## <a name="cpu-and-gpu-synchronization"></a><span data-ttu-id="9c583-146">CPU 和 GPU 同步處理</span><span class="sxs-lookup"><span data-stu-id="9c583-146">CPU and GPU synchronization</span></span>

<span data-ttu-id="9c583-147">DirectML 本身不會提交在 GPU 上執行的任何工作。</span><span class="sxs-lookup"><span data-stu-id="9c583-147">DirectML doesn't itself submit any work for execution on the GPU.</span></span> <span data-ttu-id="9c583-148">相反地， [ **IDMLCommandRecorder：： RecordDispatch** 方法](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)會將該工作的分派 *記錄* 到命令清單中，以供稍後執行。</span><span class="sxs-lookup"><span data-stu-id="9c583-148">Instead, the [**IDMLCommandRecorder::RecordDispatch** method](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) *records* the dispatch of that work into a command list for later execution.</span></span> <span data-ttu-id="9c583-149">然後，您的應用程式必須藉由呼叫 [**ID3D12CommandQueue：： ExecuteCommandLists**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists)（如同任何 Direct3D 12 命令清單）來關閉並提交其命令清單以供執行。</span><span class="sxs-lookup"><span data-stu-id="9c583-149">Your application must then close and submit its command list for execution by calling [**ID3D12CommandQueue::ExecuteCommandLists**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists), as with any Direct3D 12 command list.</span></span>

<span data-ttu-id="9c583-150">因為 DirectML 本身不會提交任何在 GPU 上執行的工作，所以它也不會建立任何 GPU，也不會代表您執行任何形式的 CPU/GPU 同步處理。</span><span class="sxs-lookup"><span data-stu-id="9c583-150">Because DirectML doesn't itself submit any work for execution on the GPU, it also doesn't create any fences, nor perform any form of CPU/GPU synchronization on your behalf.</span></span> <span data-ttu-id="9c583-151">您的應用程式必須負責使用適當的 Direct3D 12 基本專案，以等候提交的工作在 GPU 上完成執行（如有必要）。</span><span class="sxs-lookup"><span data-stu-id="9c583-151">It is the responsibility of your application to use the appropriate Direct3D 12 primitives to wait for submitted work to complete execution on the GPU, if necessary.</span></span> <span data-ttu-id="9c583-152">如需詳細資訊，請參閱 [**ID3D12Fence**](/windows/desktop/api/d3d12/nn-d3d12-id3d12fence) 和 [**ID3D12CommandQueue：：信號**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-signal)。</span><span class="sxs-lookup"><span data-stu-id="9c583-152">For more info, see [**ID3D12Fence**](/windows/desktop/api/d3d12/nn-d3d12-id3d12fence) and [**ID3D12CommandQueue::Signal**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-signal).</span></span>

## <a name="see-also"></a><span data-ttu-id="9c583-153">另請參閱</span><span class="sxs-lookup"><span data-stu-id="9c583-153">See also</span></span>

* [<span data-ttu-id="9c583-154">執行和同步處理命令清單</span><span class="sxs-lookup"><span data-stu-id="9c583-154">Executing and synchronizing command lists</span></span>](/windows/desktop/direct3d12/executing-and-synchronizing-command-lists)
* [<span data-ttu-id="9c583-155">處理 DirectML 中的錯誤和裝置移除</span><span class="sxs-lookup"><span data-stu-id="9c583-155">Handling errors and device removal in DirectML</span></span>](dml-errors.md)