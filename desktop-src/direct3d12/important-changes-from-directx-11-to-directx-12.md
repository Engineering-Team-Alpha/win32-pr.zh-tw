---
title: 從 Direct3D 11 到 Direct3D 12 的重要變更
description: Direct3D 12 代表來自 Direct3D 11 程式設計模型的重大起飛。 Direct3D 12 讓應用程式比以往更接近硬體。
ms.assetid: CE5066C9-7EA6-437D-9EB0-AACFB6CFAD9E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5be891d71d6c1f3a12d8d5aac3ec46785207ed31
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548362"
---
# <a name="important-changes-from-direct3d-11-to-direct3d-12"></a><span data-ttu-id="28c36-104">從 Direct3D 11 到 Direct3D 12 的重要變更</span><span class="sxs-lookup"><span data-stu-id="28c36-104">Important Changes from Direct3D 11 to Direct3D 12</span></span>

<span data-ttu-id="28c36-105">Direct3D 12 代表來自 Direct3D 11 程式設計模型的重大起飛。</span><span class="sxs-lookup"><span data-stu-id="28c36-105">Direct3D 12 represents a significant departure from the Direct3D 11 programming model.</span></span> <span data-ttu-id="28c36-106">Direct3D 12 讓應用程式比以往更接近硬體。</span><span class="sxs-lookup"><span data-stu-id="28c36-106">Direct3D 12 lets apps get closer to hardware than ever before.</span></span> <span data-ttu-id="28c36-107">藉由更接近硬體，Direct3D 12 的速度更快且更有效率。</span><span class="sxs-lookup"><span data-stu-id="28c36-107">By being closer to hardware, Direct3D 12 is faster and more efficient.</span></span> <span data-ttu-id="28c36-108">但是，使用 Direct3D 12 提高速度和效率的應用程式取捨，就是您負責比使用 Direct3D 11 更多的工作。</span><span class="sxs-lookup"><span data-stu-id="28c36-108">But, the trade-off of your app having increased speed and efficiency with Direct3D 12 is that you are responsible for more tasks than you were with Direct3D 11.</span></span>

-   [<span data-ttu-id="28c36-109">明確同步處理</span><span class="sxs-lookup"><span data-stu-id="28c36-109">Explicit Synchronization</span></span>](#explicit-synchronization)
-   [<span data-ttu-id="28c36-110">實體記憶體常駐管理</span><span class="sxs-lookup"><span data-stu-id="28c36-110">Physical Memory Residency Management</span></span>](#physical-memory-residency-management)
-   [<span data-ttu-id="28c36-111">管線狀態物件</span><span class="sxs-lookup"><span data-stu-id="28c36-111">Pipeline state objects</span></span>](#pipeline-state-objects)
-   [<span data-ttu-id="28c36-112">命令清單和套件組合</span><span class="sxs-lookup"><span data-stu-id="28c36-112">Command lists and bundles</span></span>](#command-lists-and-bundles)
-   [<span data-ttu-id="28c36-113">描述元堆積和資料表</span><span class="sxs-lookup"><span data-stu-id="28c36-113">Descriptor heaps and tables</span></span>](#descriptor-heaps-and-tables)
-   [<span data-ttu-id="28c36-114">從 Direct3D 11 移植</span><span class="sxs-lookup"><span data-stu-id="28c36-114">Porting from Direct3D 11</span></span>](#porting-from-direct3d-11)
-   [<span data-ttu-id="28c36-115">相關主題</span><span class="sxs-lookup"><span data-stu-id="28c36-115">Related topics</span></span>](#related-topics)

<span data-ttu-id="28c36-116">Direct3D 12 會傳回低層級的程式設計;藉由引進下列新功能，可讓您更充分掌控遊戲和應用程式的圖形元素：代表管線整體狀態的物件、用於工作提交的命令清單和組合，以及用來存取資源的描述項堆積和資料表。</span><span class="sxs-lookup"><span data-stu-id="28c36-116">Direct3D 12 is a return to low-level programming; it gives you more control over the graphical elements of your games and apps by introducing these new features: objects to represent the overall state of the pipeline, command lists and bundles for work submission, and descriptor heaps and tables for resource access.</span></span>

<span data-ttu-id="28c36-117">您的應用程式透過 Direct3D 12 提高速度和效率，但您必須負責比使用 Direct3D 11 更多的工作。</span><span class="sxs-lookup"><span data-stu-id="28c36-117">Your app has increased speed and efficiency with Direct3D 12, but you are responsible for more tasks than you were with Direct3D 11.</span></span>

## <a name="explicit-synchronization"></a><span data-ttu-id="28c36-118">明確同步處理</span><span class="sxs-lookup"><span data-stu-id="28c36-118">Explicit Synchronization</span></span>

-   <span data-ttu-id="28c36-119">在 Direct3D 12 中，CPU-GPU 同步處理現在是應用程式的明確責任，而且執行時間不再隱含地執行，因為它在 Direct3D 11 中。</span><span class="sxs-lookup"><span data-stu-id="28c36-119">In Direct3D 12, CPU-GPU synchronization is now the explicit responsibility of the app and is no longer implicitly performed by the runtime, as it is in Direct3D 11.</span></span> <span data-ttu-id="28c36-120">這項事實也表示，Direct3D 12 不會執行管線風險的自動檢查，因此這是應用程式的責任。</span><span class="sxs-lookup"><span data-stu-id="28c36-120">This fact also means that no automatic checking for pipeline hazards is performed by Direct3D 12, so again this is the apps responsibility.</span></span>
-   <span data-ttu-id="28c36-121">在 Direct3D 12 中，應用程式負責管線資料更新。</span><span class="sxs-lookup"><span data-stu-id="28c36-121">In Direct3D 12, apps are responsible for pipelining data updates.</span></span> <span data-ttu-id="28c36-122">也就是說，Direct3D 11 中的「對應/鎖定-捨棄」模式必須在 Direct3D 12 中以手動方式執行。</span><span class="sxs-lookup"><span data-stu-id="28c36-122">That is, the "Map/Lock-DISCARD" pattern in Direct3D 11 must be performed manually in Direct3D 12.</span></span> <span data-ttu-id="28c36-123">在 Direct3D 11 中，如果您在呼叫 [**>id3d11devicecoNtext：： Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) 與 [**D3D11 \_ Map \_ WRITE \_ 捨棄**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map)時，GPU 仍在使用緩衝區，則執行時間會傳回新的記憶體區域的指標，而不是舊的緩衝區資料。</span><span class="sxs-lookup"><span data-stu-id="28c36-123">In Direct3D 11, if the GPU is still using the buffer when you call [**ID3D11DeviceContext::Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) with [**D3D11\_MAP\_WRITE\_DISCARD**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), the runtime returns a pointer to a new region of memory instead of the old buffer data.</span></span> <span data-ttu-id="28c36-124">這可讓 GPU 在應用程式將資料放在新的緩衝區時，繼續使用舊的資料。</span><span class="sxs-lookup"><span data-stu-id="28c36-124">This allows the GPU to continue using the old data while the app places data in the new buffer.</span></span> <span data-ttu-id="28c36-125">應用程式不需要額外的記憶體管理;當 GPU 完成時，會自動重複使用或終結舊的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="28c36-125">No additional memory management is required in the app; the old buffer is reused or destroyed automatically when the GPU is finished with it.</span></span>
-   <span data-ttu-id="28c36-126">在 Direct3D 12 中，所有動態更新 (包括常數緩衝區、動態頂點緩衝區、動態紋理等) 都是由應用程式明確控制。</span><span class="sxs-lookup"><span data-stu-id="28c36-126">In Direct3D 12, all dynamic updates (including constant buffers, dynamic vertex buffers, dynamic textures, and so on) are explicitly controlled by the app.</span></span> <span data-ttu-id="28c36-127">這些動態更新包含任何必要的 GPU GPU 或緩衝。</span><span class="sxs-lookup"><span data-stu-id="28c36-127">These dynamic updates include any required GPU fences or buffering.</span></span> <span data-ttu-id="28c36-128">應用程式會負責保持可用的記憶體，直到不再需要為止。</span><span class="sxs-lookup"><span data-stu-id="28c36-128">The app is responsible for keeping the memory available until it is no longer needed.</span></span>
-   <span data-ttu-id="28c36-129">Direct3D 12 只針對介面存留期使用 COM 樣式的參考計數， (使用與裝置) 的存留期系結的 Direct3D 的弱式參考模型。</span><span class="sxs-lookup"><span data-stu-id="28c36-129">Direct3D 12 uses COM-style reference counting only for the lifetimes of interfaces (by using the weak reference model of Direct3D tied to the lifetime of the device).</span></span> <span data-ttu-id="28c36-130">所有資源和描述記憶體存留期都是由應用程式負責維持適當期間的唯一責任，而且不會被參考計數。</span><span class="sxs-lookup"><span data-stu-id="28c36-130">All resource and description memory lifetimes are the sole responsibly of the app to maintain for the proper duration, and are not reference counted.</span></span> <span data-ttu-id="28c36-131">Direct3D 11 也會使用參考計數來管理介面相依性的存留期。</span><span class="sxs-lookup"><span data-stu-id="28c36-131">Direct3D 11 uses reference counting to manage the lifetimes of interface dependencies as well.</span></span>

## <a name="physical-memory-residency-management"></a><span data-ttu-id="28c36-132">實體記憶體常駐管理</span><span class="sxs-lookup"><span data-stu-id="28c36-132">Physical Memory Residency Management</span></span>

<span data-ttu-id="28c36-133">Direct3D 12 應用程式必須防止多個佇列、多個介面卡和 CPU 執行緒之間的競爭條件。</span><span class="sxs-lookup"><span data-stu-id="28c36-133">A Direct3D 12 application must prevent race-conditions between multiple queues, multiple adapters, and the CPU threads.</span></span> <span data-ttu-id="28c36-134">D3D12 不會再同步處理 CPU 和 GPU，也不支援資源重新命名或多重緩衝的便利機制。</span><span class="sxs-lookup"><span data-stu-id="28c36-134">D3D12 no longer synchronizes the CPU and GPU, nor supports convenient mechanisms for resource renaming or multi-buffering.</span></span> <span data-ttu-id="28c36-135">在另一個處理單位完成使用之前，必須使用 gpu 來避免多個處理單位從多個記憶體單元寫入記憶體。</span><span class="sxs-lookup"><span data-stu-id="28c36-135">Fences must be used to avoid multiple processing units from over-writing memory before another processing unit finishes using it.</span></span>

<span data-ttu-id="28c36-136">在 GPU 讀取資料時，Direct3D 12 應用程式必須確保資料會常駐在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="28c36-136">The Direct3D 12 application must ensure data is resident in memory while the GPU reads it.</span></span> <span data-ttu-id="28c36-137">每個物件所使用的記憶體，會在建立物件時成為常駐。</span><span class="sxs-lookup"><span data-stu-id="28c36-137">Memory used by each object is made resident during the creation of the object.</span></span> <span data-ttu-id="28c36-138">呼叫這些方法的應用程式必須使用 GPU，以確保 GPU 不會存取已收回的物件。</span><span class="sxs-lookup"><span data-stu-id="28c36-138">Applications which call these methods must use fences to ensure the GPU doesn't access objects which have been evicted.</span></span>

<span data-ttu-id="28c36-139">資源障礙是所需的另一種同步處理類型，可用來同步處理資源和 subresource 轉換（在非常細微的層級）。</span><span class="sxs-lookup"><span data-stu-id="28c36-139">Resource barriers are another type of synchronization needed, used to synchronize resource and subresource transitions at a very granular level.</span></span>

<span data-ttu-id="28c36-140">請參閱 [Direct3D 12 中的記憶體管理](memory-management.md)。</span><span class="sxs-lookup"><span data-stu-id="28c36-140">Refer to [Memory Management in Direct3D 12](memory-management.md).</span></span>

## <a name="pipeline-state-objects"></a><span data-ttu-id="28c36-141">管線狀態物件</span><span class="sxs-lookup"><span data-stu-id="28c36-141">Pipeline state objects</span></span>

<span data-ttu-id="28c36-142">Direct3D 11 可讓您透過一組大型的獨立物件來操作管線狀態。</span><span class="sxs-lookup"><span data-stu-id="28c36-142">Direct3D 11 allows pipeline state manipulation through a large set of independent objects.</span></span> <span data-ttu-id="28c36-143">例如，輸入組合語言狀態、圖元著色器狀態、轉譯器狀態和輸出合併狀態都可以獨立修改。</span><span class="sxs-lookup"><span data-stu-id="28c36-143">For example, input assembler state, pixel shader state, rasterizer state, and output merger state can all be independently modified.</span></span> <span data-ttu-id="28c36-144">這項設計提供圖形管線的方便且相對高階的標記法，但它並不會利用新式硬體的功能，主要是因為各種狀態通常是相互依存的。</span><span class="sxs-lookup"><span data-stu-id="28c36-144">This design provides a convenient and relatively high-level representation of the graphics pipeline, but it doesn’t utilize the capabilities of modern hardware, primarily because the various states are often interdependent.</span></span> <span data-ttu-id="28c36-145">例如，許多 Gpu 將圖元著色器和輸出合併狀態合併成單一硬體標記法。</span><span class="sxs-lookup"><span data-stu-id="28c36-145">For example, many GPUs combine pixel shader and output merger state into a single hardware representation.</span></span> <span data-ttu-id="28c36-146">但由於 Direct3D 11 API 允許個別設定這些管線階段，因此顯示驅動程式無法解決管線狀態的問題，直到狀態完成為止，而不是在繪製時間之前。</span><span class="sxs-lookup"><span data-stu-id="28c36-146">But because the Direct3D 11 API allows these pipeline stages to be set separately, the display driver can't resolve issues of pipeline state until the state is finalized, which isn’t until draw time.</span></span> <span data-ttu-id="28c36-147">此配置會延遲硬體狀態設定，這表示每個框架有額外的額外負荷和最多繪製呼叫數。</span><span class="sxs-lookup"><span data-stu-id="28c36-147">This scheme delays hardware state setup, which means extra overhead and fewer maximum draw calls per frame.</span></span>

<span data-ttu-id="28c36-148">Direct3D 12 藉由將許多管線狀態整合至不可變的管線狀態物件 (Pso) （在建立時完成）來解決此配置。</span><span class="sxs-lookup"><span data-stu-id="28c36-148">Direct3D 12 addresses this scheme by unifying much of the pipeline state into immutable pipeline state objects (PSOs), which are finalized upon creation.</span></span> <span data-ttu-id="28c36-149">然後，硬體和驅動程式就可以立即將 PSO 轉換為執行 GPU 工作所需的任何硬體原生指示和狀態。</span><span class="sxs-lookup"><span data-stu-id="28c36-149">Hardware and drivers can then immediately convert the PSO into whatever hardware native instructions and state are required to execute GPU work.</span></span> <span data-ttu-id="28c36-150">您仍然可以動態地變更正在使用的 PSO，但若要這麼做，硬體只需要將最少量的預先計算狀態直接複製到硬體暫存器，而不是即時計算硬體狀態。</span><span class="sxs-lookup"><span data-stu-id="28c36-150">You can still dynamically change which PSO is in use, but to do so, the hardware only needs to copy the minimal amount of pre-computed state directly to the hardware registers, rather than computing the hardware state on the fly.</span></span> <span data-ttu-id="28c36-151">藉由使用 Pso，繪製呼叫的額外負荷會大幅減少，而且每個框架可能會發生許多繪製呼叫。</span><span class="sxs-lookup"><span data-stu-id="28c36-151">By using PSOs, draw call overhead is reduced significantly, and many more draw calls can occur per frame.</span></span> <span data-ttu-id="28c36-152">如需 Pso 的詳細資訊，請參閱 [管理 Direct3D 12 中的圖形管線狀態](managing-graphics-pipeline-state-in-direct3d-12.md)。</span><span class="sxs-lookup"><span data-stu-id="28c36-152">For more information about PSOs, see [Managing graphics pipeline state in Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span></span>

## <a name="command-lists-and-bundles"></a><span data-ttu-id="28c36-153">命令清單和套件組合</span><span class="sxs-lookup"><span data-stu-id="28c36-153">Command lists and bundles</span></span>

<span data-ttu-id="28c36-154">在 Direct3D 11 中，所有的工作提交都是透過 [立即內容](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render)來完成，這代表一種可移至 GPU 的命令資料流程。</span><span class="sxs-lookup"><span data-stu-id="28c36-154">In Direct3D 11, all work submission is done via the [immediate context](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), which represents a single stream of commands that go to the GPU.</span></span> <span data-ttu-id="28c36-155">為了達成多執行緒調整，遊戲也有 [延遲](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) 的內容可供使用。</span><span class="sxs-lookup"><span data-stu-id="28c36-155">To achieve multithreaded scaling, games also have [deferred contexts](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) available to them.</span></span> <span data-ttu-id="28c36-156">Direct3D 11 中的延遲內容無法完美地對應到硬體，因此可以在這些環境中執行相對較少的工作。</span><span class="sxs-lookup"><span data-stu-id="28c36-156">Deferred contexts in Direct3D 11 don't map perfectly to hardware, so relatively little work can be done in them.</span></span>

<span data-ttu-id="28c36-157">Direct3D 12 根據命令清單導入了新的工作提交模型，其中包含在 GPU 上執行特定工作負載所需的完整資訊。</span><span class="sxs-lookup"><span data-stu-id="28c36-157">Direct3D 12 introduces a new model for work submission based on command lists that contain the entirety of information needed to execute a particular workload on the GPU.</span></span> <span data-ttu-id="28c36-158">每個新的命令清單都包含資訊，例如要使用的 PSO、所需的材質和緩衝區資源，以及所有繪製呼叫的引數。</span><span class="sxs-lookup"><span data-stu-id="28c36-158">Each new command list contains information such as which PSO to use, what texture and buffer resources are needed, and the arguments to all draw calls.</span></span> <span data-ttu-id="28c36-159">因為每個命令清單都是獨立的，而且不會繼承任何狀態，所以驅動程式可以預先預先計算所有必要的 GPU 命令，並以無限制執行緒的方式預先計算。</span><span class="sxs-lookup"><span data-stu-id="28c36-159">Because each command list is self-contained and inherits no state, the driver can pre-compute all necessary GPU commands up-front and in a free-threaded manner.</span></span> <span data-ttu-id="28c36-160">唯一需要的序列程式是透過命令佇列最終將命令清單提交至 GPU 的程式。</span><span class="sxs-lookup"><span data-stu-id="28c36-160">The only serial process necessary is the final submission of command lists to the GPU via the command queue.</span></span>

<span data-ttu-id="28c36-161">除了命令清單之外，Direct3D 12 還引進了第二層的工作預先計算：配套 *。*</span><span class="sxs-lookup"><span data-stu-id="28c36-161">In addition to command lists, Direct3D 12 also introduces a second level of work pre-computation: *bundles*.</span></span> <span data-ttu-id="28c36-162">不同于完全獨立且通常會進行程式化、提交一次和捨棄的命令清單，配套提供允許重複使用的狀態繼承形式。</span><span class="sxs-lookup"><span data-stu-id="28c36-162">Unlike command lists, which are completely self-contained and are typically constructed, submitted once, and discarded, bundles provide a form of state inheritance that permits reuse.</span></span> <span data-ttu-id="28c36-163">例如，如果遊戲想要使用不同的紋理來繪製兩個字元模型，其中一個方法是使用兩組完全相同的繪製呼叫來記錄命令清單。</span><span class="sxs-lookup"><span data-stu-id="28c36-163">For example, if a game wants to draw two character models with different textures, one approach is to record a command list with two sets of identical draw calls.</span></span> <span data-ttu-id="28c36-164">但另一種方法是「錄製」一個組合來繪製單一字元模型，然後使用不同的資源在命令清單上「播放」組合兩次。</span><span class="sxs-lookup"><span data-stu-id="28c36-164">But another approach is to "record" one bundle that draws a single character model, then "play back" the bundle twice on the command list using different resources.</span></span> <span data-ttu-id="28c36-165">在後者的情況下，顯示驅動程式只需要計算適當的指示一次，而建立的命令清單基本上相當於兩個低成本的函式呼叫。</span><span class="sxs-lookup"><span data-stu-id="28c36-165">In the latter case, the display driver only has to compute the appropriate instructions once, and creating the command list essentially amounts to two low-cost function calls.</span></span>

<span data-ttu-id="28c36-166">如需命令清單和組合的詳細資訊，請參閱 [Direct3D 12 中的工作提交](command-queues-and-command-lists.md)。</span><span class="sxs-lookup"><span data-stu-id="28c36-166">For more information about command lists and bundles, see [Work Submission in Direct3D 12](command-queues-and-command-lists.md).</span></span>

## <a name="descriptor-heaps-and-tables"></a><span data-ttu-id="28c36-167">描述元堆積和資料表</span><span class="sxs-lookup"><span data-stu-id="28c36-167">Descriptor heaps and tables</span></span>

<span data-ttu-id="28c36-168">Direct3D 11 中的資源系結是高度抽象化且方便的，但會使許多新式硬體功能的使用量變低。</span><span class="sxs-lookup"><span data-stu-id="28c36-168">Resource binding in Direct3D 11 is highly abstracted and convenient, but leaves many modern hardware capabilities underutilized.</span></span> <span data-ttu-id="28c36-169">在 Direct3D 11 中，遊戲會建立資源的 *view* 物件，然後將這些視圖系結至管線中不同著色器階段 *的數個* 位置。</span><span class="sxs-lookup"><span data-stu-id="28c36-169">In Direct3D 11, games create *view* objects of resources, then bind those views to several *slots* at various shader stages in the pipeline.</span></span> <span data-ttu-id="28c36-170">著色器接著會從這些明確系結位置讀取資料，這些位置是在繪製時固定的。</span><span class="sxs-lookup"><span data-stu-id="28c36-170">Shaders, in turn, read data from those explicit bind slots, which are fixed at draw time.</span></span> <span data-ttu-id="28c36-171">此模型表示每當遊戲使用不同的資源繪製時，它必須將不同的視圖重新系結至不同的位置，然後再次呼叫 draw。</span><span class="sxs-lookup"><span data-stu-id="28c36-171">This model means that whenever a game will draw using different resources, it must re-bind different views to different slots, and call draw again.</span></span> <span data-ttu-id="28c36-172">這種情況也代表可透過充分利用新式硬體功能來消除的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="28c36-172">This case also represents overhead that can be eliminated by fully utilizing modern hardware capabilities.</span></span>

<span data-ttu-id="28c36-173">Direct3D 12 將系結模型變更為符合新式硬體，並大幅提升效能。</span><span class="sxs-lookup"><span data-stu-id="28c36-173">Direct3D 12 changes the binding model to match modern hardware and significantly improves performance.</span></span> <span data-ttu-id="28c36-174">Direct3D 12 不需要獨立的資源查看和明確對應至位置，而是會提供描述項堆積，讓遊戲建立各種資源檢視。</span><span class="sxs-lookup"><span data-stu-id="28c36-174">Instead of requiring standalone resource views and explicit mapping to slots, Direct3D 12 provides a descriptor heap into which games create their various resource views.</span></span> <span data-ttu-id="28c36-175">此配置提供一種機制，可讓 GPU 直接將硬體原生資源描述 (描述元) 預先寫入記憶體。</span><span class="sxs-lookup"><span data-stu-id="28c36-175">This scheme provides a mechanism for the GPU to directly write the hardware-native resource description (descriptor) to memory up-front.</span></span> <span data-ttu-id="28c36-176">為了宣告管線針對特定繪製呼叫所使用的資源，遊戲會指定一或多個描述中繼資料表，代表完整描述元堆積的子範圍。</span><span class="sxs-lookup"><span data-stu-id="28c36-176">To declare which resources are to be used by the pipeline for a particular draw call, games specify one or more descriptor tables that represent sub-ranges of the full descriptor heap.</span></span> <span data-ttu-id="28c36-177">由於描述項堆積已經填入適當的硬體特定描述中繼資料，因此變更描述中繼資料表是極低成本的作業。</span><span class="sxs-lookup"><span data-stu-id="28c36-177">As the descriptor heap has already been populated with the appropriate hardware-specific descriptor data, changing descriptor tables is an extremely low-cost operation.</span></span>

<span data-ttu-id="28c36-178">除了描述項堆積和資料表所提供的效能改進之外，Direct3D 12 還可讓您以著色器動態編制資源的索引，以提供前所未有的彈性並解除新的轉譯技巧。</span><span class="sxs-lookup"><span data-stu-id="28c36-178">In addition to the improved performance offered by descriptor heaps and tables, Direct3D 12 also allows resources to be dynamically indexed in shaders, which provides unprecedented flexibility and unlocks new rendering techniques.</span></span> <span data-ttu-id="28c36-179">例如，新式延遲轉譯引擎通常會將某種類型的材質或物件識別碼編碼為中繼 g 緩衝區。</span><span class="sxs-lookup"><span data-stu-id="28c36-179">As an example, modern deferred rendering engines typically encode a material or object identifier of some kind to the intermediate g-buffer.</span></span> <span data-ttu-id="28c36-180">在 Direct3D 11 中，這些引擎必須小心避免使用過多的資料，因為在一個 g 緩衝區中包含太多資料可能會大幅降低最終轉譯行程的速度。</span><span class="sxs-lookup"><span data-stu-id="28c36-180">In Direct3D 11, these engines must be careful to avoid using too many materials, as including too many in one g-buffer can significantly slow down the final render pass.</span></span> <span data-ttu-id="28c36-181">使用動態可編制索引的資源時，具有上千個材質的場景可以像只有十個數據一樣快速完成。</span><span class="sxs-lookup"><span data-stu-id="28c36-181">With dynamically indexable resources, a scene with a thousand materials can be finalized just as quickly as one with only ten.</span></span>

<span data-ttu-id="28c36-182">如需描述元堆積和資料表的詳細資訊，請參閱 [資源](resource-binding.md)系結，以及 [來自 Direct3D 11 的系結模型差異](binding-model.md)。</span><span class="sxs-lookup"><span data-stu-id="28c36-182">For more information about descriptor heaps and tables, see [Resource Binding](resource-binding.md), and [Differences in the Binding Model from Direct3D 11](binding-model.md).</span></span>

## <a name="porting-from-direct3d-11"></a><span data-ttu-id="28c36-183">從 Direct3D 11 移植</span><span class="sxs-lookup"><span data-stu-id="28c36-183">Porting from Direct3D 11</span></span>

<span data-ttu-id="28c36-184">從 Direct3D 11 移植是在 [從 direct3d 11 移植到 direct3d 12](porting-from-direct3d-11-to-direct3d-12.md)中所述的程式。</span><span class="sxs-lookup"><span data-stu-id="28c36-184">Porting from Direct3D 11 is an involved process, described in [Porting from Direct3D 11 to Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span></span> <span data-ttu-id="28c36-185">另請參閱 [使用 direct3d 11、direct3d 10 和 Direct2D](direct3d-12-interop.md)的選項範圍。</span><span class="sxs-lookup"><span data-stu-id="28c36-185">Also refer to the range of options in [Working with Direct3D 11, Direct3D 10 and Direct2D](direct3d-12-interop.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="28c36-186">相關主題</span><span class="sxs-lookup"><span data-stu-id="28c36-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="28c36-187">瞭解 Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="28c36-187">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
</dt> </dl>

 

 