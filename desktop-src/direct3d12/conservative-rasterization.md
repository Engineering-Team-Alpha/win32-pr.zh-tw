---
title: Direct3D 12 保守的點陣化
description: 保守地柵格化可為圖元轉譯新增一些確定性，這對碰撞偵測演算法特別有用。
ms.assetid: 081199AD-1702-4EC8-95AD-B1148C676199
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4e4fae3489d54ab7b6b7abfda56f54dd8d970962
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/23/2019
ms.locfileid: "104548467"
---
# <a name="direct3d-12-conservative-rasterization"></a><span data-ttu-id="a359f-103">Direct3D 12 保守的點陣化</span><span class="sxs-lookup"><span data-stu-id="a359f-103">Direct3D 12 Conservative Rasterization</span></span>

<span data-ttu-id="a359f-104">保守地柵格化可為圖元轉譯新增一些確定性，這對碰撞偵測演算法特別有用。</span><span class="sxs-lookup"><span data-stu-id="a359f-104">Conservative Rasterization adds some certainty to pixel rendering, which is helpful in particular to collision detection algorithms.</span></span>

-   [<span data-ttu-id="a359f-105">概觀</span><span class="sxs-lookup"><span data-stu-id="a359f-105">Overview</span></span>](#overview)
-   [<span data-ttu-id="a359f-106">與管線的互動</span><span class="sxs-lookup"><span data-stu-id="a359f-106">Interactions with the pipeline</span></span>](#interactions-with-the-pipeline)
    -   [<span data-ttu-id="a359f-107">柵格化規則互動</span><span class="sxs-lookup"><span data-stu-id="a359f-107">Rasterization Rules interaction</span></span>](#rasterization-rules-interaction)
    -   [<span data-ttu-id="a359f-108">多級取樣互動</span><span class="sxs-lookup"><span data-stu-id="a359f-108">Multisampling interaction</span></span>](#multisampling-interaction)
    -   [<span data-ttu-id="a359f-109">SampleMask 互動</span><span class="sxs-lookup"><span data-stu-id="a359f-109">SampleMask interaction</span></span>](#samplemask-interaction)
    -   [<span data-ttu-id="a359f-110">深度/樣板測試互動</span><span class="sxs-lookup"><span data-stu-id="a359f-110">Depth/Stencil Test interaction</span></span>](#depthstencil-test-interaction)
    -   [<span data-ttu-id="a359f-111">Helper 圖元互動</span><span class="sxs-lookup"><span data-stu-id="a359f-111">Helper Pixel interaction</span></span>](#helper-pixel-interaction)
    -   [<span data-ttu-id="a359f-112">輸出涵蓋範圍互動</span><span class="sxs-lookup"><span data-stu-id="a359f-112">Output Coverage interaction</span></span>](#output-coverage-interaction)
    -   [<span data-ttu-id="a359f-113">InputCoverage 互動</span><span class="sxs-lookup"><span data-stu-id="a359f-113">InputCoverage interaction</span></span>](#inputcoverage-interaction)
    -   [<span data-ttu-id="a359f-114">InnerCoverage 互動</span><span class="sxs-lookup"><span data-stu-id="a359f-114">InnerCoverage interaction</span></span>](#innercoverage-interaction)
    -   [<span data-ttu-id="a359f-115">屬性插補互動</span><span class="sxs-lookup"><span data-stu-id="a359f-115">Attribute Interpolation interaction</span></span>](#attribute-interpolation-interaction)
    -   [<span data-ttu-id="a359f-116">剪切互動</span><span class="sxs-lookup"><span data-stu-id="a359f-116">Clipping interaction</span></span>](#clipping-interaction)
    -   [<span data-ttu-id="a359f-117">剪輯距離互動</span><span class="sxs-lookup"><span data-stu-id="a359f-117">Clip Distance interaction</span></span>](#clip-distance-interaction)
    -   [<span data-ttu-id="a359f-118">目標獨立的點陣化互動</span><span class="sxs-lookup"><span data-stu-id="a359f-118">Target Independent Rasterization interaction</span></span>](#target-independent-rasterization-interaction)
    -   [<span data-ttu-id="a359f-119">IA 基本拓撲互動</span><span class="sxs-lookup"><span data-stu-id="a359f-119">IA Primitive Topology interaction</span></span>](#ia-primitive-topology-interaction)
    -   [<span data-ttu-id="a359f-120">查詢互動</span><span class="sxs-lookup"><span data-stu-id="a359f-120">Query interaction</span></span>](#query-interaction)
    -   [<span data-ttu-id="a359f-121">挑選狀態互動</span><span class="sxs-lookup"><span data-stu-id="a359f-121">Cull State interaction</span></span>](#cull-state-interaction)
    -   [<span data-ttu-id="a359f-122">IsFrontFace 互動</span><span class="sxs-lookup"><span data-stu-id="a359f-122">IsFrontFace interaction</span></span>](#isfrontface-interaction)
    -   [<span data-ttu-id="a359f-123">填滿模式互動</span><span class="sxs-lookup"><span data-stu-id="a359f-123">Fill Modes interaction</span></span>](#fill-modes-interaction)
-   [<span data-ttu-id="a359f-124">執行詳細資料</span><span class="sxs-lookup"><span data-stu-id="a359f-124">Implementation details</span></span>](#implementation-details)
-   [<span data-ttu-id="a359f-125">API 摘要</span><span class="sxs-lookup"><span data-stu-id="a359f-125">API summary</span></span>](#api-summary)
-   [<span data-ttu-id="a359f-126">相關主題</span><span class="sxs-lookup"><span data-stu-id="a359f-126">Related topics</span></span>](#related-topics)

## <a name="overview"></a><span data-ttu-id="a359f-127">概觀</span><span class="sxs-lookup"><span data-stu-id="a359f-127">Overview</span></span>

<span data-ttu-id="a359f-128">保守的點陣化表示所有圖元都是由轉譯的基本型別所涵蓋的所有圖元都是柵格化的，這表示會叫用圖元著色器。</span><span class="sxs-lookup"><span data-stu-id="a359f-128">Conservative Rasterization means that all pixels that are at least partially covered by a rendered primitive are rasterized, which means that the pixel shader is invoked.</span></span> <span data-ttu-id="a359f-129">一般行為是取樣，如果已啟用保守的點陣化，則不會使用它。</span><span class="sxs-lookup"><span data-stu-id="a359f-129">Normal behavior is sampling, which is not used if Conservative Rasterization is enabled.</span></span>

<span data-ttu-id="a359f-130">保守式柵格化在許多情況下都很有用，包括對碰撞偵測、遮蔽剔除，以及並排顯示呈現等確定性。</span><span class="sxs-lookup"><span data-stu-id="a359f-130">Conservative Rasterization is useful in a number of situations, including for certainty in collision detection, occlusion culling, and tiled rendering.</span></span>

<span data-ttu-id="a359f-131">例如，下圖顯示使用保守的點陣化來轉譯的綠色三角形，因為它會出現在轉譯器 (也就是使用16.8 固定點頂點座標) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-131">For example, the following figure shows a green triangle rendered using Conservative Rasterization, as it would appear in the rasterizer (that is, using 16.8 fixed point vertex coordinates).</span></span> <span data-ttu-id="a359f-132">棕色區域稱為「不確定性區域」，這是表示三角形延伸界限的概念區域，這是為了確保轉譯器中的基本型別對於原始浮點數頂點的座標很保守。</span><span class="sxs-lookup"><span data-stu-id="a359f-132">The brown area is known as an "uncertainty region" - a conceptual region that represents the extended bounds of the triangle, required to ensure the primitive in the rasterizer is conservative with respect to the original floating point vertex coordinates.</span></span> <span data-ttu-id="a359f-133">每個頂點的紅色方塊會顯示如何計算不確定性區域：做為掃描的正方形。</span><span class="sxs-lookup"><span data-stu-id="a359f-133">The red squares at each vertex shows how the uncertainty region is calculated: as a swept square.</span></span>

<span data-ttu-id="a359f-134">大型灰色方塊會顯示將呈現的圖元。</span><span class="sxs-lookup"><span data-stu-id="a359f-134">The large gray squares show the pixels that will be rendered.</span></span> <span data-ttu-id="a359f-135">粉紅色方塊顯示使用「左上角規則」所呈現的圖元，在三角形的邊緣與圖元邊緣相交時，即會開始播放。</span><span class="sxs-lookup"><span data-stu-id="a359f-135">The pink squares show pixels rendered using the "Top-Left Rule", which comes into play as the edge of the triangle crosses the edge of the pixels.</span></span> <span data-ttu-id="a359f-136">可能會有誤報 (的圖元設定，但系統通常不會將其視為系統通常不會進行挑選的) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-136">There can be false positives (pixels set that should not have been) which the system will normally but not always cull.</span></span>

![左上方的規則](images/conservative-rasterization-0.png)

## <a name="interactions-with-the-pipeline"></a><span data-ttu-id="a359f-138">與管線的互動</span><span class="sxs-lookup"><span data-stu-id="a359f-138">Interactions with the pipeline</span></span>

### <a name="rasterization-rules-interaction"></a><span data-ttu-id="a359f-139">柵格化規則互動</span><span class="sxs-lookup"><span data-stu-id="a359f-139">Rasterization Rules interaction</span></span>

<span data-ttu-id="a359f-140">在保守的點陣化模式中，使用 Top-Left 規則的例外狀況（如上面所述）和圖元涵蓋範圍的例外狀況，也會以相同的方式套用點陣化規則。</span><span class="sxs-lookup"><span data-stu-id="a359f-140">In Conservative Rasterization mode, Rasterization Rules apply the same way as when Conservative Rasterization mode is not enabled with exceptions for the Top-Left Rule, described above, and Pixel Coverage.</span></span> <span data-ttu-id="a359f-141">16.8 Fixed-Point 必須使用轉譯器的精確度。</span><span class="sxs-lookup"><span data-stu-id="a359f-141">16.8 Fixed-Point Rasterizer precision must be used.</span></span>

<span data-ttu-id="a359f-142">如果硬體使用的是完整浮點數頂點，則不會涵蓋的圖元如果在不確定性區域內，則不會包含在固定點定義域中的一半圖元。</span><span class="sxs-lookup"><span data-stu-id="a359f-142">Pixels that would not be covered if hardware was using full floating point vertex coordinates may only be included if they are within an uncertainty region no larger half a pixel in the fixed point domain.</span></span> <span data-ttu-id="a359f-143">未來的硬體預期會達到第2層中所指定的加強不確定性區域。</span><span class="sxs-lookup"><span data-stu-id="a359f-143">Future hardware is expected to reach the tightened uncertainty region specified in Tier 2.</span></span> <span data-ttu-id="a359f-144">請注意，這項需求會防止薄片三角形超過所需的擴充。</span><span class="sxs-lookup"><span data-stu-id="a359f-144">Note that this requirement prevents sliver triangles from extending further than necessary.</span></span>

<span data-ttu-id="a359f-145">同樣地，相同的有效不確定性區域 `InnerCoverage` 也適用，但因為在此情況下不需要較大的不確定性區域，所以會更緊密。</span><span class="sxs-lookup"><span data-stu-id="a359f-145">A similar valid uncertainty region applies to `InnerCoverage` as well, but it is tighter since no implementations require a larger uncertainty region for this case.</span></span> <span data-ttu-id="a359f-146">如需詳細資訊，請參閱 [InnerCoverage 互動](#innercoverage-interaction) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-146">See [InnerCoverage interaction](#innercoverage-interaction) for more detail.</span></span>

<span data-ttu-id="a359f-147">內部和外部不確定性區域必須大於或等於固定點定義域中的半圖元格線1/512 （圖元）一半的大小。</span><span class="sxs-lookup"><span data-stu-id="a359f-147">Inner and outer uncertainty regions must be greater than or equal to the size of half the sub-pixel grid, or 1/512 of a pixel, in the fixed point domain.</span></span> <span data-ttu-id="a359f-148">這是最小的不確定性區域。</span><span class="sxs-lookup"><span data-stu-id="a359f-148">This is the minimum valid uncertainty region.</span></span> <span data-ttu-id="a359f-149">1/512 來自16.8 固定點轉譯器座標標記法，以及將浮點頂點座標轉換成16.8 固定點座標時適用的舍入規則。</span><span class="sxs-lookup"><span data-stu-id="a359f-149">1/512 comes from the 16.8 fixed point Rasterizer coordinate representation and the round-to-nearest rule that applies when converting floating point vertex coordinates to 16.8 fixed point coordinates.</span></span> <span data-ttu-id="a359f-150">如果轉譯器的精確度變更，1/512 可能會變更。</span><span class="sxs-lookup"><span data-stu-id="a359f-150">1/512 can change if the Rasterizer precision changes.</span></span> <span data-ttu-id="a359f-151">如果實值符合不確定性的最社區域，則當不確定性區域的邊緣或角落落在圖元的邊緣或角落時，它們必須遵循 Top-Left 規則。</span><span class="sxs-lookup"><span data-stu-id="a359f-151">If an implementation implements this minimum uncertainty region, then they must follow the Top-Left Rule when an edge or corner of the uncertainty region falls along the edge or corner of a pixel.</span></span> <span data-ttu-id="a359f-152">不確定性區域的裁剪邊緣應視為最接近的頂點，這表示它會計算為兩個邊（在相關聯的頂點上聯結兩個邊）。</span><span class="sxs-lookup"><span data-stu-id="a359f-152">The clipped edges of the uncertainty region should be treated as the closest vertex, meaning that it counts as two edges: the two that join at the associated vertex.</span></span> <span data-ttu-id="a359f-153">使用最小不確定性區域時，需要 Top-Left 規則，因為如果不存在，則保守的點陣化執行將無法在停用「保守的點陣化」模式時，將可涵蓋的圖元進行點陣化。</span><span class="sxs-lookup"><span data-stu-id="a359f-153">Top-Left Rule is required when the minimum uncertainty region is used because if it is not, then a Conservative Rasterization implementation would fail to rasterize pixels that could be covered when Conservative Rasterization mode is disabled.</span></span>

<span data-ttu-id="a359f-154">下圖說明透過在固定點定義域中的基本邊緣周圍清除正方形所產生的有效外部不確定性區域 (也就是16.8 固定點表示) 已量化頂點。</span><span class="sxs-lookup"><span data-stu-id="a359f-154">The following diagram illustrates a valid outer uncertainty region produced by sweeping a square around the edges of the primitive in the fixed point domain (i.e. the vertices have been quantized by the 16.8 fixed point representation).</span></span> <span data-ttu-id="a359f-155">此正方形的維度是以有效的外部不確定性區域大小為依據：在1/2 的圖元中，正方形是寬度和高度的1圖元，而針對1/512 圖元，正方形是圖元的寬度和高度的1/256。</span><span class="sxs-lookup"><span data-stu-id="a359f-155">The dimensions of this square are based on the valid outer uncertainty region size: for the 1/2 of a pixel, the square is 1 pixel in width and height, for 1/512 of a pixel, the square is 1/256 of a pixel in width and height.</span></span> <span data-ttu-id="a359f-156">綠色三角形代表指定的基本類型，紅色虛線表示系結于非常重要的保守點陣化，實心黑色方塊代表沿著基本邊緣掃描的正方形，而藍色的棋盤區域是外部不確定性區域：</span><span class="sxs-lookup"><span data-stu-id="a359f-156">The green triangle represents a given primitive, the red dotted line represents the bound on Overestimated Conservative Rasterization, the solid black squares represent the square that is swept along the primitive edges, and the blue checkered area is the outer uncertainty region:</span></span>

![外部不確定性區域。](images/outercoverage.jpg)

### <a name="multisampling-interaction"></a><span data-ttu-id="a359f-158">多級取樣互動</span><span class="sxs-lookup"><span data-stu-id="a359f-158">Multisampling interaction</span></span>

<span data-ttu-id="a359f-159">無論 **RenderTarget** DepthStencil 介面中的樣本數目 /  (，或 *ForcedSampleCount* 是否正在使用中或未) ，所有範例都是由保守地柵格化的圖元所涵蓋。</span><span class="sxs-lookup"><span data-stu-id="a359f-159">Regardless of the number of samples in **RenderTarget**/**DepthStencil** surfaces (or whether *ForcedSampleCount* is being used or not), all samples are covered for pixels rasterized by Conservative Rasterization.</span></span> <span data-ttu-id="a359f-160">個別範例位置不會測試它們是否落在基本型別中。</span><span class="sxs-lookup"><span data-stu-id="a359f-160">Individual sample locations are not tested for whether they fall in the primitive or not.</span></span>

### <a name="samplemask-interaction"></a><span data-ttu-id="a359f-161">SampleMask 互動</span><span class="sxs-lookup"><span data-stu-id="a359f-161">SampleMask interaction</span></span>

<span data-ttu-id="a359f-162">*SampleMask* 轉譯器狀態的套用方式與不啟用保守的點陣化時相同 `InputCoverage` ，但不會影響 `InnerCoverage` (也就是不會 AND'ed 至以) 宣告的輸入 `InnerCoverage` 。</span><span class="sxs-lookup"><span data-stu-id="a359f-162">The *SampleMask* Rasterizer State applies the same way as when Conservative Rasterization is not enabled for `InputCoverage`, but does not affect `InnerCoverage` (i.e. it is not AND’ed into an input declared with `InnerCoverage`).</span></span> <span data-ttu-id="a359f-163">這是因為 `InnerCoverage` 與 MSAA 樣本是否已遮罩不相關： 0 `InnerCoverage` 只表示不保證會完全涵蓋圖元，而不會更新任何範例。</span><span class="sxs-lookup"><span data-stu-id="a359f-163">This is because `InnerCoverage` is unrelated to whether MSAA samples are masked out: 0 `InnerCoverage` only means that the pixel is not guaranteed to be fully covered, not that no samples will be updated.</span></span>

### <a name="depthstencil-test-interaction"></a><span data-ttu-id="a359f-164">深度/樣板測試互動</span><span class="sxs-lookup"><span data-stu-id="a359f-164">Depth/Stencil Test interaction</span></span>

<span data-ttu-id="a359f-165">深度/樣板測試會繼續進行保守的點陣化圖元，就像在未啟用保守式點陣化時所涵蓋的所有樣本一樣。</span><span class="sxs-lookup"><span data-stu-id="a359f-165">Depth/Stencil Testing proceeds for a conservatively rasterized pixel the same way as if all samples are covered when Conservative Rasterization is not enabled.</span></span>

<span data-ttu-id="a359f-166">繼續進行涵蓋的所有樣本可能會導致深度推斷，這是有效的，而且必須壓制至在未啟用保守的點陣化時所指定的視口。</span><span class="sxs-lookup"><span data-stu-id="a359f-166">Proceeding with all samples covered can cause Depth Extrapolation, which is valid and must be clamped to the viewport as specified when Conservative Rasterization is not enabled.</span></span> <span data-ttu-id="a359f-167">這與取樣計數大於1的 **RenderTarget** 上使用圖元頻率插補模式時類似，不過在保守的點陣化情況下，它是進入固定函式深度測試的深度值，可以推斷。</span><span class="sxs-lookup"><span data-stu-id="a359f-167">This is similar to when pixel-frequency interpolation modes are used on a **RenderTarget** with sample count greater than 1, although in the case of Conservative Rasterization, it is the depth value going into the fixed function depth test that can be extrapolated.</span></span>

<span data-ttu-id="a359f-168">深度外推的提早剔除行為未定義。</span><span class="sxs-lookup"><span data-stu-id="a359f-168">Early Depth culling behavior with Depth Extrapolation is undefined.</span></span> <span data-ttu-id="a359f-169">這是因為某些早期的挑選硬體無法正確支援推斷的深度值。</span><span class="sxs-lookup"><span data-stu-id="a359f-169">This is because some Early Depth culling hardware cannot properly support extrapolated depth values.</span></span> <span data-ttu-id="a359f-170">不過，在深度外推的情況下，早期的推斷行為會造成問題，即使硬體可以支援推斷的深度值也是一樣。</span><span class="sxs-lookup"><span data-stu-id="a359f-170">However, Early Depth culling behavior in the presence of Depth Extrapolation is problematic even with hardware that can support extrapolated depth values.</span></span> <span data-ttu-id="a359f-171">此問題的解決方式是將圖元著色器輸入深度固定至要進行柵格化之基本物件的最小和最大深度值，並將該值寫入 `oDepth` (圖元著色器輸出深度暫存器) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-171">This issue can be worked around by clamping the Pixel Shader input depth to the min and max depth values of the primitive being rasterized and writing that value to `oDepth` (the pixel shader output depth register).</span></span> <span data-ttu-id="a359f-172">在此情況下，由於寫入的緣故，必須要有執行來停用深度挑選 `oDepth` 。</span><span class="sxs-lookup"><span data-stu-id="a359f-172">Implementations are required to disable Early Depth culling in this case, due to the `oDepth` write.</span></span>

### <a name="helper-pixel-interaction"></a><span data-ttu-id="a359f-173">Helper 圖元互動</span><span class="sxs-lookup"><span data-stu-id="a359f-173">Helper Pixel interaction</span></span>

<span data-ttu-id="a359f-174">Helper 圖元規則的套用方式與未啟用保守的點陣化時相同。</span><span class="sxs-lookup"><span data-stu-id="a359f-174">Helper Pixel rules apply the same way as when Conservative Rasterization is not enabled.</span></span> <span data-ttu-id="a359f-175">在此情況下，包括協助程式圖元在內的所有圖元都必須 `InputCoverage` 正確地報告（如互動區段中所指定） `InputCoverage` 。</span><span class="sxs-lookup"><span data-stu-id="a359f-175">As part of this, all pixels including Helper Pixels must report `InputCoverage` accurately as specified in the `InputCoverage` interaction section.</span></span> <span data-ttu-id="a359f-176">因此，完全不涵蓋的圖元報告0涵蓋範圍。</span><span class="sxs-lookup"><span data-stu-id="a359f-176">So fully non-covered pixels report 0 coverage.</span></span>

### <a name="output-coverage-interaction"></a><span data-ttu-id="a359f-177">輸出涵蓋範圍互動</span><span class="sxs-lookup"><span data-stu-id="a359f-177">Output Coverage interaction</span></span>

<span data-ttu-id="a359f-178">輸出涵蓋範圍 (`oMask`) 的行為會與保守的點陣化圖元相同，因為未啟用任何涵蓋的範例。</span><span class="sxs-lookup"><span data-stu-id="a359f-178">Output Coverage (`oMask`) behaves for a conservatively rasterized pixel as it does when Conservative Rasterization is not enabled with all samples covered.</span></span>

### <a name="inputcoverage-interaction"></a><span data-ttu-id="a359f-179">InputCoverage 互動</span><span class="sxs-lookup"><span data-stu-id="a359f-179">InputCoverage interaction</span></span>

<span data-ttu-id="a359f-180">在保守的點陣化模式中，會將此輸入暫存器填入，因為未針對指定的保守柵格化圖元啟用保守的點陣化。</span><span class="sxs-lookup"><span data-stu-id="a359f-180">In Conservative Rasterization mode, this input register is populated as if all samples are covered when Conservative Rasterization is not enabled for a given conservatively rasterized pixel.</span></span> <span data-ttu-id="a359f-181">也就是說，所有現有的互動都會套用 (例如， *SampleMask* 會套用) ，而 LSB 的第一個 n 位 `InputCoverage` 則會設定為1，適用于保守地柵格化圖元，指定每圖元 **RenderTarget** 的 n 個樣本和/或在 **輸出合併** 時系結的 **DepthStencil** 緩衝區，或 n 個範例 *ForcedSampleCount*。</span><span class="sxs-lookup"><span data-stu-id="a359f-181">That is to say, all existing interactions apply (e.g. *SampleMask* is applied), and the first n bits in `InputCoverage` from the LSB are set to 1 for a conservatively rasterized pixel, given an n sample per pixel **RenderTarget** and/or **DepthStencil** buffer bound at the **Output Merger**, or an n sample *ForcedSampleCount*.</span></span> <span data-ttu-id="a359f-182">其餘的位則為0。</span><span class="sxs-lookup"><span data-stu-id="a359f-182">The rest of the bits are 0.</span></span>

<span data-ttu-id="a359f-183">雖然保守的點陣化會將其行為變更為只顯示 (所涵蓋的所有樣本，或沒有協助程式圖元) ，但在著色器中有提供此輸入。</span><span class="sxs-lookup"><span data-stu-id="a359f-183">This input is available in a shader regardless of the use of Conservative Rasterization, though Conservative Rasterization changes its behavior to only show all samples covered (or none for Helper Pixels).</span></span>

### <a name="innercoverage-interaction"></a><span data-ttu-id="a359f-184">InnerCoverage 互動</span><span class="sxs-lookup"><span data-stu-id="a359f-184">InnerCoverage interaction</span></span>

<span data-ttu-id="a359f-185">這項功能是必要的，而且僅適用于第3層。</span><span class="sxs-lookup"><span data-stu-id="a359f-185">This feature is required by, and only available in, Tier 3.</span></span> <span data-ttu-id="a359f-186">當執行支援的層級小於第3層時，執行時間將會在著色器建立時失敗，而這會使用此模式。</span><span class="sxs-lookup"><span data-stu-id="a359f-186">The runtime will fail shader creation for shaders that use this mode when an implementation supports a Tier less than Tier 3.</span></span>

<span data-ttu-id="a359f-187">圖元著色器的可用32位純量整數系統產生值： `InnerCoverage` 。</span><span class="sxs-lookup"><span data-stu-id="a359f-187">The Pixel Shader has a 32-bit scalar integer System Generate Value available: `InnerCoverage`.</span></span> <span data-ttu-id="a359f-188">這是位欄位，只有在該圖元保證完全在目前的基本型別內時，才會將 LSB 中的位0從設定為1。</span><span class="sxs-lookup"><span data-stu-id="a359f-188">This is a bit-field that has bit 0 from the LSB set to 1 for a given conservatively rasterized pixel, only when that pixel is guaranteed to be entirely inside the current primitive.</span></span> <span data-ttu-id="a359f-189">如果未設定位0，則所有其他輸入暫存器位都必須設定為0，但當位0設定為1時未定義 (基本上，此位欄位代表布林值，其中 false 必須正好為0，但 true 可以是任何奇數 (，也就是位0設定) 非零值) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-189">All other input register bits must be set to 0 when bit 0 is not set, but are undefined when bit 0 is set to 1 (essentially, this bit-field represents a Boolean value where false must be exactly 0, but true can be any odd (i.e. bit 0 set) non-zero value).</span></span> <span data-ttu-id="a359f-190">此輸入可用於低估的保守點陣化資訊。</span><span class="sxs-lookup"><span data-stu-id="a359f-190">This input is used for underestimated Conservative Rasterization information.</span></span> <span data-ttu-id="a359f-191">它會通知圖元著色器，指出目前的圖元是否完全位於幾何內。</span><span class="sxs-lookup"><span data-stu-id="a359f-191">It informs the Pixel Shader whether the current pixel lies completely inside the geometry.</span></span>

<span data-ttu-id="a359f-192">這必須在解析度大於或等於目前繪圖運作的解析度時，考慮貼齊錯誤。</span><span class="sxs-lookup"><span data-stu-id="a359f-192">This must account for snapping error at resolutions greater than or equal to the resolution at which the current Draw is operating.</span></span> <span data-ttu-id="a359f-193">`InnerCoverage`當解析度大於或等於目前繪圖作業) 的解析度時，不一定會有錯誤的肯定 (設定位，但允許使用 false 的否定。</span><span class="sxs-lookup"><span data-stu-id="a359f-193">There must not be false positives (setting `InnerCoverage` bits when the pixel is not fully covered for any snapping error at resolutions greater than or equal to the resolution at which the current Draw is operating), but false negatives are allowed.</span></span> <span data-ttu-id="a359f-194">總而言之，在轉譯器中不會有完整的浮點數頂點座標，因此執行不能正確地將圖元識別為完全涵蓋的圖元。</span><span class="sxs-lookup"><span data-stu-id="a359f-194">In summary, the implementation must not incorrectly identify pixels as fully covered that would not be with full floating point vertex coordinates in the Rasterizer.</span></span>

<span data-ttu-id="a359f-195">如果硬體使用完整浮點數頂點，則會完全涵蓋的圖元如果其交集于內部不確定性區域（必須大於子圖元方格的大小，或在固定點定義域中圖元的1/256），則會完全涵蓋。</span><span class="sxs-lookup"><span data-stu-id="a359f-195">Pixels that would be fully covered if hardware was using full floating point vertex coordinates may only be omitted if they intersect the inner uncertainty region, which must be no larger than the size of the sub-pixel grid, or 1/256 of a pixel, in the fixed point domain.</span></span> <span data-ttu-id="a359f-196">另一種方式是，完全在內部不確定性區域內部界限內的圖元必須標示為完整涵蓋範圍。</span><span class="sxs-lookup"><span data-stu-id="a359f-196">Said another way, pixels entirely within the inner boundary of the inner uncertainty region must be marked as fully covered.</span></span> <span data-ttu-id="a359f-197">下圖以粗體的黑色虛線說明不確定性區域的內部界限。</span><span class="sxs-lookup"><span data-stu-id="a359f-197">The inner boundary of the uncertainty region is illustrated in the diagram below by the bold black dotted line.</span></span> <span data-ttu-id="a359f-198">1/256 來自16.8 固定點轉譯器座標標記法，如果轉譯器的精確度有所變更，則可能會變更。</span><span class="sxs-lookup"><span data-stu-id="a359f-198">1/256 comes from the 16.8 fixed point Rasterizer coordinate representation, which can change if the Rasterizer precision changes.</span></span> <span data-ttu-id="a359f-199">這種不確定性區域足以因應將浮點頂點座標轉換成轉譯器中固定點頂點座標所造成的貼齊錯誤。</span><span class="sxs-lookup"><span data-stu-id="a359f-199">This uncertainty region is enough to account for snapping error caused by the conversion of floating point vertex coordinates to fixed point vertex coordinates in the Rasterizer.</span></span>

<span data-ttu-id="a359f-200">在這裡也適用于柵格化規則互動中所定義的相同1/512 最小不確定性區域需求。</span><span class="sxs-lookup"><span data-stu-id="a359f-200">The same 1/512 minimum uncertainty region requirements defined in Rasterization Rules interaction apply here as well.</span></span>

<span data-ttu-id="a359f-201">下圖說明在固定點定義域中的基本邊緣周圍清除正方形所產生的有效內部不確定性區域 (也就是16.8 固定點表示) 已量化頂點。</span><span class="sxs-lookup"><span data-stu-id="a359f-201">The following diagram illustrates a valid inner uncertainty region produced by sweeping a square around the edges of the primitive in the fixed point domain (i.e. the vertices have been quantized by the 16.8 fixed point representation).</span></span> <span data-ttu-id="a359f-202">此正方形的維度是以有效的內部不確定性區域大小為基礎：針對1/256 的圖元，正方形是圖元的1/128，寬度和高度。</span><span class="sxs-lookup"><span data-stu-id="a359f-202">The dimensions of this square are based on the valid inner uncertainty region size: for 1/256 of a pixel, the square is 1/128 of a pixel in width and height.</span></span> <span data-ttu-id="a359f-203">綠色三角形代表指定的基本型別，粗體的黑色虛線表示內部不確定性區域的界限，實心的黑色方形代表沿著基本邊緣掃描的正方形，橙色的棋盤區則是內部不確定性區域：</span><span class="sxs-lookup"><span data-stu-id="a359f-203">The green triangle represents a given primitive, the bold black dotted line represents the boundary of the inner uncertainty region, the solid black squares represent the square that is swept along the primitive edges, and the orange checkered area is the inner uncertainty region:</span></span>

![內部不確定性 reqion。](images/innercoverage.jpg)

<span data-ttu-id="a359f-205">使用 `InnerCoverage` 並不會影響圖元是否謹慎進行柵格化，也就是使用這些模式的其中一種，並不會 `InputCoverage` 影響在啟用保守的點陣化模式時，要將哪些圖元進行柵格化。</span><span class="sxs-lookup"><span data-stu-id="a359f-205">The use of `InnerCoverage` does not affect whether a pixel is conservatively rasterized, i.e. using one of these `InputCoverage` modes does not affect which pixels are rasterized when Conservative Rasterization mode is enabled.</span></span> <span data-ttu-id="a359f-206">因此，使用時，如果圖元 `InnerCoverage` 著色器正在處理的圖元未完全涵蓋于幾何中，則其值將會是0，但是圖元著色器調用將會更新範例。</span><span class="sxs-lookup"><span data-stu-id="a359f-206">Therefore, when `InnerCoverage` is used and the Pixel Shader is processing a pixel that is not completely covered by the geometry its value will be 0, but the Pixel Shader invocation will have samples updated.</span></span> <span data-ttu-id="a359f-207">這不同于當 `InputCoverage` 是0時，表示不會更新任何範例。</span><span class="sxs-lookup"><span data-stu-id="a359f-207">This is different from when `InputCoverage` is 0, meaning that no samples will be updated.</span></span>

<span data-ttu-id="a359f-208">此輸入與 `InputCoverage` 相同：無法使用兩者。</span><span class="sxs-lookup"><span data-stu-id="a359f-208">This input is mutually exclusive with `InputCoverage` : both cannot be used.</span></span>

<span data-ttu-id="a359f-209">若要存取 `InnerCoverage` ，必須將它宣告為一個圖元著色器輸入暫存器中的單一元件。</span><span class="sxs-lookup"><span data-stu-id="a359f-209">To access `InnerCoverage`, it must be declared as a single component out of one of the Pixel Shader input registers.</span></span> <span data-ttu-id="a359f-210">宣告上的插補模式必須是常數 (插補不會套用) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-210">The interpolation mode on the declaration must be constant (interpolation does not apply).</span></span>

<span data-ttu-id="a359f-211">`InnerCoverage`位欄位不會受到深度/樣板測試的影響，也不會以 *SampleMask* 轉譯器的狀態以 and 連結。</span><span class="sxs-lookup"><span data-stu-id="a359f-211">The `InnerCoverage` bit-field is not affected by depth/stencil tests, nor is it ANDed with the *SampleMask* Rasterizer state.</span></span>

<span data-ttu-id="a359f-212">此輸入只適用于保守的點陣化模式。</span><span class="sxs-lookup"><span data-stu-id="a359f-212">This input is only valid in Conservative Rasterization mode.</span></span> <span data-ttu-id="a359f-213">未啟用保守的點陣化時，會 `InnerCoverage` 產生未定義的值。</span><span class="sxs-lookup"><span data-stu-id="a359f-213">When Conservative Rasterization is not enabled, `InnerCoverage` produces an undefined value.</span></span>

<span data-ttu-id="a359f-214">圖元著色器調用所造成的需要協助程式圖元，但不包含在基本型別中，必須將暫存器 `InnerCoverage` 設定為0。</span><span class="sxs-lookup"><span data-stu-id="a359f-214">Pixel Shader invocations caused by the need for Helper Pixels, but otherwise not covered by the primitive, must have the `InnerCoverage` register set to 0.</span></span>

### <a name="attribute-interpolation-interaction"></a><span data-ttu-id="a359f-215">屬性插補互動</span><span class="sxs-lookup"><span data-stu-id="a359f-215">Attribute Interpolation interaction</span></span>

<span data-ttu-id="a359f-216">屬性內插補點模式不會變更，且繼續進行的方式與未啟用保守的點陣化時相同，其中會使用以視口調整和固定點轉換的頂點。</span><span class="sxs-lookup"><span data-stu-id="a359f-216">Attribute interpolation modes are unchanged and proceed the same way as when Conservative Rasterization is not enabled, where the viewport-scaled and fixed-point-converted vertices are used.</span></span> <span data-ttu-id="a359f-217">由於未受保守地柵格化圖元中的所有範例都被視為涵蓋範圍，因此它適用于要推斷的值，類似于在樣本計數大於1的 **RenderTarget** 上使用圖元頻率的插補模式。</span><span class="sxs-lookup"><span data-stu-id="a359f-217">Because all samples in a conservatively rasterized pixel are considered covered, it is valid for values to be extrapolated, similar to when pixel-frequency interpolation modes are used on a **RenderTarget** with sample count greater than 1.</span></span> <span data-ttu-id="a359f-218">距心插補模式產生的結果與對應的非距心插補模式相同;在此案例中，距心的概念沒有意義，其中範例涵蓋範圍只會是 full 或0。</span><span class="sxs-lookup"><span data-stu-id="a359f-218">Centroid interpolation modes produce results identical to the corresponding non-centroid interpolation mode; the notion of centroid is meaningless in this scenario – where sample coverage is only either full or 0.</span></span>

<span data-ttu-id="a359f-219">保守式的點陣化可讓退化三角形產生圖元著色器調用，因此，退化三角形必須針對所有插入值使用指派給頂點0的值。</span><span class="sxs-lookup"><span data-stu-id="a359f-219">Conservative Rasterization allows for degenerate triangles to produce Pixel Shader invocations, therefore, degenerate triangles must use the values assigned to Vertex 0 for all interpolated values.</span></span>

### <a name="clipping-interaction"></a><span data-ttu-id="a359f-220">剪切互動</span><span class="sxs-lookup"><span data-stu-id="a359f-220">Clipping interaction</span></span>

<span data-ttu-id="a359f-221">當您啟用保守的點陣化模式並停用深度剪輯時 (當 *DepthClipEnable* 轉譯器的狀態設為 FALSE) ，根據實值，在 0 <= z <= w 範圍之外的基本型別區段中，可能會有不同的屬性插補：其中一個常數值會用來從基本型別與相關平面 (接近或遠) ，或屬性內插補點的行為就像是停用保守的點陣化模式一樣。</span><span class="sxs-lookup"><span data-stu-id="a359f-221">When Conservative Rasterization mode is enabled and depth clip is disabled (when the *DepthClipEnable* Rasterizer State is set to FALSE), there may be variances in attribute interpolation for segments of a primitive that fall outside the 0 <= z <= w range, depending on implementation: either constant values are used from a point where the primitive intersects the relevant plane (near or far), or attribute interpolation behaves as when Conservative Rasterization mode is disabled.</span></span> <span data-ttu-id="a359f-222">但是，不論保守的點陣化模式為何，深度值行為都相同，也就是在深度範圍之外的基本專案，仍然必須獲得最接近的區深度範圍限制值。</span><span class="sxs-lookup"><span data-stu-id="a359f-222">However, the depth value behavior is the same regardless of Conservative Rasterization mode, i.e. primitives that fall outside of the depth range must still be given the value of the nearest limit of the viewport depth range.</span></span> <span data-ttu-id="a359f-223">0 <= z <= w 範圍內的屬性插補行為必須維持不變。</span><span class="sxs-lookup"><span data-stu-id="a359f-223">Attribute interpolation behavior inside the 0 <= z <= w range must remain unchanged.</span></span>

### <a name="clip-distance-interaction"></a><span data-ttu-id="a359f-224">剪輯距離互動</span><span class="sxs-lookup"><span data-stu-id="a359f-224">Clip Distance interaction</span></span>

<span data-ttu-id="a359f-225">當您啟用保守的點陣化模式時，裁剪距離是有效的，而且會以保守的點陣化圖元為依據，因為未啟用所有涵蓋的範例。</span><span class="sxs-lookup"><span data-stu-id="a359f-225">Clip Distance is valid when Conservative Rasterization mode is enabled, and behaves for a conservatively rasterized pixel as it does when Conservative Rasterization is not enabled with all samples covered.</span></span>

<span data-ttu-id="a359f-226">請注意，保守的點陣化可能會造成 w 頂點座標的推斷，這可能會導致 W <= 0。</span><span class="sxs-lookup"><span data-stu-id="a359f-226">Note that Conservative Rasterization can cause extrapolation of the W vertex coordinate, which may cause W <= 0.</span></span> <span data-ttu-id="a359f-227">這可能會導致每個圖元的剪輯距離實值在以角度除以無效 W 值的剪切距離上運作。</span><span class="sxs-lookup"><span data-stu-id="a359f-227">This could cause per-pixel Clip Distance implementations to operate on a Clip Distance that has been Perspective Divided by an invalid W value.</span></span> <span data-ttu-id="a359f-228">剪輯距離的執行必須防止針對圖元叫用點陣，其中頂點座標 W <= 0 (例如，因為在保守的點陣化模式中) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-228">Clip Distance implementations must guard against invoking rasterization for pixels where vertex coordinate W <= 0 (e.g. due to extrapolation when in Conservative Rasterization mode).</span></span>

### <a name="target-independent-rasterization-interaction"></a><span data-ttu-id="a359f-229">目標獨立的點陣化互動</span><span class="sxs-lookup"><span data-stu-id="a359f-229">Target Independent Rasterization interaction</span></span>

<span data-ttu-id="a359f-230">保守的點陣化模式與目標獨立的點陣化 (TIR) 相容。</span><span class="sxs-lookup"><span data-stu-id="a359f-230">Conservative Rasterization mode is compatible with Target Independent Rasterization (TIR).</span></span> <span data-ttu-id="a359f-231">TIR 規則和限制適用于謹慎地柵格化圖元，如同所有範例都涵蓋在內。</span><span class="sxs-lookup"><span data-stu-id="a359f-231">TIR rules and restrictions apply, behaving for a conservatively rasterized pixel as if all samples are covered.</span></span>

### <a name="ia-primitive-topology-interaction"></a><span data-ttu-id="a359f-232">IA 基本拓撲互動</span><span class="sxs-lookup"><span data-stu-id="a359f-232">IA Primitive Topology interaction</span></span>

<span data-ttu-id="a359f-233">未針對線條或點基本類型定義保守的點陣化。</span><span class="sxs-lookup"><span data-stu-id="a359f-233">Conservative Rasterization is not defined for line or point primitives.</span></span> <span data-ttu-id="a359f-234">因此，如果已啟用保守的點陣化，指定點或線條的基本拓撲會產生未定義的行為。</span><span class="sxs-lookup"><span data-stu-id="a359f-234">Therefore, Primitive Topologies that specify points or lines produce undefined behavior if they are fed to the rasterizer unit when Conservative Rasterization is enabled.</span></span>

<span data-ttu-id="a359f-235">Debug layer 驗證會確認應用程式不會使用這些基本拓撲。</span><span class="sxs-lookup"><span data-stu-id="a359f-235">The debug layer validation verifies applications do not use these Primitive Topologies.</span></span>

### <a name="query-interaction"></a><span data-ttu-id="a359f-236">查詢互動</span><span class="sxs-lookup"><span data-stu-id="a359f-236">Query interaction</span></span>

<span data-ttu-id="a359f-237">針對保守的柵格化圖元，查詢的行為會如同在涵蓋所有樣本時未啟用保守的點陣化時一樣。</span><span class="sxs-lookup"><span data-stu-id="a359f-237">For a conservatively rasterized pixel, queries behave as they do when Conservative Rasterization is not enabled when all samples are covered.</span></span> <span data-ttu-id="a359f-238">例如，針對非保守地柵格化圖元， \_ \_ \_ 從 D3D12 查詢類型 D3D12 的查詢類型遮蔽和 D3D12 \_ 查詢 \_ 類型 \_ 管線 \_ 統計資料 (，) 必須與所有樣本都未啟用保守的光柵 [**\_ \_**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type) 化一樣。</span><span class="sxs-lookup"><span data-stu-id="a359f-238">For example, for a conservatively rasterized pixel, D3D12\_QUERY\_TYPE\_OCCLUSION and D3D12\_QUERY\_TYPE\_PIPELINE\_STATISTICS (from [**D3D12\_QUERY\_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type)) must behave as they would when Conservative Rasterization is not enabled when all samples are covered.</span></span>

<span data-ttu-id="a359f-239">在保守的點陣化模式中，圖元著色器的調用應該以每個保守的圖元素遞增。</span><span class="sxs-lookup"><span data-stu-id="a359f-239">Pixel Shader invocations should increment for every conservatively rasterized pixel in Conservative Rasterization mode.</span></span>

### <a name="cull-state-interaction"></a><span data-ttu-id="a359f-240">挑選狀態互動</span><span class="sxs-lookup"><span data-stu-id="a359f-240">Cull State interaction</span></span>

<span data-ttu-id="a359f-241">所有挑選的狀態都是在保守的點陣化模式下有效，且遵循的規則與未啟用保守的點陣化時相同。</span><span class="sxs-lookup"><span data-stu-id="a359f-241">All Cull States are valid in Conservative Rasterization mode and follow the same rules as when Conservative Rasterization is not enabled.</span></span>

<span data-ttu-id="a359f-242">當您比較保守的點陣化之間的解析度，或是未啟用保守的點陣化時，有可能是某些基本專案可能會有不相符的 facedness (亦即，另一次面向的) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-242">When comparing Conservative Rasterization across resolutions to itself or without Conservative Rasterization enabled, there is the possibility that some primitives may have mismatched facedness (i.e. one back facing, the other front facing).</span></span> <span data-ttu-id="a359f-243">應用程式可以使用 D3D12 \_ \_ 的 [ \_ 從 D3D12 的) [**\_ 挑選 \_**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_cull_mode) 模式無 (]，而不是使用 `IsFrontFace` 系統產生的值，藉以避免這種不確定性。</span><span class="sxs-lookup"><span data-stu-id="a359f-243">Applications can avoid this uncertainty by using D3D12\_CULL\_MODE\_NONE (from [**D3D12\_CULL\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_cull_mode)) and not using the `IsFrontFace` System Generated Value.</span></span>

### <a name="isfrontface-interaction"></a><span data-ttu-id="a359f-244">IsFrontFace 互動</span><span class="sxs-lookup"><span data-stu-id="a359f-244">IsFrontFace interaction</span></span>

<span data-ttu-id="a359f-245">`IsFrontFace`系統產生的值有效，可用於保守的點陣化模式，並遵循未啟用保守的點陣化時所定義的行為。</span><span class="sxs-lookup"><span data-stu-id="a359f-245">The `IsFrontFace` System Generated Value is valid to use in Conservative Rasterization mode, and follows the behavior defined when Conservative Rasterization is not enabled.</span></span>

### <a name="fill-modes-interaction"></a><span data-ttu-id="a359f-246">填滿模式互動</span><span class="sxs-lookup"><span data-stu-id="a359f-246">Fill Modes interaction</span></span>

<span data-ttu-id="a359f-247">保守柵格化的唯一有效 [**D3D12 \_ 填滿 \_ 模式**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_fill_mode) 是 D3D12 \_ 填滿 \_ 純色，其他任何填滿模式則是針對轉譯器狀態不正確參數。</span><span class="sxs-lookup"><span data-stu-id="a359f-247">The only valid [**D3D12\_FILL\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_fill_mode) for Conservative Rasterization is D3D12\_FILL\_SOLID, any other fill mode is an invalid parameter for the Rasterizer State.</span></span>

<span data-ttu-id="a359f-248">這是因為 D3D12 功能規格會指定框線填滿模式應該將三角形邊緣轉換成線條，並遵循行的點陣化規則，而且保守線的點陣化行為尚未定義。</span><span class="sxs-lookup"><span data-stu-id="a359f-248">This is because D3D12 functional specification specifies that wireframe fill mode should convert triangle edges to lines and follow the line rasterization rules and conservative line rasterization behavior has not been defined.</span></span>

## <a name="implementation-details"></a><span data-ttu-id="a359f-249">實作詳細資料</span><span class="sxs-lookup"><span data-stu-id="a359f-249">Implementation details</span></span>

<span data-ttu-id="a359f-250">Direct3D 12 中支援的光柵類型有時稱為「非常重要保守的點陣化」。</span><span class="sxs-lookup"><span data-stu-id="a359f-250">The type of rasterization supported in Direct3D 12 is sometimes referred to as "Overestimated Conservative Rasterization".</span></span> <span data-ttu-id="a359f-251">此外，也有「低估的保守點陣化」概念，這表示只有經過轉譯的原始物件完全涵蓋的圖元才會進行柵格化。</span><span class="sxs-lookup"><span data-stu-id="a359f-251">There is also the concept of "Underestimated Conservative Rasterization", which means that only pixels that are fully covered by a rendered primitive are rasterized.</span></span> <span data-ttu-id="a359f-252">您可以透過使用輸入涵蓋範圍資料，透過圖元著色器取得低估的保守點陣化資訊，而且只有非常重要的保守點陣化可作為光柵模式。</span><span class="sxs-lookup"><span data-stu-id="a359f-252">Underestimated Conservative Rasterization information is available through the pixel shader through the use of input coverage data, and only overestimated Conservative Rasterization is available as a rasterizing mode.</span></span>

<span data-ttu-id="a359f-253">如果基本型別的任何部分與圖元重迭，則會將該圖元視為涵蓋範圍，然後再進行柵格化。</span><span class="sxs-lookup"><span data-stu-id="a359f-253">If any part of a primitive overlaps a pixel, then that pixel is considered covered and is then rasterized.</span></span> <span data-ttu-id="a359f-254">當基本的邊緣或角落落在圖元的邊緣或角落時，「左上角規則」的應用程式就會是執行特定的。</span><span class="sxs-lookup"><span data-stu-id="a359f-254">When an edge or corner of a primitive falls along the edge or corner of a pixel, the application of the "top-left rule" is implementation-specific.</span></span> <span data-ttu-id="a359f-255">不過，對於支援退化三角形的執行，沿著邊緣或角落的退化三角形必須至少涵蓋一個圖元。</span><span class="sxs-lookup"><span data-stu-id="a359f-255">However, for implementations that support degenerate triangles, a degenerate triangle along an edge or corner must cover at least one pixel.</span></span>

<span data-ttu-id="a359f-256">保守的點陣化執行會因不同的硬體而異，而且會產生誤報，這表示它們可能會不正確地判斷所涵蓋的圖元。</span><span class="sxs-lookup"><span data-stu-id="a359f-256">Conservative Rasterization implementations can vary on different hardware, and do produce false positives, meaning that they can incorrectly decide that pixels are covered.</span></span> <span data-ttu-id="a359f-257">發生這種情況的原因可能是因為執行特定的詳細資料，例如在柵格化中使用的固定點頂點座標中有基本的成長或貼齊錯誤。</span><span class="sxs-lookup"><span data-stu-id="a359f-257">This can occur because of implementation-specific details like primitive growing or snapping errors inherent in the fixed-point vertex coordinates used in rasterization.</span></span> <span data-ttu-id="a359f-258">針對固定點頂點座標 (的原因誤報) 有效的原因是，需要某些數量的誤報，才能讓執行作業對貼齊的頂點進行涵蓋範圍評估 (也就是已從浮點數轉換為轉譯器) 所使用16.8 固定點的頂點座標，但接受原始浮點數頂點座標所產生的涵蓋範圍。</span><span class="sxs-lookup"><span data-stu-id="a359f-258">The reason false positives (with respect to fixed point vertex coordinates) are valid is because some amount of false positives are needed to allow an implementation to do coverage evaluation against post-snapped vertices (i.e. vertex coordinates that have been converted from floating point to the 16.8 fixed-point used in the rasterizer), but honor the coverage produced by the original floating point vertex coordinates.</span></span>

<span data-ttu-id="a359f-259">保守式的點陣化執行不會對非退化貼齊基本專案的浮點圖元座標產生錯誤否定：如果基本專案的任何部分與圖元的任何部分重迭，則該圖元會進行點陣處理。</span><span class="sxs-lookup"><span data-stu-id="a359f-259">Conservative Rasterization implementations do not produce false negatives with respect to the floating-point vertex coordinates for non-degenerate post-snap primitives: if any part of a primitive overlaps any part of a pixel, then that pixel is rasterized.</span></span>

<span data-ttu-id="a359f-260">為退化 (索引緩衝區中的重複索引或 3D) 中的內建三角形，或在固定點轉換之後變成退化 (在轉譯器) 中的外線頂點，可能或可能不會挑選;兩者都是有效的行為。</span><span class="sxs-lookup"><span data-stu-id="a359f-260">Triangles that are degenerate (duplicate indices in an index buffer or collinear in 3D), or become degenerate after fixed-point conversion (collinear vertices in the rasterizer), may or may not be culled; both are valid behaviors.</span></span> <span data-ttu-id="a359f-261">退化三角形必須被視為對等，因此，如果應用程式需要特定的行為，則可以使用反面的剔除或測試進行正面測試。</span><span class="sxs-lookup"><span data-stu-id="a359f-261">Degenerate triangles must be considered back facing, so if a specific behavior is required by an application, it can use back-face culling or test for front facing.</span></span> <span data-ttu-id="a359f-262">退化三角形會針對所有插入值使用指派給頂點0的值。</span><span class="sxs-lookup"><span data-stu-id="a359f-262">Degenerate triangles use the values assigned to Vertex 0 for all interpolated values.</span></span>

<span data-ttu-id="a359f-263">除了硬體不支援這項功能的可能性之外，還有三個層級的硬體支援。</span><span class="sxs-lookup"><span data-stu-id="a359f-263">There are three tiers of hardware support, in addition to the possibility that the hardware does not support this feature.</span></span>

-   <span data-ttu-id="a359f-264">第1層強制執行最大1/2 圖元不確定性區域，而且不支援貼齊會變質。</span><span class="sxs-lookup"><span data-stu-id="a359f-264">Tier 1 enforces a maximum 1/2 pixel uncertainty region and does not support post-snap degenerates.</span></span> <span data-ttu-id="a359f-265">這適用于並排顯示、紋理塔圖、輕量圖產生和子圖元陰影對應。</span><span class="sxs-lookup"><span data-stu-id="a359f-265">This is good for tiled rendering, a texture atlas, light map generation and sub-pixel shadow maps.</span></span>
-   <span data-ttu-id="a359f-266">第2層將最大不確定性區域降至1/256，並要求不挑選貼齊會變質。</span><span class="sxs-lookup"><span data-stu-id="a359f-266">Tier 2 reduces the maximum uncertainty region to 1/256 and requires post-snap degenerates not be culled.</span></span> <span data-ttu-id="a359f-267">這一層對於以 CPU 為基礎的演算法加速 (很有説明，例如體素化) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-267">This tier is helpful for CPU-based algorithm acceleration (such as voxelization).</span></span>
-   <span data-ttu-id="a359f-268">第3層會維持最大1/256 不確定性區域，並新增內部輸入涵蓋範圍的支援。</span><span class="sxs-lookup"><span data-stu-id="a359f-268">Tier 3 maintains a maximum 1/256 uncertainty region and adds support for inner input coverage.</span></span> <span data-ttu-id="a359f-269">內部輸入涵蓋範圍會將新值新增 `SV_InnerCoverage` 至高階網底語言 (HLSL) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-269">Inner input coverage adds the new value `SV_InnerCoverage` to High Level Shading Language (HLSL).</span></span> <span data-ttu-id="a359f-270">這是一種32位純量整數，可在圖元著色器的輸入上指定，並代表低估的保守式點陣化資訊 (也就是，是否保證) 完全涵蓋圖元。</span><span class="sxs-lookup"><span data-stu-id="a359f-270">This is a 32-bit scalar integer that can be specified on input to a pixel shader, and represents the underestimated Conservative Rasterization information (that is, whether a pixel is guaranteed-to-be-fully covered).</span></span> <span data-ttu-id="a359f-271">這一層有助於遮蔽的挑選。</span><span class="sxs-lookup"><span data-stu-id="a359f-271">This tier is helpful for occlusion culling.</span></span>

## <a name="api-summary"></a><span data-ttu-id="a359f-272">API summary</span><span class="sxs-lookup"><span data-stu-id="a359f-272">API summary</span></span>

<span data-ttu-id="a359f-273">下列方法、結構、列舉和 helper 類別都會參考保守的點陣化：</span><span class="sxs-lookup"><span data-stu-id="a359f-273">The following methods, structures, enums, and helper classes reference Conservative Rasterization:</span></span>

-   <span data-ttu-id="a359f-274">[**D3D12 \_轉譯器 \_ DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_rasterizer_desc) ：包含轉譯器描述的結構。</span><span class="sxs-lookup"><span data-stu-id="a359f-274">[**D3D12\_RASTERIZER\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_rasterizer_desc) : structure holding the rasterizer description.</span></span>
-   <span data-ttu-id="a359f-275">[**D3D12 \_保守 \_ 點陣化 \_ 模式**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_mode) ：模式的列舉值 (on 或 off) 。</span><span class="sxs-lookup"><span data-stu-id="a359f-275">[**D3D12\_CONSERVATIVE\_RASTERIZATION\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_mode) : enum values for the mode (on or off).</span></span>
-   <span data-ttu-id="a359f-276">[**D3D12 \_功能 \_ 資料 \_ D3D12 \_ 選項**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options) ：保存支援層的結構。</span><span class="sxs-lookup"><span data-stu-id="a359f-276">[**D3D12\_FEATURE\_DATA\_D3D12\_OPTIONS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options) : structure holding the tier of support.</span></span>
-   <span data-ttu-id="a359f-277">[**D3D12 \_保守的 \_ 點陣化 \_ 層**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_tier) ：每個硬體支援層的列舉值。</span><span class="sxs-lookup"><span data-stu-id="a359f-277">[**D3D12\_CONSERVATIVE\_RASTERIZATION\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_tier) : enum values for each tier of support by the hardware.</span></span>
-   <span data-ttu-id="a359f-278">[**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) ：存取支援功能的方法。</span><span class="sxs-lookup"><span data-stu-id="a359f-278">[**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) : method to access the supported features.</span></span>
-   <span data-ttu-id="a359f-279">[**CD3DX12 \_轉譯器 \_ DESC**](cd3dx12-rasterizer-desc.md) ：用來建立轉譯器描述的協助程式類別。</span><span class="sxs-lookup"><span data-stu-id="a359f-279">[**CD3DX12\_RASTERIZER\_DESC**](cd3dx12-rasterizer-desc.md) : helper class for creating rasterizer descriptions.</span></span>

## <a name="related-topics"></a><span data-ttu-id="a359f-280">相關主題</span><span class="sxs-lookup"><span data-stu-id="a359f-280">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="a359f-281">DirectX advanced learning 影片教學課程：保守柵格化</span><span class="sxs-lookup"><span data-stu-id="a359f-281">DirectX advanced learning video tutorials : Conservative Rasterization</span></span>](https://www.youtube.com/watch?v=zL0oSY_YmDY)
</dt> <dt>

[<span data-ttu-id="a359f-282">依轉譯器排序的視圖</span><span class="sxs-lookup"><span data-stu-id="a359f-282">Rasterizer Ordered Views</span></span>](rasterizer-order-views.md)
</dt> <dt>

[<span data-ttu-id="a359f-283">轉譯</span><span class="sxs-lookup"><span data-stu-id="a359f-283">Rendering</span></span>](rendering.md)
</dt> </dl>

 

 




