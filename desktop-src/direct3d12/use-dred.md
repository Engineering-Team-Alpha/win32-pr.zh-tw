---
title: 使用 DR 診斷 GPU 錯誤
description: 裝置移除擴充資料 (DR) 是一組不斷演進的診斷功能，其設計目的是協助您找出未預期的裝置移除錯誤原因。
ms.custom: 19H1
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: bbc754239210899e804d41a294e8c9f47967fb25
ms.sourcegitcommit: 780d4b1601c45658ef0b799b80d13f45a53d808d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/26/2020
ms.locfileid: "104548379"
---
# <a name="use-dred-to-diagnose-gpu-faults"></a><span data-ttu-id="91f04-103">使用 DR 診斷 GPU 錯誤</span><span class="sxs-lookup"><span data-stu-id="91f04-103">Use DRED to diagnose GPU faults</span></span>
<span data-ttu-id="91f04-104">DR 代表裝置移除擴充的資料。</span><span class="sxs-lookup"><span data-stu-id="91f04-104">DRED stands for Device Removed Extended Data.</span></span> <span data-ttu-id="91f04-105">DR 是一組不斷演進的診斷功能，其設計目的是協助您找出非預期裝置移除錯誤的原因。</span><span class="sxs-lookup"><span data-stu-id="91f04-105">DRED is an evolving set of diagnostic features designed to help you to identify the cause of unexpected device removal errors.</span></span> <span data-ttu-id="91f04-106">在支援所需功能 (如) 所定義的硬體上，DR 會提供自動階層連結以及 GPU 分頁錯誤報告。</span><span class="sxs-lookup"><span data-stu-id="91f04-106">On hardware that supports the necessary features (as defined below), DRED delivers automatic breadcrumbs as well as GPU page fault reporting.</span></span>

## <a name="auto-breadcrumbs"></a><span data-ttu-id="91f04-107">自動階層連結</span><span class="sxs-lookup"><span data-stu-id="91f04-107">Auto-breadcrumbs</span></span>
<span data-ttu-id="91f04-108">若要設定自動階層連結的場景，讓我們先提及手動的多樣性。</span><span class="sxs-lookup"><span data-stu-id="91f04-108">To set the scene for auto-breadcrumbs, let's first mention the manual variety.</span></span> <span data-ttu-id="91f04-109">若要可能性 [Timeout 偵測和復原 (TDR)](/windows-hardware/drivers/display/timeout-detection-and-recovery)，您可以使用 [ID3D12GraphicsCommandList2：： WriteBufferImmediate 方法](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist2-writebufferimmediate)*將階層連結置於 gpu* 命令資料流程中，以便追蹤 gpu 進度。</span><span class="sxs-lookup"><span data-stu-id="91f04-109">In anticipation of the eventuality of a [Timeout Detection and Recovery (TDR)](/windows-hardware/drivers/display/timeout-detection-and-recovery), you can use the [ID3D12GraphicsCommandList2::WriteBufferImmediate method](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist2-writebufferimmediate) to place *breadcrumbs* into the GPU command stream, in order to track GPU progress.</span></span>

<span data-ttu-id="91f04-110">如果您想要建立自訂、低額外負荷的執行，這是合理的方法。</span><span class="sxs-lookup"><span data-stu-id="91f04-110">This is a reasonable approach if you want to create a custom, low-overhead implementation.</span></span> <span data-ttu-id="91f04-111">但是，它可能缺乏標準化解決方案的一些多樣性，例如偵錯工具擴充功能，或透過 [Windows 錯誤報告 (WER) ](/windows/desktop/wer/windows-error-reporting) (也稱為 Watson) 。</span><span class="sxs-lookup"><span data-stu-id="91f04-111">But it may lack some of the versatility of a standardized solution, such as debugger extensions, or reporting via [Windows Error Reporting (WER)](/windows/desktop/wer/windows-error-reporting) (also known as Watson).</span></span>

<span data-ttu-id="91f04-112">因此，DR 的自動階層連結呼叫 **WriteBufferImmediate** ，將進度計數器放置於 GPU 命令資料流程中。</span><span class="sxs-lookup"><span data-stu-id="91f04-112">So, DRED's auto-breadcrumbs call **WriteBufferImmediate** to place progress counters into the GPU command stream.</span></span> <span data-ttu-id="91f04-113">DR 會在每個轉譯作業之後插入階層 *連結，* &mdash; 這表示產生 GPU 的每個作業都會 (例如，**繪製**、**分派**、**複製**、**解析** 和其他) 。</span><span class="sxs-lookup"><span data-stu-id="91f04-113">DRED inserts a breadcrumb after each *render op*&mdash;which means every operation that results in GPU work (for example, **Draw**, **Dispatch**, **Copy**, **Resolve**, and others).</span></span> <span data-ttu-id="91f04-114">如果裝置在 GPU 工作負載的中間移除，則 DR 階層連結值基本上是在錯誤之前完成的轉譯 ops 集合。</span><span class="sxs-lookup"><span data-stu-id="91f04-114">If the device is removed in the middle of a GPU workload, then the DRED breadcrumb value is essentially a collection of the render ops that completed�before�the error.</span></span>

<span data-ttu-id="91f04-115">階層連結歷程記錄通道緩衝區會在指定的命令清單中保留最多64KiB 的作業。</span><span class="sxs-lookup"><span data-stu-id="91f04-115">The breadcrumb history ring buffer retains up to 64KiB operations in a given command list.</span></span> <span data-ttu-id="91f04-116">如果命令清單中有65536以上的作業，則只會先儲存最後一個64KiB 作業來 &mdash; 覆寫最舊的作業。</span><span class="sxs-lookup"><span data-stu-id="91f04-116">If there are more than 65536 operations in a command list, then only the last 64KiB operations are stored&mdash;overwriting the oldest operations first.</span></span> <span data-ttu-id="91f04-117">不過，階層連結計數器值會繼續計算到最多 `UINT_MAX` 。</span><span class="sxs-lookup"><span data-stu-id="91f04-117">However, the breadcrumb counter value continues to count up to `UINT_MAX`.</span></span> <span data-ttu-id="91f04-118">因此，LastOpIndex = (BreadcrumbCount-1) % 65536。</span><span class="sxs-lookup"><span data-stu-id="91f04-118">Therefore, LastOpIndex = (BreadcrumbCount - 1) % 65536.</span></span>

<span data-ttu-id="91f04-119">DR 1.0 已在 Windows 10 1809 版 (Windows 10 年10月2018更新) 中首次推出，並公開了基本的自動階層連結。</span><span class="sxs-lookup"><span data-stu-id="91f04-119">DRED 1.0 was first available in Windows 10, version 1809 (Windows 10 October 2018 Update), and it exposed rudimentary auto-breadcrumbs.</span></span> <span data-ttu-id="91f04-120">但是，它並沒有 api，因此啟用 dr 1.0 的唯一方法，就是使用意見反應 **中樞** 來為 **應用程式 & 遊戲**) \> **效能和相容性**，來取得 TDR 複製品 (重現。</span><span class="sxs-lookup"><span data-stu-id="91f04-120">However, there were no APIs for it, and the only way to enable DRED 1.0 was to use **Feedback Hub** to capture a TDR reproduction (repro) for **Apps & Games** \> **Game Performance and Compatibility**.</span></span> <span data-ttu-id="91f04-121">DR 1.0 的主要目的是協助根本原因-透過客戶意見反應來分析遊戲損毀。</span><span class="sxs-lookup"><span data-stu-id="91f04-121">The primary purpose for DRED 1.0 was to help to root-cause-analyze game crashes via customer feedback.</span></span>
### <a name="caveats"></a><span data-ttu-id="91f04-122">警示</span><span class="sxs-lookup"><span data-stu-id="91f04-122">Caveats</span></span>
- <span data-ttu-id="91f04-123">因為 GPU 會進行大量的管線，所以不保證階層連結計數器會指出失敗的確切作業。</span><span class="sxs-lookup"><span data-stu-id="91f04-123">Because a GPU is heavily pipelined, there's no guarantee that the breadcrumb counter indicates the exact operation that failed.</span></span> <span data-ttu-id="91f04-124">事實上，在某些以磚為基礎的延遲轉譯裝置上，階層連結計數器可能是完整資源或未排序的存取權， (UAV) 在實際 GPU 進度背後的關卡。</span><span class="sxs-lookup"><span data-stu-id="91f04-124">In fact, on some tile-based deferred render devices, it's possible for the breadcrumb counter to be a full resource or unordered access view (UAV) barrier behind the actual GPU progress.</span></span>
- <span data-ttu-id="91f04-125">顯示驅動程式可以重新排列命令、在執行命令前先從資源記憶體預先提取，或是在命令完成後清除快取的記憶體。</span><span class="sxs-lookup"><span data-stu-id="91f04-125">A display driver can reorder commands, pre-fetch from resource memory well before executing a command, or flush cached memory well-after completion of a command.</span></span> <span data-ttu-id="91f04-126">其中任何一項都可能產生 GPU 錯誤。</span><span class="sxs-lookup"><span data-stu-id="91f04-126">Any of these can produce a GPU error.</span></span> <span data-ttu-id="91f04-127">在這種情況下，自動階層連結計數器可能較不實用或誤導。</span><span class="sxs-lookup"><span data-stu-id="91f04-127">In such cases, the auto-breadcrumb counters may be less helpful, or misleading.</span></span>
### <a name="performance"></a><span data-ttu-id="91f04-128">效能</span><span class="sxs-lookup"><span data-stu-id="91f04-128">Performance</span></span>
<span data-ttu-id="91f04-129">雖然自動階層連結設計為低額外負荷，但不是免費的。</span><span class="sxs-lookup"><span data-stu-id="91f04-129">Although auto-breadcrumbs are designed to be low-overhead, they are not free.</span></span> <span data-ttu-id="91f04-130">經驗測量顯示一般 AAA Direct3D 12 圖形遊戲引擎的2-5% 效能損失。</span><span class="sxs-lookup"><span data-stu-id="91f04-130">Empirical measurements show 2-5% performance loss on a typical AAA Direct3D 12 graphics game engine.</span></span> <span data-ttu-id="91f04-131">基於這個理由，預設會關閉自動階層連結。</span><span class="sxs-lookup"><span data-stu-id="91f04-131">For this reason, auto-breadcrumbs are off by default.</span></span>
### <a name="hardware-requirements"></a><span data-ttu-id="91f04-132">硬體需求</span><span class="sxs-lookup"><span data-stu-id="91f04-132">Hardware requirements</span></span>
<span data-ttu-id="91f04-133">因為階層連結計數器值在裝置移除之後必須保留，所以包含階層連結的資源必須存在於系統記憶體中，而且必須在裝置移除時保存。</span><span class="sxs-lookup"><span data-stu-id="91f04-133">Because the breadcrumb counter values must be preserved after device removal, the resource that contains breadcrumbs must exist in system memory, and it must persist in the event of device removal.</span></span> <span data-ttu-id="91f04-134">這表示顯示驅動程式必須支援 [**D3D12_FEATURE_EXISTING_HEAPS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_feature)。</span><span class="sxs-lookup"><span data-stu-id="91f04-134">This means that the display driver needs to support [**D3D12_FEATURE_EXISTING_HEAPS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_feature).</span></span> <span data-ttu-id="91f04-135">幸運的是，在 Windows 10 1903 版上大部分的 Direct3D 12 顯示驅動程式都是如此。</span><span class="sxs-lookup"><span data-stu-id="91f04-135">Fortunately, this is the case for most Direct3D 12 display drivers on Windows 10, version 1903.</span></span>
## <a name="gpu-page-fault-reporting"></a><span data-ttu-id="91f04-136">GPU 分頁錯誤報告</span><span class="sxs-lookup"><span data-stu-id="91f04-136">GPU page fault reporting</span></span>
<span data-ttu-id="91f04-137">DR 1.1 的新功能是 DR GPU 分頁錯誤報告。</span><span class="sxs-lookup"><span data-stu-id="91f04-137">A feature that's new for DRED 1.1 is DRED GPU page fault reporting.</span></span> <span data-ttu-id="91f04-138">GPU 分頁錯誤通常會在下列其中一種情況下發生。</span><span class="sxs-lookup"><span data-stu-id="91f04-138">A GPU page fault commonly occurs under one of these conditions.</span></span>

1. <span data-ttu-id="91f04-139">應用程式錯誤地在參考已刪除物件的 GPU 上執行工作。</span><span class="sxs-lookup"><span data-stu-id="91f04-139">An application mistakenly executes work on the GPU that references a deleted object.</span></span> <span data-ttu-id="91f04-140">這是意外移除裝置的主要原因之一。</span><span class="sxs-lookup"><span data-stu-id="91f04-140">This is one of the top reasons for an unexpected device removal.</span></span>
2. <span data-ttu-id="91f04-141">應用程式會在存取已收回資源或非常駐磚的 GPU 上，錯誤地執行工作。</span><span class="sxs-lookup"><span data-stu-id="91f04-141">An application mistakenly executes work on the GPU that accesses an evicted resource, or a non-resident tile.</span></span>
3. <span data-ttu-id="91f04-142">著色器參考未初始化或過時的描述項。</span><span class="sxs-lookup"><span data-stu-id="91f04-142">A shader references an uninitialized or stale descriptor.</span></span>
3. <span data-ttu-id="91f04-143">根系結結尾以外的著色器索引。</span><span class="sxs-lookup"><span data-stu-id="91f04-143">A shader indexes beyond the end of a root binding.</span></span>

<span data-ttu-id="91f04-144">DR 會藉由報告任何現有或最近釋出之 API 物件的名稱和類型，以符合 GPU 回報分頁錯誤的虛擬位址 (VA) ，來嘗試解決其中一些案例。</span><span class="sxs-lookup"><span data-stu-id="91f04-144">DRED attempts to address some of these scenarios by reporting the names and types of any existing or recently freed API objects that match the virtual address (VA) of the GPU-reported page fault.</span></span>

### <a name="caveat"></a><span data-ttu-id="91f04-145">警告</span><span class="sxs-lookup"><span data-stu-id="91f04-145">Caveat</span></span>
<span data-ttu-id="91f04-146">雖然所有 Gpu 都不支援分頁錯誤 (但許多都) 。</span><span class="sxs-lookup"><span data-stu-id="91f04-146">Not all GPUs support page faults (although, many do).</span></span> <span data-ttu-id="91f04-147">某些 Gpu 會透過下列方式來回應記憶體錯誤：位值寫入;讀取模擬資料 (例如，零) ;或者只是掛斷。</span><span class="sxs-lookup"><span data-stu-id="91f04-147">Some GPUs respond to memory faults by: bit-bucket writes; reading simulated data (for example,�zeros); or by simply hanging.</span></span> <span data-ttu-id="91f04-148">可惜的是，在 GPU 不會立即停止回應的情況下， [TDR) 的超時偵測和復原 (](/windows-hardware/drivers/display/timeout-detection-and-recovery) 可能會在管道稍後發生，因此更難找到根本原因。</span><span class="sxs-lookup"><span data-stu-id="91f04-148">Unfortunately, in cases where the GPU doesn't immediately hang, a [Timeout Detection and Recovery (TDR)](/windows-hardware/drivers/display/timeout-detection-and-recovery) can happen later in the pipe, making it even harder to locate the root cause.</span></span>

### <a name="performance"></a><span data-ttu-id="91f04-149">效能</span><span class="sxs-lookup"><span data-stu-id="91f04-149">Performance</span></span>
<span data-ttu-id="91f04-150">Direct3D 12 執行時間必須主動策展 (VA) 的虛擬位址可編制索引的現有和最近刪除 API 物件的集合。</span><span class="sxs-lookup"><span data-stu-id="91f04-150">The Direct3D 12 runtime must actively curate a collection of existing and recently-deleted API objects indexable by virtual address (VA).</span></span> <span data-ttu-id="91f04-151">這會增加系統記憶體的額外負荷，並對物件建立和終結帶來輕微的效能衝擊。</span><span class="sxs-lookup"><span data-stu-id="91f04-151">This increases the system memory overhead, and introduces a small performance hit to object creation and destruction.</span></span> <span data-ttu-id="91f04-152">基於這個原因，預設會關閉此行為。</span><span class="sxs-lookup"><span data-stu-id="91f04-152">For that reason, this behavior is off by default.</span></span>

### <a name="hardware-requirements"></a><span data-ttu-id="91f04-153">硬體需求</span><span class="sxs-lookup"><span data-stu-id="91f04-153">Hardware requirements</span></span>
<span data-ttu-id="91f04-154">不支援分頁錯誤的 GPU 仍可受益于自動階層連結功能。</span><span class="sxs-lookup"><span data-stu-id="91f04-154">A GPU that doesn't support page faulting can still benefit from the auto-breadcrumbs feature.</span></span>

## <a name="setting-up-dred-in-code"></a><span data-ttu-id="91f04-155">在程式碼中設定 DR</span><span class="sxs-lookup"><span data-stu-id="91f04-155">Setting up DRED in code</span></span>
<span data-ttu-id="91f04-156">DR 設定對程式而言是全域的，您必須先設定這些設定，才能建立 Direct3D 12 裝置。</span><span class="sxs-lookup"><span data-stu-id="91f04-156">DRED settings are global to the process, and you must configure them prior to creating a Direct3D 12 Device.</span></span> <span data-ttu-id="91f04-157">若要這樣做，請呼叫 [**D3D12GetDebugInterface**](/windows/desktop/api/d3d12/nf-d3d12-d3d12getdebuginterface) 函式來取得 [**ID3D12DeviceRemovedExtendedDataSettings**](/windows/desktop/api/d3d12/nn-d3d12-id3d12deviceremovedextendeddatasettings)。</span><span class="sxs-lookup"><span data-stu-id="91f04-157">To do so, call the [**D3D12GetDebugInterface**](/windows/desktop/api/d3d12/nf-d3d12-d3d12getdebuginterface) function to retrieve an [**ID3D12DeviceRemovedExtendedDataSettings**](/windows/desktop/api/d3d12/nn-d3d12-id3d12deviceremovedextendeddatasettings).</span></span>

```cpp
CComPtr<ID3D12DeviceRemovedExtendedDataSettings> pDredSettings;
VERIFY_SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&pDredSettings)));

// Turn on auto-breadcrumbs and page fault reporting.
pDredSettings->SetAutoBreadcrumbsEnablement(D3D12_DRED_ENABLEMENT_FORCED_ON);
pDredSettings->SetPageFaultEnablement(D3D12_DRED_ENABLEMENT_FORCED_ON);
```

> [!NOTE]
> <span data-ttu-id="91f04-158">DR 設定的修改不會影響已建立的裝置。</span><span class="sxs-lookup"><span data-stu-id="91f04-158">Modifications to DRED settings have no effect on devices already created.</span></span> <span data-ttu-id="91f04-159">但後續的 [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice) 呼叫會使用最新的 dr 設定。</span><span class="sxs-lookup"><span data-stu-id="91f04-159">But subsequent calls to [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice) use the most recent DRED settings.</span></span>

## <a name="accessing-dred-data-in-code"></a><span data-ttu-id="91f04-160">存取程式碼中的 DR 資料</span><span class="sxs-lookup"><span data-stu-id="91f04-160">Accessing DRED data in code</span></span>
<span data-ttu-id="91f04-161">偵測到裝置移除之後 (例如， **現在** 會傳回 [**DXGI_ERROR_DEVICE_REMOVED**](/windows/desktop/com/com-error-codes-10)) ，請使用 [**ID3D12DeviceRemovedExtendedData**](/windows/desktop/api/d3d12/nn-d3d12-id3d12deviceremovedextendeddata) 介面的方法來存取已移除裝置的 dr 資料。</span><span class="sxs-lookup"><span data-stu-id="91f04-161">After device removal has been detected (for example, **Present** returns [**DXGI_ERROR_DEVICE_REMOVED**](/windows/desktop/com/com-error-codes-10)), use the methods of the [**ID3D12DeviceRemovedExtendedData**](/windows/desktop/api/d3d12/nn-d3d12-id3d12deviceremovedextendeddata) interface to access the DRED data for the removed device.</span></span>

<span data-ttu-id="91f04-162">若要取出 **ID3D12DeviceRemovedExtendedData** 介面，請在 [ID3D12Device](/windows/win32/api/d3d12/nn-d3d12-id3d12device) (或衍生的) 介面上呼叫 [QueryInterface](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)) ，並將介面識別碼 (IID) 傳遞至 **ID3D12DeviceRemovedExtendedData**。</span><span class="sxs-lookup"><span data-stu-id="91f04-162">To retrieve the **ID3D12DeviceRemovedExtendedData** interface, call [QueryInterface](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)) on an [ID3D12Device](/windows/win32/api/d3d12/nn-d3d12-id3d12device) (or derived) interface, passing the interface identifier (IID) of **ID3D12DeviceRemovedExtendedData**.</span></span>

```cpp
void MyDeviceRemovedHandler(ID3D12Device * pDevice)
{
    CComPtr<ID3D12DeviceRemovedExtendedData> pDred;
    VERIFY_SUCCEEDED(pDevice->QueryInterface(IID_PPV_ARGS(&pDred)));
    D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT DredAutoBreadcrumbsOutput;
    D3D12_DRED_PAGE_FAULT_OUTPUT DredPageFaultOutput;
    VERIFY_SUCCEEDED(pDred->GetAutoBreadcrumbsOutput(&DredAutoBreadcrumbsOutput));
    VERIFY_SUCCEEDED(pDred->GetPageFaultAllocationOutput(&DredPageFaultOutput));
    // Custom processing of DRED data can be done here.
    // Produce telemetry...
    // Log information to console...
    // break into a debugger...
}
```

## <a name="debugger-access-to-dred"></a><span data-ttu-id="91f04-163">DR 的偵錯工具存取</span><span class="sxs-lookup"><span data-stu-id="91f04-163">Debugger access to DRED</span></span>
<span data-ttu-id="91f04-164">偵錯工具可透過 d3d12 存取 DR 資料 **！D3D12DeviceRemovedExtendedData** 資料匯出。</span><span class="sxs-lookup"><span data-stu-id="91f04-164">Debuggers have access to the DRED data via the **d3d12!D3D12DeviceRemovedExtendedData** data export.</span></span>

## <a name="dred-telemetry"></a><span data-ttu-id="91f04-165">DR 遙測</span><span class="sxs-lookup"><span data-stu-id="91f04-165">DRED telemetry</span></span>
<span data-ttu-id="91f04-166">您的應用程式可以使用 DR Api 來控制 DR 功能，並收集遙測資料以協助分析問題。</span><span class="sxs-lookup"><span data-stu-id="91f04-166">Your application can use the DRED APIs to control DRED features, and to collect telemetry to help analyze problems.</span></span> <span data-ttu-id="91f04-167">這可提供您更廣泛的網路來攔截這些難以重現的 Tdr。</span><span class="sxs-lookup"><span data-stu-id="91f04-167">This gives you a much broader net for catching those hard-to-reproduce TDRs.</span></span>

<span data-ttu-id="91f04-168">從 Windows 10 版本1903，所有使用者模式裝置移除的事件都會回報給 [Windows 錯誤報告， (WER) ](/windows/desktop/wer/windows-error-reporting)，也稱為 Watson。</span><span class="sxs-lookup"><span data-stu-id="91f04-168">As of Windows 10, version 1903, all user-mode device-removed events are reported to [Windows Error Reporting (WER)](/windows/desktop/wer/windows-error-reporting), also known as Watson.</span></span> <span data-ttu-id="91f04-169">如果應用程式、GPU 和顯示驅動程式的特定組合產生足夠數目的裝置移除事件，則可能會暫時啟用 DR，讓客戶在類似的設定上啟動相同的應用程式。</span><span class="sxs-lookup"><span data-stu-id="91f04-169">If a particular combination of application, GPU, and display driver generates a sufficient number of device-removed events, then it's possible that DRED will be temporarily enabled for customers launching the same application on a similar configuration.</span></span>
