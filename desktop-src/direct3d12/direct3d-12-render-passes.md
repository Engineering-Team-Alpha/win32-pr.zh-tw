---
title: Direct3D 12 轉譯階段
description: 轉譯傳遞功能可減少進出晶片記憶體的記憶體流量，協助您的轉譯器改善 GPU 效率;它的做法是讓您的應用程式更清楚地識別資源轉譯順序需求和資料相依性。
ms.localizationpriority: high
ms.topic: article
ms.date: 11/15/2018
ms.openlocfilehash: f776729f17ac0017d713c6f37bc71de7302a7c08
ms.sourcegitcommit: 780d4b1601c45658ef0b799b80d13f45a53d808d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/26/2020
ms.locfileid: "104548347"
---
# <a name="direct3d-12-render-passes"></a><span data-ttu-id="c4296-103">Direct3D 12 轉譯階段</span><span class="sxs-lookup"><span data-stu-id="c4296-103">Direct3D 12 render passes</span></span>

<span data-ttu-id="c4296-104">轉譯階段功能是 Windows 10 1809 版的新功能， (10.0;組建 17763) ，並介紹 Direct3D 12 轉譯傳遞的概念。</span><span class="sxs-lookup"><span data-stu-id="c4296-104">The render passes feature is new for Windows 10, version 1809 (10.0; Build 17763), and it introduces the concept of a Direct3D 12 render pass.</span></span> <span data-ttu-id="c4296-105">轉譯階段是由您記錄至命令清單中的命令子集所組成。</span><span class="sxs-lookup"><span data-stu-id="c4296-105">A render pass consists of a subset of the commands that you record into a command list.</span></span>

<span data-ttu-id="c4296-106">若要宣告每個轉譯傳遞的開始和結束位置，您可以將屬於該傳遞的命令，裝載至 [**ID3D12GraphicsCommandList4：： BeginRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass) 和 [**EndRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-endrenderpass)的呼叫內。</span><span class="sxs-lookup"><span data-stu-id="c4296-106">To declare where each render pass begins and ends, you nest the commands belonging to that pass inside calls to [**ID3D12GraphicsCommandList4::BeginRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass) and [**EndRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-endrenderpass).</span></span> <span data-ttu-id="c4296-107">因此，任何命令清單都會包含零個、一個或多個轉譯階段。</span><span class="sxs-lookup"><span data-stu-id="c4296-107">Consequently, any command list contains zero, one, or more render passes.</span></span>

## <a name="scenarios"></a><span data-ttu-id="c4296-108">案例</span><span class="sxs-lookup"><span data-stu-id="c4296-108">Scenarios</span></span>

<span data-ttu-id="c4296-109">轉譯行程可以改善轉譯器的效能（如果它是根據 Tile-Based 延後轉譯 (TBDR) ），以及其他技巧。</span><span class="sxs-lookup"><span data-stu-id="c4296-109">Render passes can improve the performance of your renderer if it's based on Tile-Based Deferred Rendering (TBDR), among other techniques.</span></span> <span data-ttu-id="c4296-110">更具體來說，此技巧可讓您的應用程式更清楚地識別資源轉譯順序需求和資料相依性，藉此協助轉譯器改善 GPU 效率。</span><span class="sxs-lookup"><span data-stu-id="c4296-110">More specifically, the technique helps your renderer to improve GPU efficiency by reducing memory traffic to/from off-chip memory by enabling your application to better identify resource rendering ordering requirements and data dependencies.</span></span>

<span data-ttu-id="c4296-111">明確撰寫以利用轉譯階段功能的顯示器驅動程式，可提供最佳結果。</span><span class="sxs-lookup"><span data-stu-id="c4296-111">A display driver written expressly to leverage the render passes feature gives the best results.</span></span> <span data-ttu-id="c4296-112">但即使在預先存在的驅動程式上，轉譯傳遞 Api 仍可執行 (但不一定會) 效能改進。</span><span class="sxs-lookup"><span data-stu-id="c4296-112">But render passes APIs can run even on pre-existing drivers (although, not necessarily with performance improvements).</span></span>

<span data-ttu-id="c4296-113">這些是轉譯階段為了提供價值而設計的案例。</span><span class="sxs-lookup"><span data-stu-id="c4296-113">These are the scenarios in which render passes is designed to provide value.</span></span>

### <a name="allow-your-application-to-avoid-unnecessary-loadsstores-of-resources-fromto-main-memory-on-a-tile-based-deferred-rendering-tbdr-architecture"></a><span data-ttu-id="c4296-114">允許您的應用程式在 Tile-Based 延後轉譯 (TBDR) 架構上，避免不必要的資源載入/儲存至主儲存體</span><span class="sxs-lookup"><span data-stu-id="c4296-114">Allow your application to avoid unnecessary loads/stores of resources from/to main memory on a Tile-Based Deferred Rendering (TBDR) architecture</span></span>

<span data-ttu-id="c4296-115">轉譯行程的價值主張之一，是它會提供中央位置，指出應用程式對於一組轉譯作業的資料相依性。</span><span class="sxs-lookup"><span data-stu-id="c4296-115">One of the value propositions of render passes is that it provides you with a central location to indicate your application's data dependencies for a set of rendering operations.</span></span> <span data-ttu-id="c4296-116">這些資料相依性可讓顯示驅動程式在系結/關卡時間檢查這項資料，併發出指示將資源的載入/儲存從主儲存體降至最低。</span><span class="sxs-lookup"><span data-stu-id="c4296-116">These data dependencies allow the display driver to inspect this data at bind/barrier time, and to issue instructions that minimize resource loads/stores from/to main memory.</span></span>

### <a name="allow-your-tbdr-architecture-to-opportunistically-persistent-resources-in-on-chip-cache-across-render-passes-even-in-separate-command-lists"></a><span data-ttu-id="c4296-117">即使在個別的命令清單中，您的 TBDR 架構也可讓轉譯行程在內部晶片快取中伺機持續性資源 () </span><span class="sxs-lookup"><span data-stu-id="c4296-117">Allow your TBDR architecture to opportunistically persistent resources in on-chip cache across render passes (even in separate Command Lists)</span></span>

> [!NOTE]
> <span data-ttu-id="c4296-118">具體而言，此案例僅限於您要在多個命令清單中) 寫入相同轉譯目標 (s 的情況。</span><span class="sxs-lookup"><span data-stu-id="c4296-118">Specifically, this scenario is limited to the cases where you're writing to the same render target(s) across multiple command lists.</span></span>

<span data-ttu-id="c4296-119">常見的轉譯模式是讓您的應用程式以序列方式跨多個命令清單轉譯成相同的轉譯目標 (s) ，即使是以平行方式產生轉譯命令也是一樣。</span><span class="sxs-lookup"><span data-stu-id="c4296-119">A common rendering pattern is for your application to render to the same render target(s) across multiple command lists serially, even though the rendering commands are generated in parallel.</span></span> <span data-ttu-id="c4296-120">在此案例中使用轉譯階段可讓這些傳遞以 (的方式結合，因為應用程式知道它將會在立即的命令清單中繼續轉譯，) 顯示驅動程式可避免在命令清單界限上清除主儲存體。</span><span class="sxs-lookup"><span data-stu-id="c4296-120">Your use of render passes in this scenario allows these passes to be combined in such a way (since the application knows that it will resume rendering on the immediate succeeding command list) that the display driver can avoid a flush to main memory on command list boundaries.</span></span>

## <a name="your-applications-responsibilities"></a><span data-ttu-id="c4296-121">您的應用程式責任</span><span class="sxs-lookup"><span data-stu-id="c4296-121">Your application's responsibilities</span></span>

<span data-ttu-id="c4296-122">即使使用轉譯階段功能，Direct3D 12 執行時間和顯示驅動程式都不會負責重新排序/避免載入和儲存的推算出機會。</span><span class="sxs-lookup"><span data-stu-id="c4296-122">Even with the render passes feature, neither the Direct3D 12 runtime nor the display driver take on the responsibility of deducing opportunities to re-order/avoid loads and stores.</span></span> <span data-ttu-id="c4296-123">若要正確運用轉譯階段功能，您的應用程式具有這些責任。</span><span class="sxs-lookup"><span data-stu-id="c4296-123">To correctly leverage the render passes feature, your application has these responsibilities.</span></span>

- <span data-ttu-id="c4296-124">適當地識別其作業的資料/順序相依性。</span><span class="sxs-lookup"><span data-stu-id="c4296-124">Properly identify data/ordering dependencies for its operations.</span></span>
- <span data-ttu-id="c4296-125">以最小化 (的方式來排序其提交，將 **_PRESERVE** 旗標) 的使用降至最低。</span><span class="sxs-lookup"><span data-stu-id="c4296-125">Order its submissions in a way that minimizes flushes (so, minimize your use of **_PRESERVE** flags).</span></span>
- <span data-ttu-id="c4296-126">正確利用資源阻礙，並追蹤資源狀態。</span><span class="sxs-lookup"><span data-stu-id="c4296-126">Correctly make use of resource barriers, and track resource state.</span></span>
- <span data-ttu-id="c4296-127">避免不必要的複本/清除。</span><span class="sxs-lookup"><span data-stu-id="c4296-127">Avoid unneeded copies/clears.</span></span> <span data-ttu-id="c4296-128">為了協助識別這些資訊，您可以從 [Windows 工具上的 PIX](https://devblogs.microsoft.com/pix/)使用自動化效能警告。</span><span class="sxs-lookup"><span data-stu-id="c4296-128">To help identify these, you can make use of the automated performance warnings from the [PIX on Windows tool](https://devblogs.microsoft.com/pix/).</span></span>

## <a name="using-the-render-pass-feature"></a><span data-ttu-id="c4296-129">使用轉譯傳遞功能</span><span class="sxs-lookup"><span data-stu-id="c4296-129">Using the render pass feature</span></span>

### <a name="what-is-a-render-pass"></a><span data-ttu-id="c4296-130">什麼是轉譯 *階段*？</span><span class="sxs-lookup"><span data-stu-id="c4296-130">What is a *render pass*?</span></span>

<span data-ttu-id="c4296-131">轉譯行程是由這些元素所定義。</span><span class="sxs-lookup"><span data-stu-id="c4296-131">A render pass is defined by these elements.</span></span>

- <span data-ttu-id="c4296-132">一組在轉譯行程期間固定的輸出系結。</span><span class="sxs-lookup"><span data-stu-id="c4296-132">A set of output bindings that are fixed for the duration of the render pass.</span></span> <span data-ttu-id="c4296-133">這些系結會指向一或多個轉譯目標視圖 (RTVs) 和/或深度樣板視圖 (DSV) 。</span><span class="sxs-lookup"><span data-stu-id="c4296-133">These bindings are to one or more render target views (RTVs), and/or to a depth stencil view (DSV).</span></span>
- <span data-ttu-id="c4296-134">以該輸出系結集合為目標的 GPU 作業清單。</span><span class="sxs-lookup"><span data-stu-id="c4296-134">A list of GPU operations that target that set of output bindings.</span></span>
- <span data-ttu-id="c4296-135">中繼資料，描述轉譯行程設為目標之所有輸出系結的載入/儲存相依性。</span><span class="sxs-lookup"><span data-stu-id="c4296-135">Metadata that describes the load/store dependencies for all output bindings targeted by the render pass.</span></span>

### <a name="declare-your-output-bindings"></a><span data-ttu-id="c4296-136">宣告您的輸出系結</span><span class="sxs-lookup"><span data-stu-id="c4296-136">Declare your output bindings</span></span>

<span data-ttu-id="c4296-137">在轉譯階段開始時，您可以宣告轉譯目標 (s) 和/或深度/樣板緩衝區的系結。</span><span class="sxs-lookup"><span data-stu-id="c4296-137">At the start of a render pass, you declare bindings to your render target(s) and/or to your depth/stencil buffer.</span></span> <span data-ttu-id="c4296-138">您可以選擇性地系結以轉譯目標 (s) ，而且可以選擇性地系結至深度/樣板緩衝區。</span><span class="sxs-lookup"><span data-stu-id="c4296-138">It's optional to bind to render target(s), and it's optional to bind to a depth/stencil buffer.</span></span> <span data-ttu-id="c4296-139">但是，您至少必須系結至兩者的其中一個，並在下面的程式碼範例中系結至兩者。</span><span class="sxs-lookup"><span data-stu-id="c4296-139">But you must bind to at least one of the two, and in the code example below we bind to both.</span></span>

<span data-ttu-id="c4296-140">您可以在 [**ID3D12GraphicsCommandList4：： BeginRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass)的呼叫中宣告這些系結。</span><span class="sxs-lookup"><span data-stu-id="c4296-140">You declare these bindings in a call to [**ID3D12GraphicsCommandList4::BeginRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass).</span></span>

```cppwinrt
void render_passes(::ID3D12GraphicsCommandList4 * pIGCL4,
    D3D12_CPU_DESCRIPTOR_HANDLE const& rtvCPUDescriptorHandle,
    D3D12_CPU_DESCRIPTOR_HANDLE const& dsvCPUDescriptorHandle)
{
    const float clearColor4[]{ 0.f, 0.f, 0.f, 0.f };
    CD3DX12_CLEAR_VALUE clearValue{ DXGI_FORMAT_R32G32B32_FLOAT, clearColor4 };

    D3D12_RENDER_PASS_BEGINNING_ACCESS renderPassBeginningAccessClear{ D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_CLEAR, { clearValue } };
    D3D12_RENDER_PASS_ENDING_ACCESS renderPassEndingAccessPreserve{ D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE, {} };
    D3D12_RENDER_PASS_RENDER_TARGET_DESC renderPassRenderTargetDesc{ rtvCPUDescriptorHandle, renderPassBeginningAccessClear, renderPassEndingAccessPreserve };

    D3D12_RENDER_PASS_BEGINNING_ACCESS renderPassBeginningAccessNoAccess{ D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_NO_ACCESS, {} };
    D3D12_RENDER_PASS_ENDING_ACCESS renderPassEndingAccessNoAccess{ D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_NO_ACCESS, {} };
    D3D12_RENDER_PASS_DEPTH_STENCIL_DESC renderPassDepthStencilDesc{ dsvCPUDescriptorHandle, renderPassBeginningAccessNoAccess, renderPassBeginningAccessNoAccess, renderPassEndingAccessNoAccess, renderPassEndingAccessNoAccess };

    pIGCL4->BeginRenderPass(1, &renderPassRenderTargetDesc, &renderPassDepthStencilDesc, D3D12_RENDER_PASS_FLAG_NONE);
    // Record command list.
    pIGCL4->EndRenderPass();
    // Begin/End further render passes and then execute the command list(s).
}
```

<span data-ttu-id="c4296-141">您可以將 [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) 結構的第一個欄位設定為 CPU 描述項控制碼，以對應至一個或多個轉譯目標視圖 (RTVs) 。</span><span class="sxs-lookup"><span data-stu-id="c4296-141">You set the first field of the [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) structure to the CPU descriptor handle corresponding to one or more render target views (RTVs).</span></span> <span data-ttu-id="c4296-142">同樣地， [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) 包含對應至深度樣板視圖 (DSV) 的 CPU 描述項控制碼。</span><span class="sxs-lookup"><span data-stu-id="c4296-142">Similarly, [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) contains the CPU descriptor handle corresponding to a depth stencil view (DSV).</span></span> <span data-ttu-id="c4296-143">這些 CPU 描述項控制碼與您要傳遞給 [**ID3D12GraphicsCommandList：： OMSetRenderTargets**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets)的是相同的。</span><span class="sxs-lookup"><span data-stu-id="c4296-143">Those CPU descriptor handles are the same ones that you would otherwise pass to [**ID3D12GraphicsCommandList::OMSetRenderTargets**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets).</span></span> <span data-ttu-id="c4296-144">而且就像使用 **OMSetRenderTargets** 一樣，在呼叫 **BEGINRENDERPASS** 時，cpu 描述 *項會從其各自的 (* cpu 描述元) 堆積。</span><span class="sxs-lookup"><span data-stu-id="c4296-144">And, just as with **OMSetRenderTargets**, the CPU descriptors are *snapped* from their respective (CPU descriptor) heaps at the time of the call to **BeginRenderPass**.</span></span>

<span data-ttu-id="c4296-145">RTVs 和 DSV 不會繼承到轉譯階段。</span><span class="sxs-lookup"><span data-stu-id="c4296-145">The RTVs and DSV are not inherited in to the render pass.</span></span> <span data-ttu-id="c4296-146">相反地，必須設定它們。</span><span class="sxs-lookup"><span data-stu-id="c4296-146">Rather, they must be set.</span></span> <span data-ttu-id="c4296-147">**BeginRenderPass** 中宣告的 RTVS 和 DSV 也會傳播至命令清單。</span><span class="sxs-lookup"><span data-stu-id="c4296-147">Nor are the RTVs and DSV declared in **BeginRenderPass** propagated out to the command list.</span></span> <span data-ttu-id="c4296-148">相反地，它們會在轉譯階段之後處於未定義狀態。</span><span class="sxs-lookup"><span data-stu-id="c4296-148">Rather, they are in an undefined state following the render pass.</span></span>

### <a name="render-passes-and-workloads"></a><span data-ttu-id="c4296-149">轉譯階段和工作負載</span><span class="sxs-lookup"><span data-stu-id="c4296-149">Render passes and workloads</span></span>

<span data-ttu-id="c4296-150">您無法嵌套轉譯行程，也不能有轉譯行程跨一個以上的命令清單 (它們必須在錄製至單一命令清單) 時開始和結束。</span><span class="sxs-lookup"><span data-stu-id="c4296-150">You can't nest render passes, and you can't have a render pass straddle more than one command list (they must begin and end while recording into a single command list).</span></span> <span data-ttu-id="c4296-151">以下的「轉譯 [ 傳遞旗標](#render-pass-flags)」一節中會討論設計來啟用有效率的轉譯行程產生功能的優化。</span><span class="sxs-lookup"><span data-stu-id="c4296-151">Optimizations designed to enable efficient multi-threaded generation of render passes are discussed in the section [ render pass Flags](#render-pass-flags), below.</span></span>

<span data-ttu-id="c4296-152">您從轉譯傳遞中所做的寫入，在後續轉譯行程 *之前無法讀取* 。</span><span class="sxs-lookup"><span data-stu-id="c4296-152">A write that you do from within a render pass isn't *valid* for you to read from until a subsequent render pass.</span></span> <span data-ttu-id="c4296-153">這會從轉譯行程中排除某些類型的阻礙 &mdash; ，例如，從 **RENDER_TARGET** barriering 至目前系結轉譯目標上 **SHADER_RESOURCE** 。</span><span class="sxs-lookup"><span data-stu-id="c4296-153">That precludes some types of barriers from within the render pass&mdash;for example, barriering from **RENDER_TARGET** to **SHADER_RESOURCE** on the currently-bound render target.</span></span> <span data-ttu-id="c4296-154">如需詳細資訊，請參閱下方的轉譯行程 [和資源阻礙](#render-passes-and-resource-barriers)一節。</span><span class="sxs-lookup"><span data-stu-id="c4296-154">For more info, see the section [Render passes and resource barriers](#render-passes-and-resource-barriers), below.</span></span>

<span data-ttu-id="c4296-155">剛才提及之寫入讀取條件約束的唯一例外，就是在深度測試和轉譯目標混合的過程中發生的隱含讀取。</span><span class="sxs-lookup"><span data-stu-id="c4296-155">The one exception to the write-read constraint just mentioned involves the implicit reads that occur as part of depth-testing and render target blending.</span></span>
<span data-ttu-id="c4296-156">因此，轉譯行程中不允許這些 Api (如果在錄製) 期間呼叫了這些 Api，則會移除該命令清單。</span><span class="sxs-lookup"><span data-stu-id="c4296-156">So, these APIs are disallowed within a render pass (the core runtime removes the command list if any of them are called during recording).</span></span>

- [<span data-ttu-id="c4296-157">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT**</span><span class="sxs-lookup"><span data-stu-id="c4296-157">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint)
- [<span data-ttu-id="c4296-158">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64**</span><span class="sxs-lookup"><span data-stu-id="c4296-158">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64)
- [<span data-ttu-id="c4296-159">**ID3D12GraphicsCommandList4::BeginRenderPass**</span><span class="sxs-lookup"><span data-stu-id="c4296-159">**ID3D12GraphicsCommandList4::BeginRenderPass**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass)
- [<span data-ttu-id="c4296-160">**ID3D12GraphicsCommandList::ClearDepthStencilView**</span><span class="sxs-lookup"><span data-stu-id="c4296-160">**ID3D12GraphicsCommandList::ClearDepthStencilView**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-cleardepthstencilview)
- [<span data-ttu-id="c4296-161">**ID3D12GraphicsCommandList::ClearRenderTargetView**</span><span class="sxs-lookup"><span data-stu-id="c4296-161">**ID3D12GraphicsCommandList::ClearRenderTargetView**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearrendertargetview)
- [<span data-ttu-id="c4296-162">**ID3D12GraphicsCommandList::ClearState**</span><span class="sxs-lookup"><span data-stu-id="c4296-162">**ID3D12GraphicsCommandList::ClearState**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearstate)
- [<span data-ttu-id="c4296-163">**ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat**</span><span class="sxs-lookup"><span data-stu-id="c4296-163">**ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewfloat)
- [<span data-ttu-id="c4296-164">**ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint**</span><span class="sxs-lookup"><span data-stu-id="c4296-164">**ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewuint)
- [<span data-ttu-id="c4296-165">**ID3D12GraphicsCommandList::CopyBufferRegion**</span><span class="sxs-lookup"><span data-stu-id="c4296-165">**ID3D12GraphicsCommandList::CopyBufferRegion**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copybufferregion)
- [<span data-ttu-id="c4296-166">**ID3D12GraphicsCommandList::CopyResource**</span><span class="sxs-lookup"><span data-stu-id="c4296-166">**ID3D12GraphicsCommandList::CopyResource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copyresource)
- [<span data-ttu-id="c4296-167">**ID3D12GraphicsCommandList::CopyTextureRegion**</span><span class="sxs-lookup"><span data-stu-id="c4296-167">**ID3D12GraphicsCommandList::CopyTextureRegion**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion)
- [<span data-ttu-id="c4296-168">**ID3D12GraphicsCommandList::CopyTiles**</span><span class="sxs-lookup"><span data-stu-id="c4296-168">**ID3D12GraphicsCommandList::CopyTiles**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytiles)
- [<span data-ttu-id="c4296-169">**ID3D12GraphicsCommandList：:D iscardResource**</span><span class="sxs-lookup"><span data-stu-id="c4296-169">**ID3D12GraphicsCommandList::DiscardResource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-discardresource)
- [<span data-ttu-id="c4296-170">**ID3D12GraphicsCommandList：:D ispatch**</span><span class="sxs-lookup"><span data-stu-id="c4296-170">**ID3D12GraphicsCommandList::Dispatch**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch)
- [<span data-ttu-id="c4296-171">**ID3D12GraphicsCommandList::OMSetRenderTargets**</span><span class="sxs-lookup"><span data-stu-id="c4296-171">**ID3D12GraphicsCommandList::OMSetRenderTargets**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets)
- [<span data-ttu-id="c4296-172">**ID3D12GraphicsCommandList::ResolveQueryData**</span><span class="sxs-lookup"><span data-stu-id="c4296-172">**ID3D12GraphicsCommandList::ResolveQueryData**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvequerydata)
- [<span data-ttu-id="c4296-173">**ID3D12GraphicsCommandList::ResolveSubresource**</span><span class="sxs-lookup"><span data-stu-id="c4296-173">**ID3D12GraphicsCommandList::ResolveSubresource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvesubresource)
- [<span data-ttu-id="c4296-174">**ID3D12GraphicsCommandList1::ResolveSubresourceRegion**</span><span class="sxs-lookup"><span data-stu-id="c4296-174">**ID3D12GraphicsCommandList1::ResolveSubresourceRegion**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion)
- [<span data-ttu-id="c4296-175">**ID3D12GraphicsCommandList3::SetProtectedResourceSession**</span><span class="sxs-lookup"><span data-stu-id="c4296-175">**ID3D12GraphicsCommandList3::SetProtectedResourceSession**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist3-setprotectedresourcesession)

### <a name="render-passes-and-resource-barriers"></a><span data-ttu-id="c4296-176">轉譯通過和資源阻礙</span><span class="sxs-lookup"><span data-stu-id="c4296-176">Render passes and resource barriers</span></span>

<span data-ttu-id="c4296-177">您不得讀取或取用在相同轉譯階段中發生的寫入。</span><span class="sxs-lookup"><span data-stu-id="c4296-177">You may not read from, or consume, a write that occurred within the same render pass.</span></span> <span data-ttu-id="c4296-178">某些阻礙不符合此條件約束，例如，從 **D3D12_RESOURCE_STATE_RENDER_TARGET** 到目前系結轉譯 (目標上 **\* _SHADER_RESOURCE** ，而且 debug 圖層會導致該效果) 發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="c4296-178">Certain barriers don't conform to this constraint, for example from **D3D12_RESOURCE_STATE_RENDER_TARGET** to **\*_SHADER_RESOURCE** on the currently-bound render target (and the debug layer will error to that effect).</span></span> <span data-ttu-id="c4296-179">但是，在目前轉譯階段 *以外* 撰寫之轉譯目標的相同屏障是一致的，因為寫入將會在目前的轉譯階段開始之前完成。</span><span class="sxs-lookup"><span data-stu-id="c4296-179">But, that same barrier on a render target that was written *outside* the current render pass is conformant, because the writes will complete ahead of the current render pass starting.</span></span>
<span data-ttu-id="c4296-180">您可能會受益于瞭解顯示驅動程式所能進行的特定優化。</span><span class="sxs-lookup"><span data-stu-id="c4296-180">You might benefit from knowing about certain optimizations that a display driver can make in this regard.</span></span> <span data-ttu-id="c4296-181">針對符合標準的工作負載，顯示器驅動程式可能會將轉譯行程中遇到的任何阻礙移至轉譯行程的開頭。</span><span class="sxs-lookup"><span data-stu-id="c4296-181">Given a conformant workload, a display driver might move any barriers encountered in your render pass to the beginning of the render pass.</span></span> <span data-ttu-id="c4296-182">在那裡，它們可以結合 (，而不會干擾) 的任何平平平/分類收納作業。</span><span class="sxs-lookup"><span data-stu-id="c4296-182">There, they can be coalesced (and not interfere with any tiling/binning operations).</span></span> <span data-ttu-id="c4296-183">這是有效的優化，前提是在目前的轉譯階段開始之前，所有寫入都已完成。</span><span class="sxs-lookup"><span data-stu-id="c4296-183">This is a valid optimization provided that all of your writes have finished before the current render pass starts.</span></span>

<span data-ttu-id="c4296-184">以下是更完整的驅動程式優化範例，假設您有一個轉譯引擎，其具有預先 Direct3D 12 樣式的資源系結設計，可根據 &mdash; 資源的系結方式來 *視需要* 進行阻礙。</span><span class="sxs-lookup"><span data-stu-id="c4296-184">Here's a more complete driver-optimization example, which assumes that you have a rendering engine that has a pre-Direct3D 12-style resource-binding design&mdash;doing barriers *on demand* based on how resources are bound.</span></span> <span data-ttu-id="c4296-185">當寫入未排序的存取權視圖時 (UAV) 接近框架的結尾 (要在下一個畫面格中使用) ，則引擎可能會在框架結束時將資源保持 **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** 狀態。</span><span class="sxs-lookup"><span data-stu-id="c4296-185">When writing into an unordered access view (UAV) toward the end of a frame (to be consumed in the following frame), the engine might happen to leave the resource in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state at the conclusion of the frame.</span></span> <span data-ttu-id="c4296-186">在接下來的框架中，當引擎要將資源系結為著色器資源查看 (SRV) 時，它會發現該資源不是正確的狀態，而且會發出從 **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** 到 **D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE** 的屏障。</span><span class="sxs-lookup"><span data-stu-id="c4296-186">In the frame that follows, when the engine goes to bind the resource as a shader resource view (SRV), it will find that the resource is not in the correct state, and it will issue a barrier from **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** to **D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE**.</span></span> <span data-ttu-id="c4296-187">如果該屏障發生在轉譯階段內，則顯示驅動程式會對齊，假設所有寫入都已在這個目前的轉譯階段 *之外* 發生，因此 (，且此處提供優化的位置) 顯示驅動程式可能會 *將關卡移* 至轉譯行程的開頭。</span><span class="sxs-lookup"><span data-stu-id="c4296-187">If that barrier occurs within the render pass, then the display driver is justified in assuming that all writes have already occurred *outside* of this current render pass, and consequently (and here's where the optimization comes in) the display driver might *move* the barrier up to the start of the render pass.</span></span> <span data-ttu-id="c4296-188">同樣地，這是有效的，只要您的程式碼符合本節所述的寫入讀取條件約束和最後一個。</span><span class="sxs-lookup"><span data-stu-id="c4296-188">Again, this is valid, as long as your code is conforming to the write-read constraint described in this section and the last.</span></span>


<span data-ttu-id="c4296-189">這些是一致的阻礙範例。</span><span class="sxs-lookup"><span data-stu-id="c4296-189">These are examples of conformant barriers.</span></span>
- <span data-ttu-id="c4296-190">**D3D12_RESOURCE_STATE_UNORDERED_ACCESS** **D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT**。</span><span class="sxs-lookup"><span data-stu-id="c4296-190">**D3D12_RESOURCE_STATE_UNORDERED_ACCESS** to **D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT**.</span></span>
- <span data-ttu-id="c4296-191">**D3D12_RESOURCE_STATE_COPY_DEST** **\* _SHADER_RESOURCE**。</span><span class="sxs-lookup"><span data-stu-id="c4296-191">**D3D12_RESOURCE_STATE_COPY_DEST** to **\*_SHADER_RESOURCE**.</span></span>

<span data-ttu-id="c4296-192">這些都是不一致阻礙的範例。</span><span class="sxs-lookup"><span data-stu-id="c4296-192">And these are examples of non-conformant barriers.</span></span>

- <span data-ttu-id="c4296-193">**D3D12_RESOURCE_STATE_RENDER_TARGET** 目前系結 RTVs/dsv 上的任何讀取狀態。</span><span class="sxs-lookup"><span data-stu-id="c4296-193">**D3D12_RESOURCE_STATE_RENDER_TARGET** to any read state on currently-bound RTVs/DSVs.</span></span>
- <span data-ttu-id="c4296-194">**D3D12_RESOURCE_STATE_DEPTH_WRITE** 目前系結 RTVs/dsv 上的任何讀取狀態。</span><span class="sxs-lookup"><span data-stu-id="c4296-194">**D3D12_RESOURCE_STATE_DEPTH_WRITE** to any read state on currently-bound RTVs/DSVs.</span></span>
- <span data-ttu-id="c4296-195">任何別名屏障。</span><span class="sxs-lookup"><span data-stu-id="c4296-195">Any aliasing barrier.</span></span>
- <span data-ttu-id="c4296-196">未排序的存取權視圖 (UAV) 的阻礙。</span><span class="sxs-lookup"><span data-stu-id="c4296-196">Unordered access view (UAV) barriers.</span></span> 

### <a name="resource-access-declaration"></a><span data-ttu-id="c4296-197">資源存取宣告</span><span class="sxs-lookup"><span data-stu-id="c4296-197">Resource access declaration</span></span>

<span data-ttu-id="c4296-198">在 **BeginRenderPass** 階段，以及宣告在該階段中做為 RTVs 和/或 DSV 的所有資源，您也必須指定其開始和結束 *存取* 特性。</span><span class="sxs-lookup"><span data-stu-id="c4296-198">At **BeginRenderPass** time, as well as declaring all resources that are serving as RTVs and/or DSV within that pass, you must also specify their beginning and ending *access* characteristics.</span></span> <span data-ttu-id="c4296-199">如您在上述「宣告 [您的輸出](#declare-your-output-bindings) 系結」一節的程式碼範例中所見，您可以使用 [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) 和 [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) 結構來完成這項作業。</span><span class="sxs-lookup"><span data-stu-id="c4296-199">As you can see in the code example in the [Declare your output bindings](#declare-your-output-bindings) section above, you do this with the [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) and [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) structures.</span></span>

<span data-ttu-id="c4296-200">如需詳細資訊，請參閱 [**D3D12_RENDER_PASS_BEGINNING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_beginning_access) 和 [**D3D12_RENDER_PASS_ENDING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_ending_access) 結構，以及 [**D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_beginning_access_type) 和 [**D3D12_RENDER_PASS_ENDING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_ending_access_type) 列舉。</span><span class="sxs-lookup"><span data-stu-id="c4296-200">For more details, see the [**D3D12_RENDER_PASS_BEGINNING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_beginning_access) and [**D3D12_RENDER_PASS_ENDING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_ending_access) structures, and the [**D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_beginning_access_type) and [**D3D12_RENDER_PASS_ENDING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_ending_access_type) enumerations.</span></span>

### <a name="render-pass-flags"></a><span data-ttu-id="c4296-201">轉譯傳遞旗標</span><span class="sxs-lookup"><span data-stu-id="c4296-201">Render pass flags</span></span>

<span data-ttu-id="c4296-202">傳遞至 **BeginRenderPass** 的最後一個參數是轉譯傳遞旗標， (來自 [**D3D12_RENDER_PASS_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_flags) 列舉) 的值。</span><span class="sxs-lookup"><span data-stu-id="c4296-202">The last parameter passed to **BeginRenderPass** is a render pass flag (a value from the [**D3D12_RENDER_PASS_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_flags) enumeration).</span></span>

```cppwinrt
enum D3D12_RENDER_PASS_FLAGS
{
    D3D12_RENDER_PASS_FLAG_NONE = 0,
    D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES = 0x1,
    D3D12_RENDER_PASS_FLAG_SUSPENDING_PASS = 0x2,
    D3D12_RENDER_PASS_FLAG_RESUMING_PASS = 0x4
};
```

#### <a name="uav-writes-within-a-render-pass"></a><span data-ttu-id="c4296-203">在轉譯階段內 UAV 寫入</span><span class="sxs-lookup"><span data-stu-id="c4296-203">UAV writes within a render pass</span></span>

<span data-ttu-id="c4296-204">在轉譯行程中允許未排序的存取權 (UAV) 寫入，但是您必須特別指出您將在轉譯行程中，藉由指定 **D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES** 來發出 UAV 寫入，如此一來，顯示驅動程式就可以視需要退出並排顯示。</span><span class="sxs-lookup"><span data-stu-id="c4296-204">Unordered access view (UAV) writes are permitted within a render pass, but you must specifically indicate that you'll be issuing UAV writes within the render pass by specifying **D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES**, so that the display driver can opt out of tiling if necessary.</span></span>

<span data-ttu-id="c4296-205">UAV 存取必須遵循以上所述的寫入讀取條件約束 (轉譯行程中的寫入，在後續轉譯行程) 之前無效。</span><span class="sxs-lookup"><span data-stu-id="c4296-205">UAV accesses must follow the write-read constraint described above (writes in a render pass are not valid to read until a subsequent render pass).</span></span> <span data-ttu-id="c4296-206">轉譯行程中不允許 UAV 障礙。</span><span class="sxs-lookup"><span data-stu-id="c4296-206">UAV barriers are not permitted within a render pass.</span></span>

<span data-ttu-id="c4296-207">透過根資料表或根) 描述元 (的 UAV 系結會繼承到轉譯行程中，並傳播到轉譯階段。</span><span class="sxs-lookup"><span data-stu-id="c4296-207">UAV bindings (via root tables or root descriptors) are inherited into render passes, and are propagated out of render passes.</span></span>

#### <a name="suspending-passes-and-resuming-passes"></a><span data-ttu-id="c4296-208">暫止和繼續傳遞</span><span class="sxs-lookup"><span data-stu-id="c4296-208">Suspending-passes, and resuming-passes</span></span>

<span data-ttu-id="c4296-209">您可以將整個轉譯階段表示為暫停傳遞和/或繼續進行。</span><span class="sxs-lookup"><span data-stu-id="c4296-209">You can indicate an entire render pass as being a suspending-pass and/or a resuming-pass.</span></span> <span data-ttu-id="c4296-210">暫止的繼續配對必須在行程之間擁有相同的視圖/存取旗標，而且可能不會有任何中間的 GPU 作業 (例如，繪製、分派、捨棄、清除、複製、更新磚-對應、寫入緩衝區 immediates、查詢、查詢在暫停轉譯傳遞與繼續轉譯行程之間的) 。</span><span class="sxs-lookup"><span data-stu-id="c4296-210">A suspending-followed-by-a-resuming pair must have identical views/access flags between the passes, and may not have any intervening GPU operations (for example, draws, dispatches, discards, clears, copies, update-tile-mappings, write-buffer-immediates, queries, query resolves) between the suspending render pass and the resuming render pass.</span></span>

<span data-ttu-id="c4296-211">預期的使用案例是多執行緒轉譯，其中假設有四個命令清單 (每個都有自己的轉譯行程) 可將目標設為相同的呈現目標。</span><span class="sxs-lookup"><span data-stu-id="c4296-211">The intended use case is multi-threaded rendering, where say four command lists (each with their own render passes) can target the same render targets.</span></span> <span data-ttu-id="c4296-212">當轉譯階段跨命令清單暫停/繼續時，命令清單必須在 [**ID3D12CommandQueue：： ExecuteCommandLists**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists)的相同呼叫中執行。</span><span class="sxs-lookup"><span data-stu-id="c4296-212">When render passes are suspended/resumed across command lists, the command lists must be executed in the same call to [**ID3D12CommandQueue::ExecuteCommandLists**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists).</span></span>

<span data-ttu-id="c4296-213">轉譯階段可以是繼續和暫停。</span><span class="sxs-lookup"><span data-stu-id="c4296-213">A render pass can be both resuming and suspending.</span></span> <span data-ttu-id="c4296-214">在剛剛指定的多執行緒範例中，命令清單2和3會分別從1和2繼續。</span><span class="sxs-lookup"><span data-stu-id="c4296-214">In the multi-threaded example just given, command lists 2 and 3 would be resuming from 1 and 2, respectively.</span></span> <span data-ttu-id="c4296-215">而且，相同的時間2和3會分別暫停至3和4。</span><span class="sxs-lookup"><span data-stu-id="c4296-215">And at the same time 2 and 3 would be suspending to 3 and 4, respectively.</span></span>

## <a name="query-for-render-passes-feature-support"></a><span data-ttu-id="c4296-216">查詢轉譯傳遞功能支援</span><span class="sxs-lookup"><span data-stu-id="c4296-216">Query for render passes feature support</span></span>

<span data-ttu-id="c4296-217">您可以呼叫 [**ID3D12Device：： CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) 來查詢設備磁碟機和/或硬體有效率地支援轉譯行程的範圍。</span><span class="sxs-lookup"><span data-stu-id="c4296-217">You can call [**ID3D12Device::CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) to query the extent to which a device driver and/or the hardware efficiently supports render passes.</span></span>

```cppwinrt
D3D12_RENDER_PASS_TIER get_render_passes_tier(::ID3D12Device * pIDevice)
{
    D3D12_FEATURE_DATA_D3D12_OPTIONS5 featureSupport{};
    winrt::check_hresult(
        pIDevice->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS5, &featureSupport, sizeof(featureSupport))
    );
    return featureSupport.RenderPassesTier;
}
...
    D3D12_RENDER_PASS_TIER renderPassesTier{ get_render_passes_tier(pIDevice) };
```

<span data-ttu-id="c4296-218">由於執行時間的對應邏輯，轉譯傳遞一律會運作。</span><span class="sxs-lookup"><span data-stu-id="c4296-218">Because of the runtime's mapping logic, render passes always function.</span></span> <span data-ttu-id="c4296-219">但是，根據功能支援，他們不一定會提供好處。</span><span class="sxs-lookup"><span data-stu-id="c4296-219">But, depending on feature support, they won't always provide a benefit.</span></span> <span data-ttu-id="c4296-220">您可以使用類似上述程式碼範例的程式碼，來判斷是否需要您的時間來將命令發出為轉譯行程，以及當它絕對不是優點時 (也就是，當執行時間只對應至現有的 API 介面) 時。</span><span class="sxs-lookup"><span data-stu-id="c4296-220">You can use code similar to the code example above to determine whether/when it is worth your while to issue commands as render passes, and when it is definitely not a benefit (that is, when the runtime is just mapping to the existing API surface).</span></span> <span data-ttu-id="c4296-221">如果您使用的是 [D3D11On12](/windows/desktop/direct3d12/direct3d-11-on-12)) ，執行這項檢查就特別重要。</span><span class="sxs-lookup"><span data-stu-id="c4296-221">Performing this check is particularly important if you're using [D3D11On12](/windows/desktop/direct3d12/direct3d-11-on-12)).</span></span>

<span data-ttu-id="c4296-222">如需三個支援層級的說明，請參閱 [**D3D12_RENDER_PASS_TIER**](/windows/win32/api/d3d12/ne-d3d12-d3d12_render_pass_tier) 列舉。</span><span class="sxs-lookup"><span data-stu-id="c4296-222">For a description of the three tiers of support, see the [**D3D12_RENDER_PASS_TIER**](/windows/win32/api/d3d12/ne-d3d12-d3d12_render_pass_tier) enumeration.</span></span>
