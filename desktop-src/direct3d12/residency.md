---
title: 居住
description: 當 GPU 可存取物件時，會將物件視為駐留。
ms.assetid: 956F80D7-EEC8-4D88-B251-EE325614F31E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6b842ce5b3e89c3877f50036e747a90f14104bce
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548426"
---
# <a name="residency"></a><span data-ttu-id="4f2bf-103">居住</span><span class="sxs-lookup"><span data-stu-id="4f2bf-103">Residency</span></span>

<span data-ttu-id="4f2bf-104">當 GPU 可存取物件時，會將物件視為 *駐留* 。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-104">An object is considered to be *resident* when it is accessible by the GPU.</span></span>

-   [<span data-ttu-id="4f2bf-105">常駐預算</span><span class="sxs-lookup"><span data-stu-id="4f2bf-105">Residency budget</span></span>](#residency-budget)
-   [<span data-ttu-id="4f2bf-106">堆積資源</span><span class="sxs-lookup"><span data-stu-id="4f2bf-106">Heap resources</span></span>](#heap-resources)
-   [<span data-ttu-id="4f2bf-107">常駐優先順序</span><span class="sxs-lookup"><span data-stu-id="4f2bf-107">Residency priorities</span></span>](#residency-priorities)
    -   [<span data-ttu-id="4f2bf-108">預設優先權演算法</span><span class="sxs-lookup"><span data-stu-id="4f2bf-108">Default priority algorithm</span></span>](#default-priority-algorithm)
-   [<span data-ttu-id="4f2bf-109">設計常駐管理</span><span class="sxs-lookup"><span data-stu-id="4f2bf-109">Programming residency management</span></span>](#programming-residency-management)
-   [<span data-ttu-id="4f2bf-110">相關主題</span><span class="sxs-lookup"><span data-stu-id="4f2bf-110">Related topics</span></span>](#related-topics)

## <a name="residency-budget"></a><span data-ttu-id="4f2bf-111">常駐預算</span><span class="sxs-lookup"><span data-stu-id="4f2bf-111">Residency budget</span></span>

<span data-ttu-id="4f2bf-112">Gpu 尚不支援分頁錯誤，因此應用程式必須在 GPU 可以存取的情況下，將資料認可到實體記憶體。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-112">GPUs do not yet support page-faulting, so applications must commit data into physical memory while the GPU could access it.</span></span> <span data-ttu-id="4f2bf-113">此程式稱為「進行某些作業」，且必須針對實體系統記憶體和物理離散視訊記憶體進行。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-113">This process is known as “making something resident”, and must be done for both physical system memory and physical discrete video memory.</span></span> <span data-ttu-id="4f2bf-114">在 D3D12 中，大部分的 API 物件都會封裝一些 GPU 可存取的記憶體。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-114">In D3D12, most API objects encapsulate some amount of GPU-accessible memory.</span></span> <span data-ttu-id="4f2bf-115">在 api 物件的建立期間，會將 GPU 可存取的記憶體設為常駐，並在 API 物件終結時收回。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-115">That GPU-accessible memory is made resident during the creation of the API object, and evicted on API object destruction.</span></span>

<span data-ttu-id="4f2bf-116">此進程可用的實體記憶體數量稱為「影片記憶體預算」。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-116">The amount of physical memory available for the process is known as the video memory budget.</span></span> <span data-ttu-id="4f2bf-117">在背景進程喚醒和睡眠的情況下，預算可能會明顯波動;當使用者切換到另一個應用程式時，就會大幅波動。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-117">The budget can fluctuate noticeably as background processes wake-up and sleep; and fluctuate dramatically when the user switches away to another application.</span></span> <span data-ttu-id="4f2bf-118">當預算變更時，應用程式可以收到通知，而且會輪詢目前的預算和目前耗用的記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-118">The application can be notified when the budget changes and poll both the current budget and the currently consumed amount of memory.</span></span> <span data-ttu-id="4f2bf-119">如果應用程式不在其預算內，則會間歇性凍結程式以允許其他應用程式執行，並/或建立 Api 將會傳回失敗。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-119">If an application doesn’t stay within its budget, the process will be intermittently frozen to allow other applications to run and/or the creation APIs will return failure.</span></span> <span data-ttu-id="4f2bf-120">[**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3)介面提供與這項功能有關的方法，特別是 [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo)和 [**RegisterVideoMemoryBudgetChangeNotificationEvent**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent)。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-120">The [**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3) interface provides the methods pertaining to this functionality, in particular [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo) and [**RegisterVideoMemoryBudgetChangeNotificationEvent**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent).</span></span>

<span data-ttu-id="4f2bf-121">建議應用程式使用保留來代表它們無法移出的記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-121">Applications are encouraged to use a reservation to denote the amount of memory they cannot go without.</span></span> <span data-ttu-id="4f2bf-122">在理想情況下，使用者指定的「低」圖形設定或更低的值，是這類保留的正確值。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-122">Ideally, the user-specified “low” graphics settings, or something even lower, is the right value for such a reservation.</span></span> <span data-ttu-id="4f2bf-123">設定保留將不會讓應用程式的預算高於通常會收到的預算。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-123">Setting a reservation won’t ever give an application a higher budget than it would normally receive.</span></span> <span data-ttu-id="4f2bf-124">相反地，保留資訊可協助作業系統核心快速將大型記憶體壓力情況的影響降到最低。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-124">Instead, the reservation information helps the OS kernel quickly minimize the impact of large memory pressure situations.</span></span> <span data-ttu-id="4f2bf-125">即使應用程式不是前景應用程式，仍無法保證應用程式使用保留。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-125">Even the reservation is not guaranteed to be available to the application when the application isn’t the foreground application.</span></span>

## <a name="heap-resources"></a><span data-ttu-id="4f2bf-126">堆積資源</span><span class="sxs-lookup"><span data-stu-id="4f2bf-126">Heap resources</span></span>

<span data-ttu-id="4f2bf-127">雖然許多 API 物件會封裝一些 GPU 可存取的記憶體，但堆積 & 資源預期是應用程式取用和管理實體記憶體的最有效方式。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-127">While many API objects encapsulate some GPU-accessible memory, heaps & resources are expected to be the most significant way applications consume and manage physical memory.</span></span> <span data-ttu-id="4f2bf-128">堆積是管理實體記憶體的最低層級單位，因此最好先熟悉它們的常駐屬性。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-128">A heap is the lowest level unit to manage physical memory, so it’s good to have some familiarity with their residency properties.</span></span>

-   <span data-ttu-id="4f2bf-129">堆積無法進行部分常駐，但保留的資源有因應措施。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-129">Heaps cannot be made partially resident, but workarounds exists with reserved resources.</span></span>
-   <span data-ttu-id="4f2bf-130">堆積應預算為特定集區的一部分。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-130">Heaps should be budgeted as part of a particular pool.</span></span> <span data-ttu-id="4f2bf-131">UMA 介面卡有一個集區，而離散介面卡有兩個集區。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-131">UMA adapters have one pool, while discrete adapters have two pools.</span></span> <span data-ttu-id="4f2bf-132">雖然核心可以將離散配接器上的一些堆積從影片記憶體移至系統記憶體，但它只是最大的最後手段。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-132">While it is true that kernel can shift some heaps on discrete adapters from video memory to system memory, it does so only as an extreme last resort.</span></span> <span data-ttu-id="4f2bf-133">應用程式不應該依賴核心的過度預算行為，而應專注于良好的預算管理。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-133">Applications should not rely on the over-budget behavior of the kernel, and should focus on good budget management instead.</span></span>
-   <span data-ttu-id="4f2bf-134">您可以從常駐中收回堆積，讓其內容可以分頁至磁片。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-134">Heaps can be evicted from residency, which allows their content to be paged out to disk.</span></span> <span data-ttu-id="4f2bf-135">但是，在所有介面卡架構上釋出落地是更可靠的方法。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-135">But, destruction of heaps is a more reliable technique to free up residency across all adapter architectures.</span></span> <span data-ttu-id="4f2bf-136">在 [**D3D12 \_ 功能 \_ 資料 \_ GPU \_ 虛擬 \_ 位址 \_ 支援**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support)的 *theMaxGPUVirtualAddressBitsPerProcess* 欄位接近預算大小的介面卡上，[**收回**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict)將無法可靠地回收常駐。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-136">On adapters where *theMaxGPUVirtualAddressBitsPerProcess* field of [**D3D12\_FEATURE\_DATA\_GPU\_VIRTUAL\_ADDRESS\_SUPPORT**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support) is near the budget size, [**Evict**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict) won’t reliably reclaim residency.</span></span>
-   <span data-ttu-id="4f2bf-137">堆積建立可能很慢;但它已針對背景執行緒優化。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-137">Heap creation can be slow; but it is optimized for background thread processing.</span></span> <span data-ttu-id="4f2bf-138">建議您在背景執行緒上建立堆積，以避免瑕疵轉譯執行緒。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-138">It’s recommended to create heaps on background threads to avoid glitching the render thread.</span></span> <span data-ttu-id="4f2bf-139">在 D3D12 中，多個執行緒可以安全地同時呼叫 create 常式。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-139">In D3D12, multiple threads may safely call create routines concurrently.</span></span>

<span data-ttu-id="4f2bf-140">D3D12 為其資源模型帶來更多的彈性和 orthogonality，以便為應用程式啟用更多選項。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-140">D3D12 introduces more flexibility and orthogonality into its resource model in order to enable more options for applications.</span></span> <span data-ttu-id="4f2bf-141">D3D12 中有三種高層級的資源類型：已認可、已放置和已保留。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-141">There are three high-level types of resources in D3D12: committed, placed, and reserved.</span></span>

-   <span data-ttu-id="4f2bf-142">認可的資源會同時建立資源和堆積。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-142">Committed resources create both a resource and a heap at the same time.</span></span> <span data-ttu-id="4f2bf-143">堆積是隱含的，無法直接存取。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-143">The heap is implicit and cannot be accessed directly.</span></span> <span data-ttu-id="4f2bf-144">堆積會適當地調整大小，以找出堆積內的整個資源。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-144">The heap is appropriately sized to locate the entire resource within the heap.</span></span>
-   <span data-ttu-id="4f2bf-145">放置的資源允許在堆積內的非零位移放置資源。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-145">Placed resources allow the placement of a resource at a non-zero offset within a heap.</span></span> <span data-ttu-id="4f2bf-146">位移通常必須對齊 64KB;但是，這兩個方向都有一些例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-146">Offsets must typically be aligned to 64KB; but some exceptions exist in both directions.</span></span> <span data-ttu-id="4f2bf-147">MSAA 資源需要4MB 位移對齊，而小材質可以使用 4 KB 位移對齊。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-147">MSAA resources require 4MB offset alignment, and 4KB offset alignment is available for small textures.</span></span> <span data-ttu-id="4f2bf-148">放置的資源無法直接重新放置或重新對應到另一個堆積;但它們可讓您在堆積之間進行資源資料的簡單重做。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-148">Placed resources cannot be relocated or remapped to another heap directly; but they enable simple relocation of the resource data between heaps.</span></span> <span data-ttu-id="4f2bf-149">在不同堆積中建立新的放置資源並複製資源資料之後，新的資源描述元將必須用於新的資源資料位置。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-149">After creating a new placed resource in a different heap and copying the resource data, new resource descriptors will have to be used for the new resource data location.</span></span>
-   <span data-ttu-id="4f2bf-150">只有在介面卡支援並排顯示的資源層級1或更大時，才可使用保留的資源。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-150">Reserved resources are only available when the adapter supports tiled resources tier 1 or greater.</span></span> <span data-ttu-id="4f2bf-151">如果有的話，則提供最先進的常駐管理技術;但並非所有的介面卡目前都支援它們。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-151">When available, they offer the most advanced residency management techniques available; but not all adapters currently support them.</span></span> <span data-ttu-id="4f2bf-152">它們可讓您重新對應資源，而不需要重新產生資源描述項、部分 mip 層級常駐和稀疏材質案例等等。即使保留的資源可供使用，但並非所有資源類型都受到支援，因此，完全以頁面為基礎的開放管理員尚不可行。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-152">They enable remapping a resource without requiring regeneration of resource descriptors, partial mip level residency, and sparse texture scenarios, etc. Not all resources types are supported even when reserved resources are available, so a fully general page-based residency manager isn’t yet feasible.</span></span>

## <a name="residency-priorities"></a><span data-ttu-id="4f2bf-153">常駐優先順序</span><span class="sxs-lookup"><span data-stu-id="4f2bf-153">Residency priorities</span></span>

<span data-ttu-id="4f2bf-154">Windows 10 建立者更新可讓開發人員在記憶體壓力需要降級某些資源時，影響哪些堆積和資源要保持常駐。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-154">The Windows 10 Creators Update enables developers to influence which heaps and resources will be prefered to stay resident when memory pressure requires that some of its resources be demoted.</span></span> <span data-ttu-id="4f2bf-155">這可協助開發人員藉由充分利用執行時間無法從 API 使用方式推斷的知識，來建立更好的應用程式。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-155">This helps developers create better performing applications by leveraging knowlege that the runtime can't infer from API usage.</span></span> <span data-ttu-id="4f2bf-156">開發人員預期當開發人員從使用認可的資源轉換為 resereved 和並排顯示的資源時，將會更熟悉且能夠指定優先順序。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-156">Its expected that developers will become more comfortable and capable specifying priorities as they transition from using commited resources to resereved and tiled resources.</span></span>

<span data-ttu-id="4f2bf-157">套用這些優先順序必須比 manageing 兩個動態記憶體預算更容易，因為應用程式已經可以這麼做，所以請手動降級並提升資源 bettween。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-157">Applying these priorities must be easier than manageing two dynamic memory budgets, manually demoting and promoting resources bettween them, since applications can already do that.</span></span> <span data-ttu-id="4f2bf-158">因此，「主機優先順序 API」的設計會以 coursely 的方式，將合理的預設優先順序指派給每個堆積或建立的資源。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-158">Therefore, the design of the residency priority API is coursely-grained with reasonable default priorities assigned to each heap or resource as its created.</span></span> <span data-ttu-id="4f2bf-159">如需詳細資訊，請參閱 [**ID3D12Device1：： SetResidencyPriority**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) 和 [**D3D12 \_ 常駐 \_ 優先權**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) 列舉。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-159">For more information, see [**ID3D12Device1::SetResidencyPriority**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) and the [**D3D12\_RESIDENCY\_PRIORITY**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) enumeration.</span></span>

<span data-ttu-id="4f2bf-160">有了優先權，開發人員預期會有下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="4f2bf-160">With priorities, developers are expected to either:</span></span>

-   <span data-ttu-id="4f2bf-161">提高一些例外堆積的優先順序，以便更快地降級這些堆積比其自然存取模式需要更快或更頻繁的效能影響。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-161">Raise the priority of a few exceptional heaps to better mitigate the experienced performance impact of these heaps being demoted sooner or more frequently than their natural access patterns would demand.</span></span> <span data-ttu-id="4f2bf-162">從像是 Direct3D 11 或 OpenGL 等圖形 Api 所移植的應用程式，其資源管理模型與 Direct3D 12 的資源管理模型截然不同。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-162">This approach is expected to be leveraged by applications ported from graphics APIs such as Direct3D 11 or OpenGL, who's resource management model is significantly different than that of Direct3D 12.</span></span>
-   <span data-ttu-id="4f2bf-163">使用應用程式本身的 bucketization 配置來覆寫幾乎所有的堆積優先順序（根據程式設計人員對於存取頻率或動態的知識而定）：固定配置比動態配置更容易管理，但可能較不有效率，而且需要程式設計人員操作，因為在開發過程中會改變使用模式。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-163">Override nearly all heap priorities with the application's own bucketization scheme, either fixed, based on the programmer's knowlege of access frequency, or dynamic; a fixed scheme is simpler to manage than a dynamic one, but can be less effective and require programmer intevention as use patterns change over the course of development.</span></span> <span data-ttu-id="4f2bf-164">使用 Direct3D 12 樣式的資源管理所建立的應用程式（例如使用落地程式庫的應用程式）會使用這種方法， (特別是) 的動態配置。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-164">This approach is expected to be leveraged by applications that are built with Direct3D 12-style resource management in mind, such as those that use the residency library (especially dynamic schemes).</span></span>

### <a name="default-priority-algorithm"></a><span data-ttu-id="4f2bf-165">預設優先權演算法</span><span class="sxs-lookup"><span data-stu-id="4f2bf-165">Default priority algorithm</span></span>

<span data-ttu-id="4f2bf-166">應用程式無法在不先 understaning 預設優先權演算法的情況下，為任何嘗試管理的堆積指定有用的優先順序。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-166">An application can't specify useful priorities for any heap it attempts to manage without first understaning the default priority algorithm.</span></span> <span data-ttu-id="4f2bf-167">這是因為將特定優先權指派給堆積的值，是從競爭相同記憶體的其他優先順序堆積衍生而來的。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-167">This is because the value of assigning a particular priority to a heap is derived from its relative priority to other prioritized heaps that compete for the same memory.</span></span>

<span data-ttu-id="4f2bf-168">為產生預設優先順序所選擇的策略是將堆積分類成兩個值區，favoring (給予較高優先順序的) 堆積，而這些堆積會假設 GPU 不是經常寫入。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-168">The strategy chosen for generating default priorities is to categorize heaps into two buckets, favoring (giving higher priority to) heaps that are assumed to be written frequently by the GPU over heaps that aren't.</span></span>

<span data-ttu-id="4f2bf-169">高優先順序的值區包含以旗標建立的堆積和資源，這些旗標會將它們識別為轉譯目標、深度樣板緩衝區或未排序的存取視圖 (UAVs) 。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-169">The high-priority bucket contains heaps and resources that are created with flags that identify them as render targets, depth-stencil buffers, or Unordered Access Views (UAVs).</span></span> <span data-ttu-id="4f2bf-170">這些是從 **D3D12 落地 \_ \_ 優先權 \_ 高** 的範圍中指派的優先順序值; 若要進一步設定這些堆積和資源的優先順序，則優先順序的最低16位會設定為堆積或資源的大小，除以 10mb (飽和，相當大型堆積) 。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-170">These are assigned priority values in the range starting at **D3D12\_RESIDENCY\_PRIORITY\_HIGH**; to further prioritize among these heaps and resources, the lowest 16-bits of the priority are set to the size of the heap or resource divided by 10MB (saturating to 0xFFFF for extremely large heaps).</span></span> <span data-ttu-id="4f2bf-171">這種額外的優先順序偏好較大型的堆積和資源。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-171">This additional prioritization favors larger heaps and resources.</span></span>

<span data-ttu-id="4f2bf-172">低優先順序值區包含所有其他堆積和資源，這些堆積和資源都會被指派優先順序值為 [D3D12] 的 [ **\_ \_ \_ 一般**]。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-172">The low-priority bucket contains all other heaps and resources, which are assigned a priority value of **D3D12\_RESIDENCY\_PRIORITY\_NORMAL**.</span></span> <span data-ttu-id="4f2bf-173">在這些堆積與資源之間，不會有進一步的優先順序。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-173">No further prioritization among these heaps and resources is attempted.</span></span>

## <a name="programming-residency-management"></a><span data-ttu-id="4f2bf-174">設計常駐管理</span><span class="sxs-lookup"><span data-stu-id="4f2bf-174">Programming residency management</span></span>

<span data-ttu-id="4f2bf-175">簡單的應用程式可能只需要建立認可的資源，直到遇到記憶體不足的失敗為止。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-175">Simple applications may be able to get by merely creating committed resources until experiencing out-of-memory failures.</span></span> <span data-ttu-id="4f2bf-176">失敗時，應用程式可能會損毀其他已認可的資源或 API 物件，以使資源建立成功。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-176">Upon failure, the application can destroy other committed resources or API objects to enable further resource creations to succeed.</span></span> <span data-ttu-id="4f2bf-177">但是，即使是簡單的應用程式，也強烈建議監看是否有負面的預算變更，以及在框架中大約一次終結未使用的 API 物件。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-177">But, even simple applications are strongly recommended to watch for negative budget changes and destroy unused API objects roughly once a frame.</span></span>

<span data-ttu-id="4f2bf-178">當您嘗試將介面卡架構優化或納入落地優先順序時，仍會有常駐管理設計的複雜度。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-178">The complexity of a residency management design will go up when trying to optimize for adapter architectures or incorporating residency priorities.</span></span> <span data-ttu-id="4f2bf-179">分開預算和管理兩個離散記憶體集區會比只管理一個集區更複雜，而且在大規模指派固定優先順序可能會在使用模式演進時成為維護的負擔。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-179">Discretely budgeting and managing two pools of discrete memory will be more complex than managing only one, and assigning fixed priorities on a wide scale can become a maintainance burden if use patterns evolve.</span></span> <span data-ttu-id="4f2bf-180">將材質溢出至系統記憶體會增加複雜度，因為系統記憶體中錯誤的資源可能會嚴重影響畫面播放速率。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-180">Overflowing textures into system memory adds more complexity, as the wrong resource in system-memory can severely impact frame rate.</span></span> <span data-ttu-id="4f2bf-181">而且，沒有任何簡單的功能可協助您找出可受益于較高 GPU 頻寬或容許較低 GPU 頻寬的資源。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-181">And, there is no simple functionality to help identify the resources that would either benefit from higher GPU bandwidth or tolerate lower GPU bandwidth.</span></span>

<span data-ttu-id="4f2bf-182">更複雜的設計也會查詢目前介面卡的功能。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-182">Even more complicated designs will query for the features of the current adapter.</span></span> <span data-ttu-id="4f2bf-183">這項資訊適用于 [**D3D12 \_ 功能 \_ 資料 \_ GPU \_ 虛擬 \_ 位址 \_ 支援**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support)、 [**D3D12 \_ 功能 \_ 資料 \_ 結構**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture)、 [**D3D12 \_ 並排 \_ 資源 \_ 層**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier)和 [**D3D12 \_ 資源 \_ 堆積 \_ 層**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier)。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-183">This information is available in [**D3D12\_FEATURE\_DATA\_GPU\_VIRTUAL\_ADDRESS\_SUPPORT**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support), [**D3D12\_FEATURE\_DATA\_ARCHITECTURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture), [**D3D12\_TILED\_RESOURCES\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier), and [**D3D12\_RESOURCE\_HEAP\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier).</span></span>

<span data-ttu-id="4f2bf-184">應用程式的多個部分可能會使用不同的技術。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-184">Multiple parts of an application will likely wind up using different techniques.</span></span> <span data-ttu-id="4f2bf-185">例如，某些大型紋理和很少使用的程式碼路徑可能會使用認可的資源，而許多材質可以使用串流屬性來指定，並使用一般的放置資源技術。</span><span class="sxs-lookup"><span data-stu-id="4f2bf-185">For example, some large textures and rarely exercised code paths may use committed resources, while many textures may be designated with a streaming property and use a general placed-resource technique.</span></span>

## <a name="related-topics"></a><span data-ttu-id="4f2bf-186">相關主題</span><span class="sxs-lookup"><span data-stu-id="4f2bf-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="4f2bf-187">**ID3D12Heap**</span><span class="sxs-lookup"><span data-stu-id="4f2bf-187">**ID3D12Heap**</span></span>](/windows/desktop/api/d3d12/nn-d3d12-id3d12heap)
</dt> <dt>

[<span data-ttu-id="4f2bf-188">記憶體管理</span><span class="sxs-lookup"><span data-stu-id="4f2bf-188">Memory Management</span></span>](memory-management.md)
</dt> </dl>

 

 