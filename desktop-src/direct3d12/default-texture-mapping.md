---
title: UMA 優化 CPU 可存取的材質和標準 Swizzle
description: 通用記憶體架構 (UMA) Gpu 可提供比離散 Gpu 更高的效率，尤其是在針對行動裝置進行優化的情況下。
ms.assetid: 26C41948-9625-4786-BBDF-552D1F8A2437
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 47725702676d385d607fa87533680b9ffe0fc0df
ms.sourcegitcommit: 294c5ab750c46b5100bb2c84ef6c33ef7266c54b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/15/2020
ms.locfileid: "104548417"
---
# <a name="uma-optimizations-cpu-accessible-textures-and-standard-swizzle"></a><span data-ttu-id="1aead-103">UMA 優化：可存取 CPU 的材質和標準 Swizzle</span><span class="sxs-lookup"><span data-stu-id="1aead-103">UMA Optimizations: CPU Accessible Textures and Standard Swizzle</span></span>

<span data-ttu-id="1aead-104">通用記憶體架構 (UMA) Gpu 可提供比離散 Gpu 更高的效率，尤其是在針對行動裝置進行優化的情況下。</span><span class="sxs-lookup"><span data-stu-id="1aead-104">Universal Memory Architecture (UMA) GPUs offer some efficiency advantages over discrete GPUs, especially when optimizing for mobile devices.</span></span> <span data-ttu-id="1aead-105">當 GPU 為 UMA 時提供資源 CPU 存取權，可減少在 CPU 與 GPU 之間發生的複製量。</span><span class="sxs-lookup"><span data-stu-id="1aead-105">Giving resources CPU access when the GPU is UMA can reduce the amount of copying that occurs between CPU and GPU.</span></span> <span data-ttu-id="1aead-106">雖然我們不建議應用程式盲目將 CPU 存取權提供給 UMA 設計上的所有資源，但有機會藉由提供正確的資源 CPU 存取來提高效率。</span><span class="sxs-lookup"><span data-stu-id="1aead-106">While we don’t recommend applications blindly give CPU access to all resources on UMA designs, there are opportunities to improve efficiencies by giving the right resources CPU access.</span></span> <span data-ttu-id="1aead-107">與離散 Gpu 不同的是，CPU 可以有 GPU 可存取的所有資源指標。</span><span class="sxs-lookup"><span data-stu-id="1aead-107">Unlike discrete GPUs, the CPU can technically have a pointer to all resources that the GPU can access.</span></span>

-   [<span data-ttu-id="1aead-108">瞭解可存取 CPU 的材質</span><span class="sxs-lookup"><span data-stu-id="1aead-108">Overview of CPU accessible textures</span></span>](#overview-of-cpu-accessible-textures)
-   [<span data-ttu-id="1aead-109">標準 Swizzle 總覽</span><span class="sxs-lookup"><span data-stu-id="1aead-109">Overview of Standard Swizzle</span></span>](#overview-of-standard-swizzle)
-   [<span data-ttu-id="1aead-110">API</span><span class="sxs-lookup"><span data-stu-id="1aead-110">APIs</span></span>](#apis)
-   [<span data-ttu-id="1aead-111">相關主題</span><span class="sxs-lookup"><span data-stu-id="1aead-111">Related topics</span></span>](#related-topics)

## <a name="overview-of-cpu-accessible-textures"></a><span data-ttu-id="1aead-112">瞭解可存取 CPU 的材質</span><span class="sxs-lookup"><span data-stu-id="1aead-112">Overview of CPU accessible textures</span></span>

<span data-ttu-id="1aead-113">圖形管線中的 CPU 可存取材質是 UMA 架構的功能，可讓 Cpu 讀取和寫入紋理的存取權。</span><span class="sxs-lookup"><span data-stu-id="1aead-113">CPU accessible textures, in the graphics pipeline, are a feature of UMA architecture, enabling CPUs read and write access to textures.</span></span> <span data-ttu-id="1aead-114">在較常見的離散 Gpu 上，CPU 無法存取圖形管線中的材質。</span><span class="sxs-lookup"><span data-stu-id="1aead-114">On the more common discrete GPUs, the CPU does not have access to textures in the graphics pipeline.</span></span>

<span data-ttu-id="1aead-115">紋理的一般最佳作法建議是容納離散 Gpu，通常需要遵循 [透過緩衝區上傳材質資料](upload-and-readback-of-texture-data.md)的程式，摘要如下：</span><span class="sxs-lookup"><span data-stu-id="1aead-115">The general best practice advice for textures is to accommodate discrete GPUs, which typically involves following the processes in [Uploading Texture Data Through Buffers](upload-and-readback-of-texture-data.md), summarized as:</span></span>

-   <span data-ttu-id="1aead-116">大部分的材質都沒有 CPU 存取權。</span><span class="sxs-lookup"><span data-stu-id="1aead-116">Not having any CPU access for the majority of textures.</span></span>
-   <span data-ttu-id="1aead-117">設定紋理配置以 D3D12 \_ 材質配置 \_ \_ 未知。</span><span class="sxs-lookup"><span data-stu-id="1aead-117">Setting the texture layout to D3D12\_TEXTURE\_LAYOUT\_UNKNOWN.</span></span>
-   <span data-ttu-id="1aead-118">使用 [**CopyTextureRegion**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion)將材質上傳到 GPU。</span><span class="sxs-lookup"><span data-stu-id="1aead-118">Uploading the textures to the GPU with [**CopyTextureRegion**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion).</span></span>

<span data-ttu-id="1aead-119">不過，在某些情況下，CPU 和 GPU 可能會在相同的資料上頻繁地互動，而對應的材質會變得很有用，以節省電力，或加速特定介面卡或架構上的特定設計。</span><span class="sxs-lookup"><span data-stu-id="1aead-119">However, for certain cases, the CPU and GPU may interact so frequently on the same data, that mapping textures becomes helpful to save power, or to speed up a particular design on particular adapters or architectures.</span></span> <span data-ttu-id="1aead-120">應用程式應該會偵測到這些情況，並將不必要的複本優化。</span><span class="sxs-lookup"><span data-stu-id="1aead-120">Applications should detect these cases and optimize out the unnecessary copies.</span></span> <span data-ttu-id="1aead-121">在此情況下，為了獲得最佳效能，請考慮下列事項：</span><span class="sxs-lookup"><span data-stu-id="1aead-121">In this case, for best performance consider the following:</span></span>

-   <span data-ttu-id="1aead-122">當 [**D3D12 \_ 功能 \_ 資料 \_ 結構**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture)：： UMA 為 TRUE 時，只會啟動更好的地圖紋理效能。</span><span class="sxs-lookup"><span data-stu-id="1aead-122">Only start entertaining the better performance of mapping textures when [**D3D12\_FEATURE\_DATA\_ARCHITECTURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture)::UMA is TRUE.</span></span> <span data-ttu-id="1aead-123">如果決定要在堆積上選擇哪些 CPU 快取屬性，請注意 *CacheCoherentUMA* 。</span><span class="sxs-lookup"><span data-stu-id="1aead-123">Then pay attention to *CacheCoherentUMA* if deciding which CPU cache properties to choose on the heap.</span></span>

-   <span data-ttu-id="1aead-124">運用紋理的 CPU 存取比緩衝區更複雜。</span><span class="sxs-lookup"><span data-stu-id="1aead-124">Leveraging CPU access for textures is more complicated than for buffers.</span></span> <span data-ttu-id="1aead-125">最有效率的 Gpu 材質版面配置很少是資料列的 \_ 主要。</span><span class="sxs-lookup"><span data-stu-id="1aead-125">The most efficient texture layouts for GPUs are rarely row\_major.</span></span> <span data-ttu-id="1aead-126">事實上，某些 Gpu 在複製材質資料時，只能支援資料列 \_ 主要紋理。</span><span class="sxs-lookup"><span data-stu-id="1aead-126">In fact, some GPUs can only support row\_major textures when copying texture data around.</span></span>

-   <span data-ttu-id="1aead-127">UMA Gpu 應廣泛受益于簡單的優化，以減少層級載入時間。</span><span class="sxs-lookup"><span data-stu-id="1aead-127">UMA GPUs should universally benefit from a simple optimization to reduce level-load times.</span></span> <span data-ttu-id="1aead-128">辨識 UMA 之後，應用程式可以將初始 [**CopyTextureRegion**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion) 優化，以填入 GPU 不會修改的材質。</span><span class="sxs-lookup"><span data-stu-id="1aead-128">After recognizing UMA, the application can optimize out the initial [**CopyTextureRegion**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion) to populate textures that the GPU will not modify.</span></span> <span data-ttu-id="1aead-129">\_ \_ \_ 應用程式可以使用 [**WriteToSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-writetosubresource)來避免瞭解實際的材質配置，而不是使用 D3D12 堆積類型的預設值來建立堆積的材質，以及透過將材質資料封送處理。</span><span class="sxs-lookup"><span data-stu-id="1aead-129">Instead of creating the texture in a heap with D3D12\_HEAP\_TYPE\_DEFAULT, and marshalling the texture data through, the application can use [**WriteToSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-writetosubresource) to avoid understanding the actual texture layout.</span></span>

-   <span data-ttu-id="1aead-130">在 D3D12 中，使用 D3D12 材質配置來建立的材質 \_ \_ \_ 未知，而且沒有 CPU 存取最有效率的是經常進行 GPU 轉譯和取樣。</span><span class="sxs-lookup"><span data-stu-id="1aead-130">In D3D12, textures created with D3D12\_TEXTURE\_LAYOUT\_UNKNOWN and no CPU access are the most efficient for frequent GPU rendering and sampling.</span></span> <span data-ttu-id="1aead-131">當效能測試時，應該將這些紋理與 \_ cpu 存取的 D3D12 紋理配置 \_ \_ ，以及 \_ 具有 cpu 存取的 D3D12 材質配置 \_ \_ 標準 \_ SWIZZLE 和 D3D12 \_ 材質版面配置資料 \_ \_ 列主要進行比較， \_ 以取得跨介面卡支援。</span><span class="sxs-lookup"><span data-stu-id="1aead-131">When performance testing, those textures should be compared against D3D12\_TEXTURE\_LAYOUT\_UNKNOWN with CPU access, and D3D12\_TEXTURE\_LAYOUT\_STANDARD\_SWIZZLE with CPU access, and D3D12\_TEXTURE\_LAYOUT\_ROW\_MAJOR for cross-adapter support.</span></span>

-   <span data-ttu-id="1aead-132">使用 D3D12 \_ 材質 \_ 配置 \_ 與 CPU 存取的「未知」，可讓 [**WriteToSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-writetosubresource)、 [**ReadFromSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-readfromsubresource)、 [**Map**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map) (阻止應用程式存取指標 [](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-unmap)) 和取消對應，但可能會犧牲 GPU 存取的效率。</span><span class="sxs-lookup"><span data-stu-id="1aead-132">Using D3D12\_TEXTURE\_LAYOUT\_UNKNOWN with CPU access enables the methods [**WriteToSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-writetosubresource), [**ReadFromSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-readfromsubresource), [**Map**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map) (precluding application access to pointer), and [**Unmap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-unmap); but can sacrifice efficiency of GPU access.</span></span>

-   <span data-ttu-id="1aead-133">使用 D3D12 \_ 材質 \_ 配置 \_ 標準 \_ SWIZZLE 搭配 CPU 存取，可讓 [**WriteToSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-writetosubresource)、 [**ReadFromSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-readfromsubresource)、Map (傳回應用程式) 和取消 [**對應**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map)的 [](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-unmap)有效指標。</span><span class="sxs-lookup"><span data-stu-id="1aead-133">Using D3D12\_TEXTURE\_LAYOUT\_STANDARD\_SWIZZLE with CPU access enables [**WriteToSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-writetosubresource), [**ReadFromSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-readfromsubresource), [**Map**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map) (which returns a valid pointer to application), and [**Unmap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-unmap).</span></span> <span data-ttu-id="1aead-134">它也可以犧牲 GPU 存取的效率，而不是 \_ 透過 \_ CPU 存取的未知 D3D12 材質配置 \_ 。</span><span class="sxs-lookup"><span data-stu-id="1aead-134">It can also sacrifice the efficiency of GPU access more than D3D12\_TEXTURE\_LAYOUT\_UNKNOWN with CPU access.</span></span>

## <a name="overview-of-standard-swizzle"></a><span data-ttu-id="1aead-135">標準 Swizzle 總覽</span><span class="sxs-lookup"><span data-stu-id="1aead-135">Overview of Standard Swizzle</span></span>

<span data-ttu-id="1aead-136">D3D12 (和 D3D 11.3) 引進標準的多維度資料版面配置。</span><span class="sxs-lookup"><span data-stu-id="1aead-136">D3D12 (and D3D11.3) introduce a standard multi-dimensional data layout.</span></span> <span data-ttu-id="1aead-137">這樣做的目的是為了讓多個處理單位在相同的資料上運作，而不需要複製資料或在多個配置之間 swizzling 資料。</span><span class="sxs-lookup"><span data-stu-id="1aead-137">This is done to enable multiple processing units to operate on the same data without copying the data or swizzling the data between multiple layouts.</span></span> <span data-ttu-id="1aead-138">標準化配置可讓您透過網路效果提高效率，並允許演算法在採用特定模式時進行短暫的剪下。</span><span class="sxs-lookup"><span data-stu-id="1aead-138">A standardized layout enables efficiency gains through network effects and allows algorithms to make short-cuts assuming a particular pattern.</span></span>

<span data-ttu-id="1aead-139">如需材質配置的詳細說明，請參閱 [**D3D12 \_ 材質 \_ 版面**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_texture_layout)配置。</span><span class="sxs-lookup"><span data-stu-id="1aead-139">For a detailed description of the texture layouts, refer to [**D3D12\_TEXTURE\_LAYOUT**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_texture_layout).</span></span>

<span data-ttu-id="1aead-140">不過請注意，這個標準 swizzle 是硬體功能，而且可能不受所有 Gpu 支援。</span><span class="sxs-lookup"><span data-stu-id="1aead-140">Note though that this standard swizzle is a hardware feature, and may not be supported by all GPUs.</span></span>

<span data-ttu-id="1aead-141">如需 swizzling 的背景資訊，請參閱 [Z 順序曲線](https://en.wikipedia.org/wiki/Z-order_curve)。</span><span class="sxs-lookup"><span data-stu-id="1aead-141">For background information on swizzling, refer to [Z-order curve](https://en.wikipedia.org/wiki/Z-order_curve).</span></span>

## <a name="apis"></a><span data-ttu-id="1aead-142">API</span><span class="sxs-lookup"><span data-stu-id="1aead-142">APIs</span></span>

<span data-ttu-id="1aead-143">與 D3D 11.3 不同的是，D3D12 預設支援材質對應，因此不需要查詢 [**D3D12 \_ 功能 \_ 資料 \_ D3D12 \_ 選項**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options)。</span><span class="sxs-lookup"><span data-stu-id="1aead-143">Unlike D3D11.3, D3D12 supports texture mapping by default, so there is no need to query [**D3D12\_FEATURE\_DATA\_D3D12\_OPTIONS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options).</span></span> <span data-ttu-id="1aead-144">不過，D3D12 不一定會支援標準 swizzle-這項功能必須透過呼叫來進行查詢，以 [**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport)和檢查 **D3D12 \_ feature \_ DATA \_ D3D12 \_ 選項** 的 *StandardSwizzle64KBSupported* 欄位。</span><span class="sxs-lookup"><span data-stu-id="1aead-144">However D3D12 does not always support standard swizzle - this feature will need to be queried for with a call to [**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) and checking the *StandardSwizzle64KBSupported* field of **D3D12\_FEATURE\_DATA\_D3D12\_OPTIONS**.</span></span>

<span data-ttu-id="1aead-145">下列 Api 參考紋理對應：</span><span class="sxs-lookup"><span data-stu-id="1aead-145">The following APIs reference texture mapping:</span></span>

<span data-ttu-id="1aead-146">列舉</span><span class="sxs-lookup"><span data-stu-id="1aead-146">Enums</span></span>

-   <span data-ttu-id="1aead-147">[**D3D12 \_材質 \_**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_texture_layout) 配置：控制預設材質的 swizzle 模式，並啟用可存取 CPU 的材質的地圖支援。</span><span class="sxs-lookup"><span data-stu-id="1aead-147">[**D3D12\_TEXTURE\_LAYOUT**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_texture_layout) : controls the swizzle pattern of default textures and enable map support on CPU accessible textures.</span></span>

<span data-ttu-id="1aead-148">結構</span><span class="sxs-lookup"><span data-stu-id="1aead-148">Structures</span></span>

-   <span data-ttu-id="1aead-149">[**D3D12 \_資源 \_ DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_resource_desc) ：描述資源，例如紋理，這是廣泛使用的結構。</span><span class="sxs-lookup"><span data-stu-id="1aead-149">[**D3D12\_RESOURCE\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_resource_desc) : describes a resource, such as a texture, this is an extensively used structure.</span></span>
-   <span data-ttu-id="1aead-150">[**D3D12 \_堆積 \_ DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_heap_desc) ：描述堆積。</span><span class="sxs-lookup"><span data-stu-id="1aead-150">[**D3D12\_HEAP\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_heap_desc) : describes a heap.</span></span>

<span data-ttu-id="1aead-151">方法</span><span class="sxs-lookup"><span data-stu-id="1aead-151">Methods</span></span>

-   <span data-ttu-id="1aead-152">[**ID3D12Device：： CreateCommittedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createcommittedresource) ：建立單一資源，並支援正確大小和對齊方式的堆積。</span><span class="sxs-lookup"><span data-stu-id="1aead-152">[**ID3D12Device::CreateCommittedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createcommittedresource) : creates a single resource and backing heap of the right size and alignment.</span></span>
-   <span data-ttu-id="1aead-153">[**ID3D12Device：： CreateHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createheap) ：建立緩衝區或材質的堆積。</span><span class="sxs-lookup"><span data-stu-id="1aead-153">[**ID3D12Device::CreateHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createheap) : creates a heap for a buffer or texture.</span></span>
-   <span data-ttu-id="1aead-154">[**ID3D12Device：： CreatePlacedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createplacedresource) ：建立放置於特定堆積中的資源，通常比 [**CreateHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createheap)更快建立資源的方法。</span><span class="sxs-lookup"><span data-stu-id="1aead-154">[**ID3D12Device::CreatePlacedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createplacedresource) : creates a resource that is placed in a specific heap, usually a faster method of creating a resource than [**CreateHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createheap).</span></span>
-   <span data-ttu-id="1aead-155">[**ID3D12Device：： CreateReservedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createreservedresource) ：建立已保留但尚未認可或放在堆積中的資源。</span><span class="sxs-lookup"><span data-stu-id="1aead-155">[**ID3D12Device::CreateReservedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createreservedresource) : creates a resource that is reserved but not yet committed or placed in a heap.</span></span>
-   <span data-ttu-id="1aead-156">[**ID3D12CommandQueue：： UpdateTileMappings**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-updatetilemappings) ：將並排顯示的資源中的磚位置對應更新為資源堆積中的記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="1aead-156">[**ID3D12CommandQueue::UpdateTileMappings**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-updatetilemappings) : updates mappings of tile locations in tiled resources to memory locations in a resource heap.</span></span>
-   <span data-ttu-id="1aead-157">[**ID3D12Resource：： Map**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map) ：取得資源中指定資料的指標，並拒絕 SUBRESOURCE 的 GPU 存取。</span><span class="sxs-lookup"><span data-stu-id="1aead-157">[**ID3D12Resource::Map**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map) : gets a pointer to the specified data in the resource, and denies the GPU access to the subresource.</span></span>
-   <span data-ttu-id="1aead-158">[**ID3D12Resource：： GetDesc**](id3d12resource-getdesc.md) ：取得資源屬性。</span><span class="sxs-lookup"><span data-stu-id="1aead-158">[**ID3D12Resource::GetDesc**](id3d12resource-getdesc.md) : gets the resource properties.</span></span>
-   <span data-ttu-id="1aead-159">[**ID3D12Heap：： GetDesc**](id3d12heap-getdesc.md) 會取得堆積屬性。</span><span class="sxs-lookup"><span data-stu-id="1aead-159">[**ID3D12Heap::GetDesc**](id3d12heap-getdesc.md) gets the heap properties.</span></span>
-   <span data-ttu-id="1aead-160">[**ReadFromSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-readfromsubresource) ：從使用 [**Map**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map)所對應的材質複製資料。</span><span class="sxs-lookup"><span data-stu-id="1aead-160">[**ReadFromSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-readfromsubresource) : copies data from a texture which was mapped using [**Map**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map).</span></span>
-   <span data-ttu-id="1aead-161">[**WriteToSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-writetosubresource) ：將資料複製到使用 [**Map**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map)對應的材質。</span><span class="sxs-lookup"><span data-stu-id="1aead-161">[**WriteToSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-writetosubresource) : copies data into a texture which was mapped using [**Map**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-map).</span></span>

<span data-ttu-id="1aead-162">資源和父堆積有對齊需求：</span><span class="sxs-lookup"><span data-stu-id="1aead-162">Resources and parent heaps have alignment requirements:</span></span>

-   <span data-ttu-id="1aead-163">D3D12 \_ \_ \_ \_ \_ 多重範例紋理的預設 MSAA 資源放置對齊 (4mb) 。</span><span class="sxs-lookup"><span data-stu-id="1aead-163">D3D12\_DEFAULT\_MSAA\_RESOURCE\_PLACEMENT\_ALIGNMENT (4MB) for multi-sample textures.</span></span>
-   <span data-ttu-id="1aead-164">D3D12 \_ \_ \_ \_ 單一範例紋理和緩衝區的預設資源位置對齊 (64kb) 。</span><span class="sxs-lookup"><span data-stu-id="1aead-164">D3D12\_DEFAULT\_RESOURCE\_PLACEMENT\_ALIGNMENT (64KB) for single sample textures and buffers.</span></span>
-   <span data-ttu-id="1aead-165">線性 subresource 複製必須對齊 D3D12 \_ 材質 \_ 資料 \_ 放置 \_ 對齊 (512 個位元組) ，而且資料列間距會對齊 D3D12 \_ 材質 \_ 資料 \_ 音調 \_ 對齊 (256 個位元組) 。</span><span class="sxs-lookup"><span data-stu-id="1aead-165">Linear subresource copying must be aligned to D3D12\_TEXTURE\_DATA\_PLACEMENT\_ALIGNMENT (512 bytes), with row pitch being aligned to D3D12\_TEXTURE\_DATA\_PITCH\_ALIGNMENT (256 bytes).</span></span>
-   <span data-ttu-id="1aead-166">常數緩衝區視圖必須對齊 D3D12 \_ 常數 \_ 緩衝區 \_ 資料 \_ 放置對齊， \_ (256 個位元組) 。</span><span class="sxs-lookup"><span data-stu-id="1aead-166">Constant buffer views must be aligned to D3D12\_CONSTANT\_BUFFER\_DATA\_PLACEMENT\_ALIGNMENT (256 bytes).</span></span>

<span data-ttu-id="1aead-167">小於64KB 的材質應該透過 [**CreateCommittedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createcommittedresource)來處理。</span><span class="sxs-lookup"><span data-stu-id="1aead-167">Textures smaller than 64KB should be processed through [**CreateCommittedResource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createcommittedresource).</span></span>

<span data-ttu-id="1aead-168">使用動態紋理 (材質變更每個畫面格) CPU 會以線性方式寫入上傳堆積，然後再進行 GPU 複製作業。</span><span class="sxs-lookup"><span data-stu-id="1aead-168">With dynamic textures (textures that change every frame) the CPU will write linearly to the upload heap, followed by a GPU copy operation.</span></span>

<span data-ttu-id="1aead-169">一般而言，若要建立動態資源，請在上傳堆積中建立大型緩衝區 (請參閱 [緩衝區內](large-buffers.md) 的子分配) 。</span><span class="sxs-lookup"><span data-stu-id="1aead-169">Typically to create dynamic resources create a large buffer in an upload heap (refer to [Suballocation Within Buffers](large-buffers.md)).</span></span> <span data-ttu-id="1aead-170">若要建立暫存資源，請在 readback 堆積中建立大型緩衝區。</span><span class="sxs-lookup"><span data-stu-id="1aead-170">To create staging resources, create a large buffer in a readback heap.</span></span> <span data-ttu-id="1aead-171">若要建立預設靜態資源，請在預設堆積中建立連續的資源。</span><span class="sxs-lookup"><span data-stu-id="1aead-171">To create default static resources, create adjacent resources in a default heap.</span></span> <span data-ttu-id="1aead-172">若要建立預設的別名資源，請在預設堆積中建立重迭的資源。</span><span class="sxs-lookup"><span data-stu-id="1aead-172">To create default aliased resources, create overlapping resources in a default heap.</span></span>

<span data-ttu-id="1aead-173">[**WriteToSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-writetosubresource) 和 [**ReadFromSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-readfromsubresource) 會在資料列的版面配置和未定義的資源版面配置之間重新排列材質資料。</span><span class="sxs-lookup"><span data-stu-id="1aead-173">[**WriteToSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-writetosubresource) and [**ReadFromSubresource**](/windows/desktop/api/d3d12/nf-d3d12-id3d12resource-readfromsubresource) rearrange texture data between a row-major layout and an undefined resource layout.</span></span> <span data-ttu-id="1aead-174">作業是同步的，因此應用程式應記住 CPU 排程。</span><span class="sxs-lookup"><span data-stu-id="1aead-174">The operation is synchronous, so the application should keep CPU scheduling in mind.</span></span> <span data-ttu-id="1aead-175">應用程式一律會將複製分割成較小的區域，或在另一項工作中排程這項作業。</span><span class="sxs-lookup"><span data-stu-id="1aead-175">The application can always break up the copying into smaller regions or schedule this operation in another task.</span></span> <span data-ttu-id="1aead-176">這些 CPU 複製作業不支援具有不透明資源版面配置的 MSAA 資源和深度樣板資源，且會造成失敗。</span><span class="sxs-lookup"><span data-stu-id="1aead-176">MSAA resources and depth-stencil resources with opaque resource layouts are not supported by these CPU copy operations, and will cause a failure.</span></span> <span data-ttu-id="1aead-177">也不支援不具雙線元素大小的格式，而且也會造成失敗。</span><span class="sxs-lookup"><span data-stu-id="1aead-177">Formats which don’t have a power-of-two element size are also not supported and will also cause a failure.</span></span> <span data-ttu-id="1aead-178">可能會發生記憶體不足的傳回碼。</span><span class="sxs-lookup"><span data-stu-id="1aead-178">Out of memory return codes can occur.</span></span>

## <a name="related-topics"></a><span data-ttu-id="1aead-179">相關主題</span><span class="sxs-lookup"><span data-stu-id="1aead-179">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="1aead-180">**核心常數**</span><span class="sxs-lookup"><span data-stu-id="1aead-180">**Core Constants**</span></span>](constants.md)
</dt> <dt>

[<span data-ttu-id="1aead-181">**ID3D12Heap**</span><span class="sxs-lookup"><span data-stu-id="1aead-181">**ID3D12Heap**</span></span>](/windows/desktop/api/d3d12/nn-d3d12-id3d12heap)
</dt> <dt>

[<span data-ttu-id="1aead-182">資源系結</span><span class="sxs-lookup"><span data-stu-id="1aead-182">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




