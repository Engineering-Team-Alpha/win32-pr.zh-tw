---
title: 柵格化規則
description: 點陣化規則定義向量資料對應至點陣資料的方式。
ms.assetid: 2b3894eb-dff3-401f-8b14-4af98db86e39
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e256c6fc171c1cce9b63b79fac6a480e507a306e
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104375385"
---
# <a name="rasterization-rules"></a><span data-ttu-id="d0cdf-103">柵格化規則</span><span class="sxs-lookup"><span data-stu-id="d0cdf-103">Rasterization Rules</span></span>

<span data-ttu-id="d0cdf-104">點陣化規則定義向量資料對應至點陣資料的方式。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-104">Rasterization rules define how vector data is mapped into raster data.</span></span> <span data-ttu-id="d0cdf-105">點陣資料會貼齊至整數位置，該整數位置接著會進行揀選和裁剪 (以繪製像素數目下限)，而每個像素屬性會在傳遞至像素著色器之前進行插入 (從每個頂點屬性)。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-105">The raster data is snapped to integer locations that are then culled and clipped (to draw the minimum number of pixels), and per-pixel attributes are interpolated (from per-vertex attributes) before being passed to a pixel shader.</span></span>

<span data-ttu-id="d0cdf-106">有數種規則根據將對應的基本類型，以及資料是否使用多重取樣來減少鋸齒化。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-106">There are several types of rules, which depend on the type of primitive that is being mapped, as well as whether or not the data uses multisampling to reduce aliasing.</span></span> <span data-ttu-id="d0cdf-107">以下圖例示範異常情況的處理方式。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-107">The following illustrations demonstrate how the corner cases are handled.</span></span>

-   [<span data-ttu-id="d0cdf-108"> (不含取樣) 的三角形柵格化規則 </span><span class="sxs-lookup"><span data-stu-id="d0cdf-108">Triangle Rasterization Rules (Without Multisampling)</span></span>](#triangle-rasterization-rules-without-multisampling)
-   [<span data-ttu-id="d0cdf-109">線條柵格化規則 (為別名，不含多級程式) </span><span class="sxs-lookup"><span data-stu-id="d0cdf-109">Line Rasterization Rules (Aliased, Without Multisampling)</span></span>](#line-rasterization-rules-aliased-without-multisampling)
-   [<span data-ttu-id="d0cdf-110">線條柵格化規則 (反鋸齒效果，而不需要取樣) </span><span class="sxs-lookup"><span data-stu-id="d0cdf-110">Line Rasterization Rules (Antialiased, Without Multisampling)</span></span>](#line-rasterization-rules-antialiased-without-multisampling)
-   [<span data-ttu-id="d0cdf-111">點柵格化規則 (沒有取樣) </span><span class="sxs-lookup"><span data-stu-id="d0cdf-111">Point Rasterization Rules (Without Multisampling)</span></span>](#point-rasterization-rules-without-multisampling)
-   [<span data-ttu-id="d0cdf-112">多級化消除鋸齒的點陣化規則</span><span class="sxs-lookup"><span data-stu-id="d0cdf-112">Multisample Anti-Aliasing Rasterization Rules</span></span>](#multisample-anti-aliasing-rasterization-rules)
    -   [<span data-ttu-id="d0cdf-113">硬體支援</span><span class="sxs-lookup"><span data-stu-id="d0cdf-113">Hardware Support</span></span>](#hardware-support)
    -   [<span data-ttu-id="d0cdf-114">在進行多重取樣消除鋸齒時距心屬性取樣</span><span class="sxs-lookup"><span data-stu-id="d0cdf-114">Centroid Sampling of Attributes when Multisample Antialiasing</span></span>](#centroid-sampling-of-attributes-when-multisample-antialiasing)
    -   [<span data-ttu-id="d0cdf-115">取樣時的衍生計算</span><span class="sxs-lookup"><span data-stu-id="d0cdf-115">Derivative Calculations When Multisampling</span></span>](#derivative-calculations-when-multisampling)
-   [<span data-ttu-id="d0cdf-116">相關主題</span><span class="sxs-lookup"><span data-stu-id="d0cdf-116">Related topics</span></span>](#related-topics)

## <a name="triangle-rasterization-rules-without-multisampling"></a><span data-ttu-id="d0cdf-117">三角形點陣化規則 (不含多重取樣)</span><span class="sxs-lookup"><span data-stu-id="d0cdf-117">Triangle Rasterization Rules (Without Multisampling)</span></span>

<span data-ttu-id="d0cdf-118">繪製落在三角形內的任何像素中心；如果像素通過左上規則便假設是在內部。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-118">Any pixel center which falls inside a triangle is drawn; a pixel is assumed to be inside if it passes the top-left rule.</span></span> <span data-ttu-id="d0cdf-119">左上規則是像素中心被定義為若位在三角形的上緣或左緣即落在三角形內。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-119">The top-left rule is that a pixel center is defined to lie inside of a triangle if it lies on the top edge or the left edge of a triangle.</span></span>

<span data-ttu-id="d0cdf-120">其中：</span><span class="sxs-lookup"><span data-stu-id="d0cdf-120">Where:</span></span>

-   <span data-ttu-id="d0cdf-121">上緣是完全水平邊緣並且在其他邊緣上方。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-121">A top edge, is an edge that is exactly horizontal and is above the other edges.</span></span>
-   <span data-ttu-id="d0cdf-122">左邊緣是不完全水準的邊緣，位於三角形的左邊。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-122">A left edge, is an edge that is not exactly horizontal and is on the left side of the triangle.</span></span> <span data-ttu-id="d0cdf-123">三角形可以有一或兩個左邊緣。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-123">A triangle can have one or two left edges.</span></span>

<span data-ttu-id="d0cdf-124">左上規則確保只繪製相鄰三角形一次。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-124">The top-left rule ensures that adjacent triangles are drawn once.</span></span>

<span data-ttu-id="d0cdf-125">這個圖例顯示像素範例，繪製像素是因為它們不是落在三角形內，就是遵循左上規則。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-125">This illustration shows examples of pixels that are drawn because they either lie inside a triangle or follow the top-left rule.</span></span>

![左上角三角形柵格化範例的圖例](images/d3d10-rasterrulestriangle.png)

<span data-ttu-id="d0cdf-127">淺灰和暗灰格內的像素顯示它們為像素群組，以指出它們在哪個三角形內。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-127">The light and dark gray covering of the pixels show them as groups of the pixels to indicate which triangle they are inside.</span></span>

## <a name="line-rasterization-rules-aliased-without-multisampling"></a><span data-ttu-id="d0cdf-128">線條點陣化規則 (鋸齒化，沒有多重取樣)</span><span class="sxs-lookup"><span data-stu-id="d0cdf-128">Line Rasterization Rules (Aliased, Without Multisampling)</span></span>

<span data-ttu-id="d0cdf-129">線條點陣化規則使用菱形測試區域來判斷線條是否涵蓋像素。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-129">Line rasterization rules use a diamond test area to determine if a line covers a pixel.</span></span> <span data-ttu-id="d0cdf-130">若為 x-主要線條 (行-1 <= 斜率 <= + 1) ，則鑽石測試區域包含的 (顯示為實心) 左下邊緣、右下角和右下角;菱形會排除 (顯示在左上邊緣、右上角、頂端 corder、左上角和右邊的點) 。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-130">For x-major lines (lines with -1 <= slope <= +1), the diamond test area includes (shown solid) the lower-left edge, lower-right edge, and bottom corner; the diamond excludes (shown dotted) the upper-left edge, upper-right edge, the top corder, the left corner, and the right corner.</span></span> <span data-ttu-id="d0cdf-131">y 主要線條是非 x 主要線條的任何線條；測試菱形區與針對 x 主要線條所述的相同，只是除了右角落也包含在內以外。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-131">A y-major line is any line that is not an x-major line; the test diamond area is the same as described for the x-major line except the right corner is also included.</span></span>

<span data-ttu-id="d0cdf-132">提供菱形區域，當沿著線條從開頭到結束移動時若線條存在像素的菱形測試區域，則線條涵蓋像素。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-132">Given the diamond area, a line covers a pixel if the line exits the pixel's diamond test area when traveling along the line from the start towards the end.</span></span> <span data-ttu-id="d0cdf-133">帶狀線的行為相同，它是以一連串的線條繪製。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-133">A line strip behaves the same, as it is drawn as a sequence of lines.</span></span>

<span data-ttu-id="d0cdf-134">以下圖例顯示一些範例。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-134">The following illustration shows some examples.</span></span>

![以別名換行的範例圖解](images/d3d10-rasterrulesline.png)

## <a name="line-rasterization-rules-antialiased-without-multisampling"></a><span data-ttu-id="d0cdf-136">線條點陣化規則 (消除鋸齒，沒有多重取樣)</span><span class="sxs-lookup"><span data-stu-id="d0cdf-136">Line Rasterization Rules (Antialiased, Without Multisampling)</span></span>

<span data-ttu-id="d0cdf-137">消除鋸齒的線條點陣化為如同它是矩形一般 (寬度 = 1)。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-137">An antialiased line is rasterized as if it were a rectangle (with width = 1).</span></span> <span data-ttu-id="d0cdf-138">矩形會與產生每個像素涵蓋值的呈現目標相交，乘以該值成為像素著色器輸出 Alpha 元件。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-138">The rectangle intersects with a render target producing per-pixel coverage values, which are multiplied into pixel shader output alpha components.</span></span> <span data-ttu-id="d0cdf-139">在多重取樣的呈現目標上繪製線條時，不執行任何鋸齒化。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-139">There is no antialiasing preformed when drawing lines on a multisampled render target.</span></span>

<span data-ttu-id="d0cdf-140">它被視為沒有單一最佳途徑來執行消除鋸齒線條呈現。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-140">It is deemed that there is no single "best" way to perform antialiased line rendering.</span></span> <span data-ttu-id="d0cdf-141">Direct3D 10 採用作為下圖所示之方法的指導方針。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-141">Direct3D 10 adopts as a guideline the method shown in the following illustration.</span></span> <span data-ttu-id="d0cdf-142">這個方法是憑經驗證明衍生而來的，展示數個被認為需要的視覺屬性。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-142">This method was derived empirically, exhibiting a number of visual properties deemed desirable.</span></span> <span data-ttu-id="d0cdf-143">硬體不需要與這個演算法完全相符；對此參考的測試應有「合理」容錯，並由以下進一步列出的原則引導，允許各種硬體實作及篩選核心大小。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-143">Hardware need not exactly match this algorithm; tests against this reference shall have "reasonable" tolerances, guided by some of the principles listed further below, permitting various hardware implementations and filter kernel sizes.</span></span> <span data-ttu-id="d0cdf-144">不過，硬體實行中不允許這種彈性，但可以透過 Direct3D 10 傳遞至應用程式，而不只是繪製線條以及觀察/測量其外觀。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-144">None of this flexibility permitted in hardware implementation, however, can be communicated up through Direct3D 10 to applications, beyond simply drawing lines and observing/measuring how they look.</span></span>

![反鋸齒線條柵格化範例的圖例](images/d3d10-rasterruleslineaa.png)

<span data-ttu-id="d0cdf-146">這個演算法產生相對平滑的線條，具有一致的濃度，最低限度的鋸齒邊緣或編織。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-146">This algorithm generates relatively smooth lines, with uniform intensity, with minimal jagged edges or braiding.</span></span> <span data-ttu-id="d0cdf-147">將封閉線段的莫列波紋減至最小。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-147">Moire patterning for close lines is minimized.</span></span> <span data-ttu-id="d0cdf-148">點對點放置的線段間的接合有良好的涵蓋。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-148">There is good coverage for junctions between line segments placed end-to-end.</span></span> <span data-ttu-id="d0cdf-149">篩選核心是邊緣模糊量和 Gamma 修正造成的濃度變更之間的合理取捨。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-149">The filter kernel is a reasonable tradeoff between the amount of edge blurring and the changes in intensity caused by gamma corrections.</span></span> <span data-ttu-id="d0cdf-150">涵蓋範圍值會乘以圖元著色器 o0。輸出合併階段會根據下列公式)  (srcAlpha： srcColor \* srcAlpha + destColor \* (1-srcAlpha) 。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-150">The coverage value is multiplied into pixel shader o0.a (srcAlpha) per the following formula by the output-merger stage: srcColor \* srcAlpha + destColor \* (1-srcAlpha).</span></span>

## <a name="point-rasterization-rules-without-multisampling"></a><span data-ttu-id="d0cdf-151">點點陣化規則 (沒有多重取樣)</span><span class="sxs-lookup"><span data-stu-id="d0cdf-151">Point Rasterization Rules (Without Multisampling)</span></span>

<span data-ttu-id="d0cdf-152">點被解譯為如同由 Z 模式中的兩個三角形組成，而該三角形使用三角形點陣化規則。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-152">A point is interpreted as though it were composed of two triangles in a Z pattern, which use triangle rasterization rules.</span></span> <span data-ttu-id="d0cdf-153">座標會辨識一個像素寬的方形的中心。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-153">The coordinate identifies the center of a one pixel wide square.</span></span> <span data-ttu-id="d0cdf-154">沒有揀選任何點。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-154">There is no culling for points.</span></span>

<span data-ttu-id="d0cdf-155">以下圖例顯示一些範例。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-155">The following illustration shows some examples.</span></span>

![點點陣化範例的圖例](images/d3d10-rasterrulespoint.png)

## <a name="multisample-anti-aliasing-rasterization-rules"></a><span data-ttu-id="d0cdf-157">多重取樣取消鋸齒點陣化規則</span><span class="sxs-lookup"><span data-stu-id="d0cdf-157">Multisample Anti-Aliasing Rasterization Rules</span></span>

<span data-ttu-id="d0cdf-158">多重取樣取消鋸齒 (MSAA) 在多個子樣本位置，使用像素涵蓋範圍和深度樣板測試，來降低幾何鋸齒化。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-158">Multisample antialiasing (MSAA) reduces geometry aliasing using pixel coverage and depth-stencil tests at multiple sub-sample locations.</span></span> <span data-ttu-id="d0cdf-159">為改善效能，像素計算是透過在所涵蓋子像素共用著色器輸出，為每一個涵蓋的像素執行一次。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-159">To improve performance, per-pixel calculations are performed once for each covered pixel, by sharing shader outputs across covered sub-pixels.</span></span> <span data-ttu-id="d0cdf-160">多重取樣鋸齒化並不會減少表面鋸齒化。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-160">Multisample antialiasing does not reduce surface aliasing.</span></span> <span data-ttu-id="d0cdf-161">樣本位置和重建功能是依硬體實作而定。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-161">Sample locations and reconstruction functions are dependent on the hardware implementation.</span></span>

<span data-ttu-id="d0cdf-162">以下圖例顯示一些範例。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-162">The following illustration shows some examples.</span></span>

![多級化消除鋸齒柵格化範例的圖例](images/d3d10-rasterrulesmsaa.png)

<span data-ttu-id="d0cdf-164">樣本位置的數量依多重取樣模式而定。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-164">The number of sample locations is dependent on the multisample mode.</span></span> <span data-ttu-id="d0cdf-165">頂點屬性會插入像素中心，因為這是叫用像素著色器的地方 (若未覆蓋中心，這會變成外插法)。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-165">Vertex attributes are interpolated at pixel centers, since this is where the pixel shader is invoked (this becomes extrapolation if the center is not covered).</span></span> <span data-ttu-id="d0cdf-166">屬性可以在要距心取樣的像素著色器標幟，使非涵蓋的像素在像素區域和基本類型的交集處插入屬性。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-166">Attributes can be flagged in the pixel shader to be centroid sampled, which causes non-covered pixels to interpolate the attribute at intersection of the pixel's area and the primitive.</span></span> <span data-ttu-id="d0cdf-167">像素著色器會為每一個 2x2 像素區域執行，以支援衍生性計算 (使用 x 和 y 差異)。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-167">A pixel shader runs for each 2x2 pixel area to support derivative calculations (which use x and y deltas).</span></span> <span data-ttu-id="d0cdf-168">這表示著色器叫用的發生多於所顯示的，以填入最少 2x2 配量 (這不受多重取樣的影響)。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-168">This means that shader invocations occur more than is shown to fill out the minimum 2x2 quanta (which is independent of multisampling).</span></span> <span data-ttu-id="d0cdf-169">著色器結果會為每個覆蓋的且通過每個樣本深度樣板測試的樣本寫出。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-169">The shader result is written out for each covered sample that passes the per-sample depth-stencil test.</span></span>

<span data-ttu-id="d0cdf-170">基本類型的點陣化規則一般按照多重取樣鋸齒化保持不變，除了︰</span><span class="sxs-lookup"><span data-stu-id="d0cdf-170">Rasterization rules for primitives are, in general, unchanged by multisample antialiasing, except:</span></span>

-   <span data-ttu-id="d0cdf-171">對於三角形，會為每個樣本位置 (而不是像素中心) 執行涵蓋範圍測試。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-171">For a triangle, a coverage test is performed for each sample location (not for a pixel center).</span></span> <span data-ttu-id="d0cdf-172">如果涵蓋多個樣本位置，像素著色器會執行一次，在像素中央插入屬性。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-172">If more than one sample location is covered, a pixel shader runs once with attributes interpolated at the pixel center.</span></span> <span data-ttu-id="d0cdf-173">為通過深度/樣板測試的像素中的每個涵蓋的樣本位置，儲存 (複製) 結果。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-173">The result is stored (replicated) for each covered sample location in the pixel that passes the depth/stencil test.</span></span>

    <span data-ttu-id="d0cdf-174">線條會被視為兩個三角形組成的矩形，而線條的寬度為 1.4。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-174">A line is treated as a rectangle made up of two triangles, with a line width of 1.4.</span></span>

-   <span data-ttu-id="d0cdf-175">對於點，會為每個樣本位置 (而不是像素中心) 執行涵蓋範圍測試。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-175">For a point, a coverage test is performed for each sample location (not for a pixel center).</span></span>

<span data-ttu-id="d0cdf-176">許多格式都支援多取樣 (請參閱) [Direct3D 10 格式的硬體支援](/previous-versions//cc627090(v=vs.85)) 、某些格式可在 ([**ResolveSubresource**](/windows/desktop/api/d3d10/nf-d3d10-id3d10device-resolvesubresource)中加以解析;這會將多重取樣格式 downsamples 為 1) 的取樣大小。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-176">Many formats support multisampling (see [Hardware Support for Direct3D 10 Formats](/previous-versions//cc627090(v=vs.85))), some formats can be resolved ([**ResolveSubresource**](/windows/desktop/api/d3d10/nf-d3d10-id3d10device-resolvesubresource); which downsamples a multisampled format to a sample size of 1).</span></span> <span data-ttu-id="d0cdf-177">多重取樣格式可用於呈現目標，目標則可使用[載入](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-to-load)讀回著色器，因為著色器所存取的個別樣本不需要任何解析。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-177">Multisampling formats can be used in render targets which can be read back into shaders using [load](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-to-load), since no resolve is required for individual samples accessed by the shader.</span></span> <span data-ttu-id="d0cdf-178">多重取樣資源不支援深度格式，因此，深度格式只限於呈現目標。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-178">Depth formats are not supported for multisample resource, therefore, depth formats are restricted to render targets only.</span></span>

<span data-ttu-id="d0cdf-179">實例) 支援的無格式 (R8G8B8A8 的無別格式 \_ ，可讓資源查看以不同的方式解讀資料。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-179">Typeless formats (R8G8B8A8\_TYPELESS for instance) support multisampling to allow a resource view to interpret data in different ways.</span></span> <span data-ttu-id="d0cdf-180">例如，您可以使用 R8G8B8A8 的非型別來建立多重取樣資源 \_ 、使用具有 R8G8B8A8 UINT 格式的轉譯目標視圖資源進行轉譯， \_ 然後將內容解析成具有 R8G8B8A8 UNORM 資料格式的另一種資源 \_ 。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-180">For instance, you could create a multisample resource using R8G8B8A8\_TYPELESS, render to it using a render-target-view resource with a R8G8B8A8\_UINT format, then resolve the contents to another resource with a R8G8B8A8\_UNORM data format.</span></span>

### <a name="hardware-support"></a><span data-ttu-id="d0cdf-181">硬體支援</span><span class="sxs-lookup"><span data-stu-id="d0cdf-181">Hardware Support</span></span>

<span data-ttu-id="d0cdf-182">API 透過幾個品質等級報告對於多重取樣的硬體支援。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-182">The API reports hardware support for multisampling through the number of quality levels.</span></span> <span data-ttu-id="d0cdf-183">例如，0 的品質等級表示硬體不支援多重取樣 (在特定的格式及品質等級)。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-183">For example, a 0 quality level means the hardware does not support multisampling (at a particular format and quality level).</span></span> <span data-ttu-id="d0cdf-184">3 的品質等級表示硬體支援三種不同樣本配置和/或解析演算法。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-184">A 3 for quality levels means that the hardware supports three different sample layouts and/or resolve algorithms.</span></span> <span data-ttu-id="d0cdf-185">您也可以假設下列情況：</span><span class="sxs-lookup"><span data-stu-id="d0cdf-185">You can also assume the following:</span></span>

-   <span data-ttu-id="d0cdf-186">所有支援多重取樣的格式，支援該系列中每個格式相同數量的品質等級。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-186">Any format that supports multisampling, supports the same number of quality levels for every format in that family.</span></span>
-   <span data-ttu-id="d0cdf-187">每種支援取樣的格式，以及具有 \_ UNORM、 \_ SRGB、 \_ SNORM 或 \_ FLOAT 格式的格式，也都支援解析。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-187">Every format that supports multisampling, and has the \_UNORM, \_SRGB, \_SNORM or \_FLOAT formats, also supports resolving.</span></span>

### <a name="centroid-sampling-of-attributes-when-multisample-antialiasing"></a><span data-ttu-id="d0cdf-188">多重取樣鋸齒化時屬性的距心取樣</span><span class="sxs-lookup"><span data-stu-id="d0cdf-188">Centroid Sampling of Attributes when Multisample Antialiasing</span></span>

<span data-ttu-id="d0cdf-189">根據預設，頂點屬性會在多重取樣鋸齒化期間插入像素的中心；如果未涵蓋像素中心，屬性會外插到像素中心。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-189">By default, vertex attributes are interpolated to a pixel center during multisample antialiasing; if the pixel center is not covered, attributes are extrapolated to a pixel center.</span></span> <span data-ttu-id="d0cdf-190">如果包含距心像素語意 (假設像素未完全涵蓋) 的像素著色器輸入，將在像素涵蓋區內的某個位置取樣，就可能是在涵蓋的樣本位置之一。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-190">If a pixel shader input that contains the centroid semantic (assuming the pixel is not fully covered) will be sampled somewhere within the covered area of the pixel, possibly at one of the covered sample locations.</span></span> <span data-ttu-id="d0cdf-191">樣本遮罩 (由轉譯器狀態指定) 會在距心運算之前套用。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-191">A sample mask (specified by the rasterizer state) is applied prior to centroid computation.</span></span> <span data-ttu-id="d0cdf-192">因此，遮罩住的樣本將不會用來做為距心位置。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-192">Therefore, a sample that is masked out will not be used as a centroid location.</span></span>

<span data-ttu-id="d0cdf-193">參考轉譯器會選擇距心取樣的樣本位置，類似如下所列︰</span><span class="sxs-lookup"><span data-stu-id="d0cdf-193">The reference rasterizer chooses a sample location for centroid sampling similar to this:</span></span>

-   <span data-ttu-id="d0cdf-194">樣本遮罩允許所有樣本。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-194">The sample mask allows all samples.</span></span> <span data-ttu-id="d0cdf-195">如果涵蓋像素或未涵蓋任何樣本，則使用像素中心。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-195">Use a pixel center if the pixel is covered or if none of the samples are covered.</span></span> <span data-ttu-id="d0cdf-196">否則，選擇第一個涵蓋的樣本，從像素中心開始並向外移動。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-196">Otherwise, the first covered sample is chosen, starting from the pixel center and moving outward.</span></span>
-   <span data-ttu-id="d0cdf-197">樣本遮罩會關閉所有樣本，但其中一個 (常見案例) 除外。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-197">The sample mask turns off all samples but one (a common scenario).</span></span> <span data-ttu-id="d0cdf-198">應用程式可以實作多次超級取樣，方法是對於每個使用距心取樣的樣本，循環單一位元樣本遮罩值和重新呈現場景。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-198">An application can implement multipass supersampling by cycling through single-bit sample-mask values and re-rendering the scene for each sample using centroid sampling.</span></span> <span data-ttu-id="d0cdf-199">這需要應用程式調整導數，以適當選取更詳細的紋理 Mips，擁有較高的紋理取樣密度 。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-199">This would require that an application adjust derivatives to select appropriately more detailed texture mips for the higher texture sampling density.</span></span>

### <a name="derivative-calculations-when-multisampling"></a><span data-ttu-id="d0cdf-200">多重取樣時的導數計算</span><span class="sxs-lookup"><span data-stu-id="d0cdf-200">Derivative Calculations When Multisampling</span></span>

<span data-ttu-id="d0cdf-201">像素著色器永遠使用最低的 2x2 像素區域來執行，以支援導數計算，其透過從相鄰像素的資料間得出差異來計算 (假設每個像素中的資料已取樣，以水平或垂直的單位間距取樣)。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-201">Pixel shaders always run using a minimum 2x2 pixel area to support derivative calculations, which are calculated by taking deltas between data from adjacent pixels (making the assumption that the data in each pixel has been sampled with unit spacing horizontally or vertically).</span></span> <span data-ttu-id="d0cdf-202">這不受多重取樣的影響。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-202">This is unaffected by multisampling.</span></span>

<span data-ttu-id="d0cdf-203">如果已經距心取樣的屬性要求導數，就不調整硬體計算，這可能導致不正確的導數。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-203">If derivatives are requested on an attribute that has been centroid sampled, the hardware calculation is not adjusted, which can cause inaccurate derivatives.</span></span> <span data-ttu-id="d0cdf-204">著色器會預期呈現目標空間中的單位向量，但可能取得與一些其他向量空間相關的非單位向量。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-204">A shader will expect a unit vector in render-target space but may get a non-unit vector with respect to some other vector space.</span></span> <span data-ttu-id="d0cdf-205">因此，由應用程式負責在從已距心取樣的屬性要求導數時顯示警告。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-205">Therefore, it is an application's responsibility to exhibit caution when requesting derivatives from attributes that are centroid sampled.</span></span> <span data-ttu-id="d0cdf-206">事實上，建議不要結合導數和距心取樣。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-206">In fact, it is recommended that you do not combine derivatives and centroid sampling.</span></span> <span data-ttu-id="d0cdf-207">距心取樣在這些情況可能很實用：基本類型的插入屬性不外插，但隨之而來的是要有所取捨，例如基本類型邊緣與像素交錯時跳動 (而不是持續變更) 或紋理取樣作業無法使用的導數衍生 LOD。</span><span class="sxs-lookup"><span data-stu-id="d0cdf-207">Centroid sampling can be useful for situations where it is critical that a primitive's interpolated attributes are not extrapolated, but this comes with tradeoffs such as attributes that appear to jump where a primitive edge crosses a pixel (rather than change continuously) or derivatives that cannot be used by texture sampling operations that derive LOD.</span></span>

## <a name="related-topics"></a><span data-ttu-id="d0cdf-208">相關主題</span><span class="sxs-lookup"><span data-stu-id="d0cdf-208">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="d0cdf-209">轉譯器階段</span><span class="sxs-lookup"><span data-stu-id="d0cdf-209">Rasterizer Stage</span></span>](d3d10-graphics-programming-guide-rasterizer-stage.md)
</dt> </dl>

 

 