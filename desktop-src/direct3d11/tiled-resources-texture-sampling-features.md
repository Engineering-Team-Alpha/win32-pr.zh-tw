---
title: 磚資源紋理取樣功能
description: 本節說明並排顯示的資源紋理取樣功能。
ms.assetid: E56737CE-C468-4D3C-84EE-E8EB2AB6F505
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cdd46c96219e54aea6990e91de8e340fdca5e32b
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "103682714"
---
# <a name="tiled-resources-texture-sampling-features"></a><span data-ttu-id="337ce-103">磚資源紋理取樣功能</span><span class="sxs-lookup"><span data-stu-id="337ce-103">Tiled resources texture sampling features</span></span>

<span data-ttu-id="337ce-104">本節說明並排顯示的資源紋理取樣功能。</span><span class="sxs-lookup"><span data-stu-id="337ce-104">This section describes tiled resources texture sampling features.</span></span>

## <a name="requirements-of-tiled-resources-texture-sampling-features"></a><span data-ttu-id="337ce-105">磚資源紋理取樣功能的需求</span><span class="sxs-lookup"><span data-stu-id="337ce-105">Requirements of tiled resources texture sampling features</span></span>

<span data-ttu-id="337ce-106">此處所述的材質取樣功能需要 [第2層層](tier-2.md) 級的並排資源支援。</span><span class="sxs-lookup"><span data-stu-id="337ce-106">The texture sampling features described here require [Tier 2](tier-2.md) level of tiled resources support.</span></span>

## <a name="shader-feedback-about-mapped-areas"></a><span data-ttu-id="337ce-107">對應區域的著色器意見反應</span><span class="sxs-lookup"><span data-stu-id="337ce-107">Shader feedback about mapped areas</span></span>

<span data-ttu-id="337ce-108">讀取及/或寫入磚資源的任何著色器指令都會導致狀態資訊記錄。</span><span class="sxs-lookup"><span data-stu-id="337ce-108">Any shader instruction that reads and/or writes to a tiled resource causes status information to be recorded.</span></span> <span data-ttu-id="337ce-109">這個狀態公開為進入 32 位元暫時暫存器之每個資源存取指令的選擇性額外傳回值。</span><span class="sxs-lookup"><span data-stu-id="337ce-109">This status is exposed as an optional extra return value on every resource access instruction that goes into a 32-bit temp register.</span></span> <span data-ttu-id="337ce-110">傳回值的內容是不透明。</span><span class="sxs-lookup"><span data-stu-id="337ce-110">The contents of the return value are opaque.</span></span> <span data-ttu-id="337ce-111">也就是，不允許著色器程式直接讀取。</span><span class="sxs-lookup"><span data-stu-id="337ce-111">That is, direct reading by the shader program is disallowed.</span></span> <span data-ttu-id="337ce-112">但是，您可以使用 [**CheckAccessFullyMapped**](/windows/desktop/direct3dhlsl/checkaccessfullymapped) 函式來擷取狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="337ce-112">But, you can use the [**CheckAccessFullyMapped**](/windows/desktop/direct3dhlsl/checkaccessfullymapped) function to extract the status info.</span></span>

## <a name="fully-mapped-check"></a><span data-ttu-id="337ce-113">完全對應檢查</span><span class="sxs-lookup"><span data-stu-id="337ce-113">Fully mapped check</span></span>

<span data-ttu-id="337ce-114">[**CheckAccessFullyMapped**](/windows/desktop/direct3dhlsl/checkaccessfullymapped) 函式解譯從記憶體存取傳回的狀態，並指出存取的所有資料是否都在資源中對應。</span><span class="sxs-lookup"><span data-stu-id="337ce-114">The [**CheckAccessFullyMapped**](/windows/desktop/direct3dhlsl/checkaccessfullymapped) function interprets the status returned from a memory access and indicates whether all data being accessed was mapped in the resource.</span></span> <span data-ttu-id="337ce-115">如果資料已對應，**CheckAccessFullyMapped** 傳回 true (0xFFFFFFFF)，如果資料未對應則傳回 false (0x00000000)。</span><span class="sxs-lookup"><span data-stu-id="337ce-115">**CheckAccessFullyMapped** returns true (0xFFFFFFFF) if data was mapped or false (0x00000000) if data was unmapped.</span></span>

<span data-ttu-id="337ce-116">在篩選作業時，有時候特定紋素的加權會變成 0.0。</span><span class="sxs-lookup"><span data-stu-id="337ce-116">During filter operations, sometimes the weight of a given texel ends up being 0.0.</span></span> <span data-ttu-id="337ce-117">一個範例是紋理座標直接落在紋素中心的線性樣本：3 個其他紋素 (有哪些可能因硬體而不同) 貢獻到篩選，但具有 0 加權。</span><span class="sxs-lookup"><span data-stu-id="337ce-117">An example is a linear sample with texture coordinates that fall directly on a texel center: 3 other texels (which ones they are can vary by hardware) contribute to the filter but with 0 weight.</span></span> <span data-ttu-id="337ce-118">這些 0 加權紋素完全不會貢獻到篩選結果，如果它們恰巧落在 **NULL** 磚，它們不算是未對應的存取。</span><span class="sxs-lookup"><span data-stu-id="337ce-118">These 0 weight texels don't contribute to the filter result at all, so if they happen to fall on **NULL** tiles, they don't count as an unmapped access.</span></span> <span data-ttu-id="337ce-119">請注意，相同的保證適用於包括多個 mip 層級的紋理篩選；如果其中一個 mipmap 的紋素未對應，但在那些紋素的加權是 0，那些紋素不算是未對應的存取。</span><span class="sxs-lookup"><span data-stu-id="337ce-119">Note the same guarantee applies for texture filters that include multiple mip levels; if the texels on one of the mipmaps isn't mapped but the weight on those texels is 0, those texels don't count as an unmapped access.</span></span>

<span data-ttu-id="337ce-120">從具有少於4個元件的格式進行取樣 (例如 DXGI \_ 格式 \_ R8 \_ UNORM) ，任何落在 **null** 磚上的材質都會導致回報 **null** 對應存取，不論著色器實際在結果中查看哪些元件。</span><span class="sxs-lookup"><span data-stu-id="337ce-120">When sampling from a format that has fewer than 4 components (such as DXGI\_FORMAT\_R8\_UNORM), any texels that fall on **NULL** tiles result in the a **NULL** mapped access being reported regardless of which components the shader actually looks at in the result.</span></span> <span data-ttu-id="337ce-121">例如，從 R8 UNORM 讀取 \_ 和遮罩著色器中的讀取結果（使用. gba/. yzw 根本不需要讀取紋理）。</span><span class="sxs-lookup"><span data-stu-id="337ce-121">For example, reading from R8\_UNORM and masking the read result in the shader with .gba/.yzw wouldn't appear to need to read the texture at all.</span></span> <span data-ttu-id="337ce-122">但如果紋素位址是 **NULL** 對應磚，作業仍然算是 **NULL** 對應存取。</span><span class="sxs-lookup"><span data-stu-id="337ce-122">But if the texel address is a **NULL** mapped tile, the operation still counts as a **NULL** map access.</span></span>

<span data-ttu-id="337ce-123">著色器可以檢查狀態，並在失敗時追求任何您想要的動作過程。</span><span class="sxs-lookup"><span data-stu-id="337ce-123">The shader can check the status and pursue any desired course of action on failure.</span></span> <span data-ttu-id="337ce-124">例如，動作過程可以是記錄「遺漏」(例如透過 UAV 寫入) 和/或發出另一個讀取 (鉗制到已知對應的更粗略 LOD)。</span><span class="sxs-lookup"><span data-stu-id="337ce-124">For example, a course of action can be logging 'misses' (say via UAV write) and/or issuing another read clamped to a coarser LOD known to be mapped.</span></span> <span data-ttu-id="337ce-125">應用程式可能也要追蹤成功存取，以了解對應磚集的哪個部分被存取。</span><span class="sxs-lookup"><span data-stu-id="337ce-125">An application might want to track successful accesses as well in order to get a sense of what portion of the mapped set of tiles got accessed.</span></span>

<span data-ttu-id="337ce-126">記錄的一個複雜問題是沒有機制存在回報一組確切的磚被存取。</span><span class="sxs-lookup"><span data-stu-id="337ce-126">One complication for logging is no mechanism exists for reporting the exact set of tiles that would have been accessed.</span></span> <span data-ttu-id="337ce-127">應用程式可以根據其用於存取的座標來進行保守猜測，以及使用」 LOD 指令 (例如， [**tex2Dlod**](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-tex2dlod)) 傳回硬體」 lod 計算。</span><span class="sxs-lookup"><span data-stu-id="337ce-127">The application can make conservative guesses based on knowing the coordinates it used for access, as well as using the LOD instruction (for example, [**tex2Dlod**](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-tex2dlod)) which returns what the hardware LOD calculation is.</span></span>

<span data-ttu-id="337ce-128">另一個問題是，許多存取會到同一個磚，所以會發生許多重複記錄和可能記憶體競爭。</span><span class="sxs-lookup"><span data-stu-id="337ce-128">Another complication is that lots of accesses will be to the same tiles, so a lot of redundant logging will occur and possibly contention on memory.</span></span> <span data-ttu-id="337ce-129">如果硬體有選項，在之前其他地方有報告時，不需要為了報告磚存取而擔心，則可能很便利。</span><span class="sxs-lookup"><span data-stu-id="337ce-129">It could be convenient if the hardware could be given the option to not bother to report tile accesses if they were reported elsewhere before.</span></span> <span data-ttu-id="337ce-130">或許這類追蹤的狀態可能從 API 重設 (可能在畫面界限)。</span><span class="sxs-lookup"><span data-stu-id="337ce-130">Perhaps the state of such tracking could be reset from the API (likely at frame boundaries).</span></span>

## <a name="per-sample-minlod-clamp"></a><span data-ttu-id="337ce-131">每個樣本 MinLOD 鉗制</span><span class="sxs-lookup"><span data-stu-id="337ce-131">Per-sample MinLOD clamp</span></span>

<span data-ttu-id="337ce-132">為了協助著色器避免 mipmapped 中的區域被視為非對應的資源，大部分涉及使用取樣器 (篩選) 的著色器指令都有新的模式，可讓著色器將額外的 float32 MinLOD 夾具參數傳遞給紋理範例。</span><span class="sxs-lookup"><span data-stu-id="337ce-132">To help shaders avoid areas in mipmapped tiled resources that are known to be non-mapped, most shader instructions that involve using a sampler (filtering) have a new mode that allows the shader to pass an additional float32 MinLOD clamp parameter to the texture sample.</span></span> <span data-ttu-id="337ce-133">這個值位於檢視的 mipmap 數字空間，而不是基礎資源。</span><span class="sxs-lookup"><span data-stu-id="337ce-133">This value is in the view's mipmap number space, as opposed to the underlying resource.</span></span>

<span data-ttu-id="337ce-134">硬體會在」 LOD 計算中的相同位置執行 [**最大**](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-max) (FShaderMinLODClamp、fComputedLOD) ，其中每個資源 MinLOD 的夾具也是 **最大** () 。</span><span class="sxs-lookup"><span data-stu-id="337ce-134">The hardware performs [**max**](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-max)(fShaderMinLODClamp,fComputedLOD) in the same place in the LOD calculation where the per-resource MinLOD clamp occurs, which is also a **max**().</span></span>

<span data-ttu-id="337ce-135">如果套用每個樣本 LOD 鉗制和定義於取樣器之任何其他 LOD 鉗制的結果是空集合，結果是和每個資源 minLOD 鉗制相同的超出範圍存取結果：0 表示表面格式中的元件，預設值表示遺失元件。</span><span class="sxs-lookup"><span data-stu-id="337ce-135">If the result of applying the per-sample LOD clamp and any other LOD clamps defined in the sampler is an empty set, the result is the same out of bounds access result as the per-resource minLOD clamp: 0 for components in the surface format and defaults for missing components.</span></span>

<span data-ttu-id="337ce-136">」 LOD 指令 (例如， [**tex2Dlod**](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-tex2dlod)) ，它會比此處所述的每個樣本 minLOD 夾具，同時傳回壓制和 unclamped」 lod。</span><span class="sxs-lookup"><span data-stu-id="337ce-136">The LOD instruction (for example, [**tex2Dlod**](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-tex2dlod)), which predates the per-sample minLOD clamp described here, returns both a clamped and unclamped LOD.</span></span> <span data-ttu-id="337ce-137">從這個 LOD 指令傳回的鉗制 LOD 反映所有鉗制，包括每個資源鉗制，但不是每個樣本鉗制。</span><span class="sxs-lookup"><span data-stu-id="337ce-137">The clamped LOD returned from this LOD instruction reflects all clamping including the per-resource clamp, but not a per-sample clamp.</span></span> <span data-ttu-id="337ce-138">每個樣本鉗制是由著色器控制和所知，因此著色器作者如有需要可以手動將該鉗制套用至 LOD 指令的傳回值。</span><span class="sxs-lookup"><span data-stu-id="337ce-138">Per-sample clamp is controlled and known by the shader anyway, so the shader author can manually apply that clamp to the LOD instruction's return value if desired.</span></span>

## <a name="minmax-reduction-filtering"></a><span data-ttu-id="337ce-139">最小/最大削減篩選</span><span class="sxs-lookup"><span data-stu-id="337ce-139">Min/Max reduction filtering</span></span>

<span data-ttu-id="337ce-140">應用程式可以選擇管理自己的資料結構，以通知它們對應的磚資源外觀。</span><span class="sxs-lookup"><span data-stu-id="337ce-140">Applications can choose to manage their own data structures that inform them of what the mappings looks like for a tiled resource.</span></span> <span data-ttu-id="337ce-141">其中一個範例就是一個介面，其中包含的材質可保存磚資源內每個磚的資訊。</span><span class="sxs-lookup"><span data-stu-id="337ce-141">An example would be a surface that contains a texel to hold information for every tile in a tiled resource.</span></span> <span data-ttu-id="337ce-142">有人可能會儲存在特定磚位置對應的第一個 LOD。</span><span class="sxs-lookup"><span data-stu-id="337ce-142">One might store the first LOD that is mapped at a given tile location.</span></span> <span data-ttu-id="337ce-143">藉由仔細取樣此資料結構的方式，就像是要取樣並排顯示的資源，可能會發現完全對應的最小」 LOD 是整個材質篩選器使用量的最小值。</span><span class="sxs-lookup"><span data-stu-id="337ce-143">By careful sampling of this data structure in a similar way that the tiled resource is intended to be sampled, one might discover what the minimum LOD that is fully mapped for an entire texture filter footprint will be.</span></span> <span data-ttu-id="337ce-144">為了讓這個程序更容易，Direct3D 11.2 引進新的通用取樣器模式，最小/最大篩選。</span><span class="sxs-lookup"><span data-stu-id="337ce-144">To help make this process easier, Direct3D 11.2 introduces a new general purpose sampler mode, min/max filtering.</span></span>

<span data-ttu-id="337ce-145">LOD 追蹤的最小/最大篩選公用程式可能對其他用途有用，例如，也許是深度表面篩選。</span><span class="sxs-lookup"><span data-stu-id="337ce-145">The utility of min/max filtering for LOD tracking might be useful for other purposes, such as, perhaps the filtering of depth surfaces.</span></span>

<span data-ttu-id="337ce-146">最小/最大減少篩選是取樣器上的模式，會擷取一般紋理篩選擷取的一組相同的紋素。</span><span class="sxs-lookup"><span data-stu-id="337ce-146">Min/max reduction filtering is a mode on samplers that fetches the same set of texels that a normal texture filter would fetch.</span></span> <span data-ttu-id="337ce-147">但是，它會依據每個元素傳回所擷取紋素的 min() 或 max() (例如，所有 R 值的最小值，與所有 G 值的最小值分開，以此類推)，而不是混合值以產生答案。</span><span class="sxs-lookup"><span data-stu-id="337ce-147">But instead of blending the values to produce an answer, it returns the min() or max() of the texels fetched, on a per-component basis (for example, the min of all the R values, separately from the min of all the G values and so on).</span></span>

<span data-ttu-id="337ce-148">最小/最大作業遵循 Direct3D 算術精確度規則。</span><span class="sxs-lookup"><span data-stu-id="337ce-148">The min/max operations follow Direct3D arithmetic precision rules.</span></span> <span data-ttu-id="337ce-149">比較的順序並不重要。</span><span class="sxs-lookup"><span data-stu-id="337ce-149">The order of comparisons doesn't matter.</span></span>

<span data-ttu-id="337ce-150">在不是最小/最大的篩選作業時，有時候特定紋素的加權會變成 0.0。</span><span class="sxs-lookup"><span data-stu-id="337ce-150">During filter operations that aren't min/max, sometimes the weight of a given texel ends up being 0.0.</span></span> <span data-ttu-id="337ce-151">其中一個範例是具有材質座標的線性範例，直接落在材質 center-3 個其他材質 (它們可能會因硬體而異) 對篩選準則有所差異，但有0權數。</span><span class="sxs-lookup"><span data-stu-id="337ce-151">An example is a linear sample with texture coordinates that fall directly on a texel center - 3 other texels (which ones they are may vary by hardware) contribute to the filter but with 0 weight.</span></span> <span data-ttu-id="337ce-152">對於在非最小/最大篩選上 0 加權的任何紋素，如果篩選是最小/最大，這些紋素仍然不會貢獻到結果 (而且加權不會影響最小/最大篩選作業)。</span><span class="sxs-lookup"><span data-stu-id="337ce-152">For any of these texels that would be 0 weight on a non-min/max filter, if the filter is min/max, these texels still do not contribute to the result (and the weights do not otherwise affect the min/max filter operation).</span></span>

<span data-ttu-id="337ce-153">篩選模式的完整清單會以列舉值的最小值和最大值顯示在 [**D3D11 \_ 濾波器**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_filter) 列舉中。</span><span class="sxs-lookup"><span data-stu-id="337ce-153">The full list of filter modes is shown in the [**D3D11\_FILTER**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_filter) enumeration with MINIMUM and MAXIMUM in the enumeration values.</span></span>

<span data-ttu-id="337ce-154">這項功能的支援取決於圖層資源的 [第2層](tier-2.md) 支援。</span><span class="sxs-lookup"><span data-stu-id="337ce-154">Support for this feature depends on [Tier 2](tier-2.md) support for tiled resources.</span></span>

## <a name="related-topics"></a><span data-ttu-id="337ce-155">相關主題</span><span class="sxs-lookup"><span data-stu-id="337ce-155">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="337ce-156">磚資源的管線存取</span><span class="sxs-lookup"><span data-stu-id="337ce-156">Pipeline access to tiled resources</span></span>](pipeline-access-to-tiled-resources.md)
</dt> </dl>

 

 