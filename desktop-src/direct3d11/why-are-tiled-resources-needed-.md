---
title: 為何需要磚資源
description: 需要有並排的資源，因此 (GPU) 記憶體會浪費儲存應用程式知道將無法存取的介面區域，而且硬體可以瞭解如何在連續的磚之間進行篩選。
ms.assetid: E2179D65-56D3-481F-A5F3-B9C45A11A179
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d42ccccf66a73d224d8bab9a9d10c87cc330be43
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/20/2020
ms.locfileid: "104971700"
---
# <a name="why-are-tiled-resources-needed"></a><span data-ttu-id="4f3b3-103">為何需要磚資源？</span><span class="sxs-lookup"><span data-stu-id="4f3b3-103">Why are tiled resources needed?</span></span>

<span data-ttu-id="4f3b3-104">需要有並排的資源，因此 (GPU) 記憶體會浪費儲存應用程式知道將無法存取的介面區域，而且硬體可以瞭解如何在連續的磚之間進行篩選。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-104">Tiled resources are needed so less graphics processing unit (GPU) memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles.</span></span>

<span data-ttu-id="4f3b3-105">在圖形系統 (也就是，作業系統、顯示驅動程式和圖形硬體) 不會有並排的資源支援，圖形系統會以 subresource 的細微性來管理所有的 Direct3D 記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-105">In a graphics system (that is, the operating system, display driver, and graphics hardware) without tiled resource support, the graphics system manages all Direct3D memory allocations at subresource granularity.</span></span> <span data-ttu-id="4f3b3-106">若為 [緩衝區](overviews-direct3d-11-resources-buffers.md)，整個緩衝區都是 subresource。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-106">For a [Buffer](overviews-direct3d-11-resources-buffers.md), the entire Buffer is the subresource.</span></span> <span data-ttu-id="4f3b3-107">針對 [材質](overviews-direct3d-11-resources-textures.md) (例如， [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)) ，每個 mip 層級都是一個 subresource;針對材質陣列 (例如， [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)) ，指定陣列配量的每個 mip 層級都是 subresource。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-107">For a [Texture](overviews-direct3d-11-resources-textures.md) (for example, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)), each mip level is a subresource; for a texture array (for example, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), each mip level at a given array slice is a subresource.</span></span> <span data-ttu-id="4f3b3-108">圖形系統只會公開在此子資源資料粒度上管理配置之對應的功能。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-108">The graphics system only exposes the ability to manage the mapping of allocations at this subresource granularity.</span></span> <span data-ttu-id="4f3b3-109">在並排顯示的資源環境中，「對應」是指讓 GPU 可以看到資料。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-109">In the context of tiled resources, "mapping" refers to making data visible to the GPU.</span></span>

<span data-ttu-id="4f3b3-110">假設應用程式了解特定轉譯作業只需要存取圖片 Mipmap 鏈的一小部分 (甚至可能不到特定 Mipmap 的完整區域)。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-110">Suppose an application knows that a particular rendering operation only needs to access a small portion of an image mipmap chain (perhaps not even the full area of a given mipmap).</span></span> <span data-ttu-id="4f3b3-111">理想上來說，該應用程式可能會向圖形系統通知這項需求。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-111">Ideally, the app could inform the graphics system about this need.</span></span> <span data-ttu-id="4f3b3-112">則圖形系統之後便只會確保所需的記憶體在 GPU 上對應，而不會為太多記憶體進行分頁。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-112">The graphics system would then only bother to ensure that the needed memory is mapped on the GPU without paging in too much memory.</span></span> <span data-ttu-id="4f3b3-113">實際上，如果沒有並排的資源支援，圖形系統只會收到需要在 GPU 上以 subresource (細微性對應的記憶體相關資訊，例如，可) 存取的完整 mipmap 層級範圍。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-113">In reality, without tiled resource support, the graphics system can only be informed about the memory that needs to be mapped on the GPU at subresource granularity (for example, a range of full mipmap levels that could be accessed).</span></span> <span data-ttu-id="4f3b3-114">圖形系統中不會發生隨選失敗，所以可能導致必須使用許多額外的 GPU 記憶體，讓完整子資源對應搶先在參照記憶體中任何部分的轉譯命令執行之前完成。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-114">There is no demand faulting in the graphics system either, so potentially a lot of excess GPU memory must be used to make full subresources mapped before a rendering command that references any part of the memory is executed.</span></span> <span data-ttu-id="4f3b3-115">這只是在 Direct3D 中難以使用大型記憶體配置的一個問題，而不會有並排的資源支援。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-115">This is just one issue that makes the use of large memory allocations difficult in Direct3D without tiled resource support.</span></span>

<span data-ttu-id="4f3b3-116">Direct3D 11 支援在指定的一端具有最多16384圖元的 [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) 介面。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-116">Direct3D 11 supports [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) surfaces with up to 16384 pixels on a given side.</span></span> <span data-ttu-id="4f3b3-117">長寬為 16384 x 16384 且每像素 4 個位元組的影像會消耗 1 GB 的視訊記憶體 (新增 Mipmap 則會消耗加倍的量)。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-117">An image that is 16384 wide by 16384 tall and 4 bytes per pixel would consume 1GB of video memory (and adding mipmaps would double that amount).</span></span> <span data-ttu-id="4f3b3-118">在實際應用上，幾乎不需要在單一轉譯作業中參照完整 1GB 的大小。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-118">In practice, all 1GB would rarely need to be referenced in a single rendering operation.</span></span>

<span data-ttu-id="4f3b3-119">有些遊戲開發人員會用最大至 128k x 128K 的大小塑造地型表面。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-119">Some game developers model terrain surfaces as large as 128K by 128K.</span></span> <span data-ttu-id="4f3b3-120">讓這種作法能在現有 GPU 上運作的方式，是將表面分解為硬體能夠處理的小型磚。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-120">The way they get this to work on existing GPUs is to break the surface into tiles that are small enough for hardware to handle.</span></span> <span data-ttu-id="4f3b3-121">應用程式必須了解需要將哪個磚載入 GPU 上紋理的快取內，這也就是軟體分頁系統的作用。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-121">The application must figure out which tiles might be needed and load them into a cache of textures on the GPU - a software paging system.</span></span> <span data-ttu-id="4f3b3-122">這種方法的主要缺點是，硬體不知道正在進行的分頁作業：當影像的一部分需要在跨越圖格的螢幕上顯示時，硬體並不知道如何執行固定函式 (也就是有效率地) 篩選整個磚。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-122">A significant downside to this approach comes from the hardware not knowing anything about the paging that is going on: When a part of an image needs to be shown on screen that straddles tiles, the hardware does not know how to perform fixed function (that is, efficient) filtering across tiles.</span></span> <span data-ttu-id="4f3b3-123">這表示必須在著色器程式碼中使用手動紋理篩選，以管理應用程式本身的軟體並排 (如果想要使用高品質非等向性篩選，成本將會變得很高)，以及 (或) 必須浪費記憶體在磚上製作包含鄰近磚資料的裝訂邊，以便固定功能硬體篩選得以繼續提供協助。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-123">This means the application managing its own software tiling must resort to manual texture filtering in shader code (which becomes very expensive if a good quality anisotropic filter is desired) and/or waste memory authoring gutters around tiles that contain data from neighboring tiles so that fixed function hardware filtering can continue to provide some assistance.</span></span>

<span data-ttu-id="4f3b3-124">如果表面配置的並排標記法可能是圖形系統中的第一個類別功能，應用程式可能會告訴硬體有哪些磚可供使用。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-124">If a tiled representation of surface allocations could be a first class feature in the graphics system, the application could tell the hardware which tiles to make available.</span></span> <span data-ttu-id="4f3b3-125">如此一來，就能浪費較少 GPU 記憶體在儲存應用程式未存取的表面區域上，且硬體會了解如何進行跨相鄰磚篩選，減輕開發人員在執行軟體並排時所遇到的一些麻煩。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-125">In this way, less GPU memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles, alleviating some of the pain experienced by developers who perform software tiling on their own.</span></span>

<span data-ttu-id="4f3b3-126">但若要提供完整的解決方案，有些項目必須先處理完成，像是不論是否支援表面上的並排，目前最大的表面維度是 16384，這和應用程式想要的 128K+ 差距很大。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-126">But to provide a complete solution, something must be done to deal with the fact that, independent of whether tiling within a surface is supported, the maximum surface dimension is currently 16384 - nowhere near the 128K+ that applications already want.</span></span> <span data-ttu-id="4f3b3-127">僅讓硬體支援較大的紋理大小是一種方法，但採取此方法需要花費大量費用和 (或) 其他方面的取捨。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-127">Just requiring the hardware to support larger texture sizes is one approach, however there are significant costs and/or tradeoffs to going this route.</span></span> <span data-ttu-id="4f3b3-128">Direct3D 11 的材質篩選路徑和轉譯路徑的精確度，在支援16K 紋理的精確度方面已有更高的精確度，例如在轉譯期間支援的區住範圍，或是在篩選時支援從介面邊緣換行的材質。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-128">Direct3D 11's texture filter path and rendering path are already saturated in terms of precision in supporting 16K textures with the other requirements, such as supporting viewport extents falling off the surface during rendering, or supporting texture wrapping off the surface edge during filtering.</span></span> <span data-ttu-id="4f3b3-129">可能需要進行取捨，像是紋理大小增加超過 16K 時，功能或精確度會在某方面失效。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-129">A possibility is to define a tradeoff such that as the texture size increases beyond 16K, functionality/precision is given up in some manner.</span></span> <span data-ttu-id="4f3b3-130">即使在功能上做出這項讓步，還是可能需要額外的硬體效能，才能提升整體硬體系統的處理性能，以轉換至更大的紋理大小。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-130">Even with this concession however, additional hardware costs might be required in terms of addressing capability throughout the hardware system to go to larger texture sizes.</span></span>

<span data-ttu-id="4f3b3-131">當紋理變得非常大時會浮現一個問題，那就是單精確度浮點數紋理座標 (以及已與座標建立關聯的內插運算，用以支援點陣化) 將用完精確度，因此無法準確指定表面上的位置。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-131">One issue that comes into play as textures get very large is that single precision floating point texture coordinates (and the associated interpolators to support rasterization) run out of precision to specify locations on the surface accurately.</span></span> <span data-ttu-id="4f3b3-132">在這之後會發生抖動紋理篩選。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-132">Jittery texture filtering would ensue.</span></span> <span data-ttu-id="4f3b3-133">這時其中一個較為昂貴的選項是需要雙精確度內插運算支援，但在有其他選擇時，此選項可能會有點大材小用。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-133">One expensive option would be to require double precision interpolator support, though that could be overkill given a reasonable alternative.</span></span>

<span data-ttu-id="4f3b3-134">磚資源的替代名稱是「稀疏材質」。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-134">An alternate name for tiled resources is "sparse texture."</span></span> <span data-ttu-id="4f3b3-135">「疏鬆」表達了並排資源的本質，以及並排它們的主要原因，也就是說這些資源並非會一次對應完畢。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-135">"Sparse" conveys both the tiled nature of the resources as well as perhaps the primary reason for tiling them - that not all of them are expected to be mapped at once.</span></span> <span data-ttu-id="4f3b3-136">事實上，應用程式可能會撰寫並排的資源，在此資源中，不會刻意針對所有區域和資源的 mips 撰寫任何資料。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-136">In fact, an application could conceivably author a tiled resource in which no data is authored for all regions+mips of the resource, intentionally.</span></span> <span data-ttu-id="4f3b3-137">因此，內容本身可能是稀疏的，而且在指定的時間內，GPU 記憶體中的內容對應會是 (更多稀疏) 的子集。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-137">So, the content itself could be sparse, and the mapping of the content in GPU memory at a given time would be a subset of that (even more sparse).</span></span>

<span data-ttu-id="4f3b3-138">可由並排顯示的資源提供的另一個案例，是讓多個不同維度/格式的資源分享相同的記憶體。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-138">Another scenario that could be served by tiled resources is enabling multiple resources of different dimensions/formats to share the same memory.</span></span> <span data-ttu-id="4f3b3-139">有時候應用程式有無法同時使用的專屬資源集，或建立來僅供短暫期間使用並在使用後就刪除的資源，而在資源刪除後接著再建立其他資源。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-139">Sometimes applications have exclusive sets of resources that are known not to be used at the same time, or resources that are created only for very brief use and then destroyed, followed by creation of other resources.</span></span> <span data-ttu-id="4f3b3-140">可能會超出「已並排顯示的資源」的一種類型，就是可以讓使用者將多個不同的資源指向相同的 () 記憶體重迭。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-140">A form of generality that can fall out of "tiled resources" is that it is possible to allow the user to point multiple different resources at the same (overlapping) memory.</span></span> <span data-ttu-id="4f3b3-141">意即，可以從應用程式觀點將「資源」的建立和刪除 (定義維度或格式等項目) 和具備基礎資源之記憶體的管理分離。</span><span class="sxs-lookup"><span data-stu-id="4f3b3-141">In other words, the creation and destruction of "resources" (which define a dimension/format and so on) can be decoupled from the management of the memory underlying the resources from the application's point of view.</span></span>

## <a name="related-topics"></a><span data-ttu-id="4f3b3-142">相關主題</span><span class="sxs-lookup"><span data-stu-id="4f3b3-142">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="4f3b3-143">磚資源</span><span class="sxs-lookup"><span data-stu-id="4f3b3-143">Tiled resources</span></span>](tiled-resources.md)
</dt> </dl>

 

 